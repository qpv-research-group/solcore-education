[
  {
    "objectID": "solar-cell-simulation/notebooks/1b-simple_cell.html",
    "href": "solar-cell-simulation/notebooks/1b-simple_cell.html",
    "title": "solcore-education",
    "section": "",
    "text": "In this script, we will build on the TMM model from example 1(a) and look at the effects of interference.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom solcore import material, si\nfrom solcore.solar_cell import Layer\nfrom solcore.absorption_calculator import calculate_rat, OptiStack\nimport seaborn as sns\n\nFirst, let’s define some materials:\n\nSi = material(\"Si\")\nSiN = material(\"Si3N4\")()\nAg = material(\"Ag\")()\n\nNote the second set of brackets (or lack thereof). The Solcore material system essentially operates in two stages; we first call the material function with the name of the material we want to use, for example Si = material(“Si”), which creates a general Python class corresponding to that material. We then call this class to specify further details, such as the temperature, doping level, or alloy composition (where relavant). This happens below when defining Si_n and Si_p; both are use the Si class defined above, and adding further details to the material. For the definitions of SiN and Ag above, we do both steps in a single line, hence the two sets of brackets.\n\nSi_n = Si(Nd=si(\"1e21cm-3\"), hole_diffusion_length=si(\"10um\"))\nSi_p = Si(Na=si(\"1e16cm-3\"), electron_diffusion_length=si(\"400um\"))\n\nTo look at the effect of interference in the Si layer at different thicknesses, we make a list of thicknesses to test (evenly spaced on a log scale from 400 nm to 300 um):\n\nSi_thicknesses = np.linspace(np.log(0.4e-6), np.log(300e-6), 8)\nSi_thicknesses = np.exp(Si_thicknesses)\n\nwavelengths = si(np.linspace(300, 1200, 400), \"nm\")\n\noptions = {\n    \"recalculate_absorption\": True,\n    \"optics_method\": \"TMM\",\n    \"wavelength\": wavelengths\n           }\n\nMake a color palette using the seaborn package to make the plots look nicer\n\ncolors = sns.color_palette('rocket', n_colors=len(Si_thicknesses))\ncolors.reverse()\n\ncreate an ARC layer:\n\nARC_layer = Layer(width=si('75nm'), material=SiN)\n\nNow we are going to loop through the different Si thicknesses generated above, and create a simple solar cell-like structure. Because we will only do an optical calculation, we don’t need to define a junction and can just make a simple stack of layers.\nWe then calculate reflection, absorption and transmission (RAT) for two different situations: 1. a fully coherent stack 2. assuming the silicon layer is incoherent. This means that light which enters the Si layer cannot interfere with itself, but light in the ARC layer can still show interference. In very thick layers (much thicker than the wavelength of light being considered) this is likely to be more physically accurate because real light does not have infinite coherence length; i.e. if you measured wavelength-dependent transmission or reflection of a Si wafer hundreds of microns thick you would not expect to see interference fringes.\nPLOT 1\n\nplt.figure()\n\nfor i1, Si_t in enumerate(Si_thicknesses):\n\n    base_layer = Layer(width=Si_t, material=Si_p) # silicon layer\n    solar_cell = OptiStack([ARC_layer, base_layer]) # OptiStack (optical stack) to feed into calculate_rat function\n\n    # Coherent calculation:\n    RAT_c = calculate_rat(solar_cell, wavelengths*1e9, no_back_reflection=False) # coherent calculation\n    # For historical reasons, Solcore's default setting is to ignore reflection at the back of the cell (i.e. at the\n    # interface between the final material in the stack and the substrate). Hence we need to tell the calculate_rat\n    # function NOT to ignore this reflection (no_back_reflection=False).\n\n    # Calculation assuming no interference in the silicon (\"incoherent\"):\n    RAT_i = calculate_rat(solar_cell, wavelengths*1e9, no_back_reflection=False,\n                          coherent=False, coherency_list=['c', 'i']) # partially coherent: ARC is coherent, Si is not\n\n    # Plot the results:\n    plt.plot(wavelengths*1e9, RAT_c[\"A\"], color=colors[i1], label=str(round(Si_t*1e6, 1)), alpha=0.7)\n    plt.plot(wavelengths*1e9, RAT_i[\"A\"], '--', color=colors[i1])\n\nplt.legend(title=r\"Thickness ($\\mu$m)\")\nplt.xlim(300, 1300)\nplt.ylim(0, 1.02)\nplt.ylabel(\"Absorption\")\nplt.title(\"(1) Absorption in Si with varying thickness\")\nplt.show()\n\n\n\n\nWe can see that the coherent calculations (solid lines) show clear interference fringes which depend on the Si thickness. The incoherent calculations do not have these fringes and seem to lie around the average of the interference fringes. For both sets of calculations, we see increasing absorption as the Si gets thicker, as expected.\nNow we repeat the calculation, but with an Ag substrate under the Si. Previously, we did not specify the substrate and so it was assumed by Solcore to be air (n=1, k=0).\nPLOT 2\n\nplt.figure()\n\nfor i1, Si_t in enumerate(Si_thicknesses):\n\n    base_layer = Layer(width=Si_t, material=Si_p)\n\n    # As before, but now we specify the substrate to be silver:\n    solar_cell = OptiStack([ARC_layer, base_layer], substrate=Ag)\n\n    RAT_c = calculate_rat(solar_cell, wavelengths*1e9, no_back_reflection=False)\n    RAT_i = calculate_rat(solar_cell, wavelengths*1e9, no_back_reflection=False,\n                          coherent=False, coherency_list=['c', 'i'])\n    plt.plot(wavelengths*1e9, RAT_c[\"A\"], color=colors[i1],\n             label=str(round(Si_t*1e6, 1)), alpha=0.7)\n    plt.plot(wavelengths*1e9, RAT_i[\"A\"], '--', color=colors[i1])\n\nplt.legend(title=r\"Thickness ($\\mu$m)\")\nplt.xlim(300, 1300)\nplt.ylim(0, 1.02)\nplt.ylabel(\"Absorption\")\nplt.title(\"(2) Absorption in Si with varying thickness (Ag substrate)\")\nplt.show()\n\n\n\n\nWe see that the interference fringes get more prominent in the coherent calculation, due to higher reflection at the rear Si/Ag surface compared to Ag/Air. We also see a slightly boosted absorption at long wavelengths at all thicknesses, again due to improved reflection at the rear surface\nFinally, we look at the effect of incidence angle and polarization of the light hitting the cell.\nPLOT 3\n\nangles = [0, 30, 60, 70, 80, 89]\n\nARC_layer = Layer(width=si('75nm'), material=SiN)\nbase_layer = Layer(width=si(\"100um\"), material=Si_p)\n\ncolors = sns.cubehelix_palette(n_colors=len(angles))\n\nplt.figure()\n\nfor i1, theta in enumerate(angles):\n\n    solar_cell = OptiStack([ARC_layer, base_layer])\n\n    RAT_s = calculate_rat(solar_cell, wavelengths*1e9, angle=theta,\n                          pol='s',\n                          no_back_reflection=False,\n                          coherent=False, coherency_list=['c', 'i'])\n    RAT_p = calculate_rat(solar_cell, wavelengths*1e9, angle=theta,\n                          pol='p',\n                          no_back_reflection=False,\n                          coherent=False, coherency_list=['c', 'i'])\n\n    plt.plot(wavelengths*1e9, RAT_s[\"A\"], color=colors[i1], label=str(round(theta)))\n    plt.plot(wavelengths*1e9, RAT_p[\"A\"], '--', color=colors[i1])\n\nplt.legend(title=r\"$\\theta (^\\circ)$\")\nplt.xlim(300, 1300)\nplt.ylim(0, 1.02)\nplt.ylabel(\"Absorption\")\nplt.title(\"(3) Absorption in Si with varying thickness\")\nplt.show()\n\n\n\n\nFor normal incidence (\\(\\theta = 0^\\circ\\)), s (solid lines) and p (dashed lines) polarization are equivalent. As the incidence angle increases, in general absorption is higher for p-polarized light (due to lower reflection). Usually, sunlight is modelled as unpolarized light, which computationally is usually done by averaging the results for s and p-polarized light.\nWe have now seen some effects of interference in layers of different thicknesses, and seen the effect of adding a highly reflective substrate. So we already have two strategies for light-trapping/improving the absorption in a solar cell: adding an anti-reflection coating (in example 1a), to reduce front-surface reflection and get more light into the cell, and adding a highly reflective layer at the back, to reduce loss through the back of the cell and keep light trapped in the cell."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1a-simple_cell.html",
    "href": "solar-cell-simulation/notebooks/1a-simple_cell.html",
    "title": "solcore-education",
    "section": "",
    "text": "In this first set of examples, we will look at simple planar solar cells (Si and GaAs).\nIn this script, we will look at the difference between Beer-Lambert absorption calculations, using the Fresnel equations for front-surface reflection, and using the transfer-matrix model.\nFirst, lets import some very commonly-used Python packages:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nNumpy is a Python library which adds supports for multi-dimensional data arrays and matrices, so it is very useful for storing and handling data. You will probably use it in every Solcore script you write. Here, it is imported under the alias ‘np’, which you will see used below. matplotlib is used for making plots, and is imported under the alias ‘plt’. Both the ‘np’ and ‘plt’ aliases are extremely commonly used in Python programming.\nNow, let’s import some things from Solcore (which will be explained as we use them):\n\nfrom solcore import material, si\nfrom solcore.solar_cell import SolarCell, Layer, Junction\nfrom solcore.solar_cell_solver import solar_cell_solver\nfrom solcore.interpolate import interp1d\n\nTo define our solar cell, we first want to define some materials. Then we want to organise those materials into Layers, organise those layers into a Junction, and then finally define a SolarCell with that Junction.\nFirst, let’s define a Si material. Silicon, along with many other semiconductors, dielectrics, and metals common in solar cells, is included in Solcore’s database:\n\nSi = material(\"Si\")\nGaAs = material(\"GaAs\")\n\nThis creates an instance of the Si and GaAs materials. However, to use this in a solar cell we need to do specify some more information, such as the doping level. The ‘si’ function comes in handy here to convert all quantities to based units e.g. m, m^(-3)…\n\nSi_n = Si(Nd=si(\"1e21cm-3\"), hole_diffusion_length=si(\"10um\"), relative_permittivity=11.7)\nSi_p = Si(Na=si(\"1e16cm-3\"), electron_diffusion_length=si(\"400um\"), relative_permittivity=11.7)\n\nNow we define the emitter and base layers we will have in the solar cell; we specify their thickness, the material they are made of and the role they play within the cell (emitter or base)\n\nemitter_layer = Layer(width=si(\"600nm\"), material=Si_n, role='emitter')\nbase_layer = Layer(width=si(\"200um\"), material=Si_p, role='base')\n\ncreate the p-n junction using the layers defined above. We set kind=“DA” to tell Solcore to use the Depletion Approximation in the calculation (we will discuss the different electrical solver options more later on):\n\nSi_junction = Junction([emitter_layer, base_layer], kind=\"DA\")\n\nWavelengths we want to use in the calculations; wavelengths between 300 and 1200 nm, at 200 evenly spaced intervals:\n\nwavelengths = si(np.linspace(300, 1200, 200), \"nm\")\n\nNote that here and above in defining the layers and materials we have used the “si()” function: you can use this to automatically convert quantities in other units to base SI units (e.g. nanometres to metres).\nNow we specify some options for running the calculation. Initially we want to use the Beer-Lambert absorption law to calculate the optics of the cell (“BL”). We set the wavelengths we want to use, and we set “recalculate_absorption” to True so that further down in the script when we try different optics methods, Solcore knows we want to re-calculate the optics of the cell. We specify the options in a Python format called a dictionary:\n\noptions = {\n    \"recalculate_absorption\": True,\n    \"optics_method\": \"BL\",\n    \"wavelength\": wavelengths\n           }\n\nDefine the solar cell; in this case it is very simple and we just have a single junction:\n\nsolar_cell = SolarCell([Si_junction])\n\nNow use solar_cell_solver to calculate the QE of the cell; we can ask solar_cell_solver to calculate ‘qe’, ‘optics’ or ‘iv’.\n\nsolar_cell_solver(solar_cell, 'qe', options)\n\nSolving optics of the solar cell...\nSolving QE of the solar cell...\n\n\nPLOT 1: plotting the QE in the Si junction, as well as the fraction of light absorbed in the junction and reflected:\n\nplt.figure()\nplt.plot(wavelengths*1e9, 100*solar_cell[0].eqe(wavelengths), 'k-', label=\"EQE\")\nplt.plot(wavelengths*1e9, 100*solar_cell[0].layer_absorption, label='Absorptance (A)')\nplt.plot(wavelengths*1e9, 100*solar_cell.reflected, label='Reflectance (R)')\nplt.legend()\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"QE/Absorptance (%)\")\nplt.title(\"(1) QE of Si cell - Beer-Lambert absorption\")\nplt.show()\n\n\n\n\nNow, to make this calculation a bit more realistic, there are a few things we could do. We could load some measured front surface reflectance from a file, or we could calculate the reflectance. To calculate the reflectance, there are many approaches we could take; we are going to explore two of them here.\nIf we assume the silicon is infinitely thick (or at least much thicker than the wavelengths we care about) then the reflectance will approach the reflectivity of a simple air/Si interface. We can calculate what this is using the Fresnel equation for reflectivity: https://en.wikipedia.org/wiki/Fresnel_equations\n\ndef calculate_R_Fresnel(incidence_n, transmission_n, wl):\n    # return a function that gives the value of R (at normal incidence) at the input wavelengths\n\n    Rs = np.abs((incidence_n - transmission_n)/(incidence_n + transmission_n))**2\n\n    return interp1d(wl, Rs)\n\ncomplex reflective index at our wavelengths for the transmission medium (Si). The incidence_n = 1 (air).\n\ntrns_n = Si_n.n(wavelengths) + 1j*Si_n.k(wavelengths)\nreflectivity_fn = calculate_R_Fresnel(1, trns_n, wavelengths)\n\nwe define the solar cell again, with the same layers but now supplying the function for the externally-calculated reflectivity, and calculate the optics (reflection, absorption, transmission):\n\nsolar_cell_fresnel = SolarCell([Si_junction], reflectivity=reflectivity_fn)\n\nsolar_cell_solver(solar_cell_fresnel, 'optics', options)\n\nSolving optics of the solar cell...\n\n\nFinally, we do the same again but now instead of supplying the external reflectivity we ask set the optics_method to “TMM” (Transfer Matrix Method), to correctly calculate reflection at the front surface:\n\nSi_junction = Junction([emitter_layer, base_layer], kind=\"DA\")\n\nsolar_cell_TMM = SolarCell([Si_junction])\n\nSet some more options:\n\noptions[\"optics_method\"] = \"TMM\"\nvoltages = np.linspace(0, 1.1, 100)\noptions[\"light_iv\"] = True\noptions[\"mpp\"] = True\noptions[\"voltages\"] = voltages\n\nwe calculate the QE and the IV (we set the light_iv option to True; if we don’t do this, Solcore just calculates the dark IV). We also ask Solcore to find the maximum power point (mpp) so we can get the efficiency.\n\nsolar_cell_solver(solar_cell_TMM, 'iv', options)\nsolar_cell_solver(solar_cell_TMM, 'qe', options)\n\nSolving optics of the solar cell...\nTreating layer(s) 1 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\nSolving optics of the solar cell...\nTreating layer(s) 1 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving QE of the solar cell...\n\n\nPLOT 2: here we plot the reflection, transmission, and absorption calculated with the Fresnel equation defined above, and with the TMM solver in Solcore, showing that for this simple situation (no anti-reflection coating, thick Si junction) they are exactly equivalent.\n\nplt.figure()\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.reflected, color='firebrick', label = \"R (TMM)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_fresnel.reflected, '--', color='orangered', label = \"R (Fresnel)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.absorbed, color='dimgrey', label = \"A (TMM)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_fresnel.absorbed, '--', color='lightgrey', label = \"A (Fresnel)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.transmitted, color='blue', label = \"T (TMM)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_fresnel.transmitted, '--', color='dodgerblue', label = \"T (Fresnel)\")\nplt.ylim(0, 100)\nplt.legend()\nplt.title(\"(2) Optics of Si cell - Fresnel/TMM\")\nplt.show()\n\n\n\n\nPLOT 3: As above for the TMM calculation, plotting the EQE as well, which will be slightly lower than the absorption because not all the carriers are collected. Comparing to plot (1), we can see we now have lower absorption due to the inclusion of front surface reflection.\n\nplt.figure()\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM[0].eqe(wavelengths), 'k-', label=\"EQE\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM[0].layer_absorption, label='A')\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.reflected, label=\"R\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.transmitted, label=\"T\")\nplt.title(\"(3) QE of Si cell (no ARC) - TMM\")\nplt.legend()\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"QE/Absorptance (%)\")\nplt.ylim(0, 100)\nplt.show()\n\n\n\n\nNow we will try adding a simple anti-reflection coating (ARC), a single layer of silicon nitride (Si3N4):\n\nSiN = material(\"Si3N4\")()\n\nSi_junction = Junction([emitter_layer, base_layer], kind=\"DA\")\n\nsolar_cell_TMM_ARC = SolarCell([Layer(width=si(75, \"nm\"), material=SiN), Si_junction])\n\nsolar_cell_solver(solar_cell_TMM_ARC, 'qe', options)\nsolar_cell_solver(solar_cell_TMM_ARC, 'iv', options)\n\nSolving optics of the solar cell...\nTreating layer(s) 2 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving QE of the solar cell...\nSolving optics of the solar cell...\nTreating layer(s) 2 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\n\n\nPLOT 4: Absorption, EQE, reflection and transmission for the cell with a simple one-layer ARC. We see the reflection is significantly reduced from the previous plot leading to higher absorption/EQE.\n\nplt.figure()\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM_ARC[1].eqe(wavelengths), 'k-', label=\"EQE\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM_ARC[1].layer_absorption, label='A')\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM_ARC.reflected, label=\"R\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM_ARC.transmitted, label=\"T\")\nplt.legend()\nplt.title(\"(4) QE of Si cell (ARC) - TMM\")\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"QE/Absorptance (%)\")\nplt.ylim(0, 100)\nplt.show()\n\n\n\n\nPLOT 5: Compare the IV curves of the cells with and without an ARC. The efficiency is also shown on the plot. Note that because we didn’t specify a light source, Solcore will assume we want to use AM1.5G; in later examples we will set the light source used for IV simulations explicitly.\n\nplt.figure()\nplt.plot(voltages, -solar_cell_TMM[0].iv(voltages)/10, label=\"No ARC\")\nplt.plot(voltages, -solar_cell_TMM_ARC[1].iv(voltages)/10, label=\"75 nm SiN\")\nplt.text(0.5, solar_cell_TMM.iv[\"Isc\"]/10, str(round(solar_cell_TMM.iv[\"Eta\"]*100, 1)) + ' %')\nplt.text(0.5, solar_cell_TMM_ARC.iv[\"Isc\"]/10, str(round(solar_cell_TMM_ARC.iv[\"Eta\"]*100, 1)) + ' %')\nplt.ylim(0, 38)\nplt.xlim(0, 0.8)\nplt.legend()\nplt.xlabel(\"V (V)\")\nplt.ylabel(r\"J (mA/cm$^2$)\")\nplt.title(\"(5) IV curve of Si cell with and without ARC\")\nplt.show()\n\n\n\n\nWe see that the cell with an ARC has a significantly higher Jsc, and a slightly higher Voc, than the bare Si cell. In reality, most Si cells have a textured surface rather than a planar surface with an ARC; this will be discussed later in the course.\nOverall, some things we can take away from the examples in this script: - The Beer-Lambert law is a very simple way to calculate absorption in a cell, but won’t take into account important effects such as front-surface reflection or the effects of anti-reflection coatings - Using the transfer-matrix method (TMM) we can account for front surface reflection and interference effects which make e.g. ARCs effective. In the simple situation of a thick cell without any front surface layers, it is equivalent to simply calculation the reflection with the Fresnel equations and assuming Beer-Lambert absorption in the cell. - Adding a simple, one-layer ARC can significantly reduce front-surface reflection for a single-junction cell, leading to improved short-circuit current."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "solcore-education",
    "section": "",
    "text": "Welcome to the solcore-education website. The sidebar on the left lists the current examples for the course."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  }
]