[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "This is the website for the solcore-education GitHub, where we host readable versions of Solcore and RayFlare examples (see the Tutorials tab above). Note that this is not an introductory Python course, or a course about the fundamentals of solar cells.\nThe examples on this website are hosted in Jupyter Notebook (.ipynb) format for readability. To run the examples yourself, you can find standard .py versions on the GitHub here. We recommend using these rather than the Notebook versions.\nPackage requirements\nTo use the examples on this website, you will need to install Solcore and RayFlare (the links take you to installation instructions for each package). In the simplest case, you can install them with:\npip install solcore rayflare jupyter\nBut this will not install all functionality, as detailed in the documentation for both packages.\nThe only other dependency, which is used for plotting, is seaborn, which you can install simply with:\npip install seaborn"
  },
  {
    "objectID": "solcore-workshop/notebooks/6b-arc_optimization.html",
    "href": "solcore-workshop/notebooks/6b-arc_optimization.html",
    "title": "Section 6b: Optimizing an ARC",
    "section": "",
    "text": "In the previous example, we introduced a simple one-layer anti-reflection coating (ARC); ARCs are a standard feature of all high-efficiency solar cells. But how do you find out the right thickness for the anti-reflection coating layer(s) (or the right dimensions for a light-trapping grating, or some other structure in your cell)? This is where optimization comes in. Here, we will look at a very simple ‘brute-force’ optimization for a single or double-layer ARC.\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\nfrom solcore import material, si\nfrom solcore.solar_cell import Layer\nfrom solcore.light_source import LightSource\nfrom solcore.absorption_calculator import search_db, download_db\n\nfrom rayflare.transfer_matrix_method import tmm_structure\nfrom rayflare.options import default_options\nimport seaborn as sns"
  },
  {
    "objectID": "solcore-workshop/notebooks/6b-arc_optimization.html#setting-up",
    "href": "solcore-workshop/notebooks/6b-arc_optimization.html#setting-up",
    "title": "Section 6b: Optimizing an ARC",
    "section": "Setting up",
    "text": "Setting up\nWe set some options, as in previous examples, setting the wavelengths and defining the incident spectrum. We are going to do a partially coherent calculation, treating the ARC as a coherent layer and the thick Si layer as incoherent (no thin-film interference).\n\nopts = default_options()\n\nwavelengths = np.linspace(300, 1200, 800)*1e-9\n\nAM15g = LightSource(source_type=\"standard\", version=\"AM1.5g\", output_units=\"photon_flux_per_m\")\nspectrum = AM15g.spectrum(wavelengths)[1]\nnormalised_spectrum = spectrum/np.max(spectrum)\n\nopts.wavelengths = wavelengths\nopts.coherent = False\nopts.coherency_list = ['c', 'i']\n\nSi = material(\"Si\")()\nSiN = material(\"Si3N4\")()\nAg = material(\"Ag\")()\nAir = material(\"Air\")()"
  },
  {
    "objectID": "solcore-workshop/notebooks/6b-arc_optimization.html#single-layer-arc",
    "href": "solcore-workshop/notebooks/6b-arc_optimization.html#single-layer-arc",
    "title": "Section 6b: Optimizing an ARC",
    "section": "Single-layer ARC",
    "text": "Single-layer ARC\nHere, we will calculate the behaviour of a single-layer SiN anti-reflection coating on Si while changing the ARC thickness between 0 and 200 nm. We will consider two values to optimize: the mean reflectance mean_R, and the reflectance weighted by the photon flux in an AM1.5G spectrum (weighted_R). The reason for considering the second value is that it is more useful to suppress reflection at wavelengths where there are more photons which could be absorbed by the cell (up to the cell’s bandgap).\nWe will loop through the different ARC thicknesses in d_range, build the structure for each case, and then calculate the reflectance. We then save the mean reflected and weighted mean reflectance in the corresponding arrays. We also plot the reflectance for each 15th loop (this is just so the plot does not get too crowded).\n\nd_range = np.linspace(0, 200, 200)\n\nmean_R = np.empty_like(d_range)\nweighted_R = np.empty_like(d_range)\n\ncols = sns.cubehelix_palette(np.ceil(len(d_range)/15))\n\nplt.figure()\njcol = 0\n\nfor i1, d in enumerate(d_range):\n\n    struct = tmm_structure([Layer(si(d, 'nm'), SiN), Layer(si('300um'), Si)], incidence=Air, transmission=Ag)\n    RAT = struct.calculate(opts)\n\n    if i1 % 15 == 0:\n        plt.plot(wavelengths*1e9, RAT['R'], label=str(np.round(d, 0)), color=cols[jcol])\n        jcol += 1\n\n    mean_R[i1] = np.mean(RAT['R'])\n    weighted_R[i1] = np.mean(RAT['R']*normalised_spectrum)\n\nplt.legend()\nplt.show()\n\n\n\n\nWe now find at which index mean_R and weighted_R are minimised using np.argmin, and use this to print the ARC thickness at which this occurs (rounded to 1 decimal place).\n\nprint('Minimum mean reflection occurs at d = ' + str(np.round(d_range[np.argmin(mean_R)], 1)) + ' nm')\nprint('Minimum weighted reflection occurs at d = ' + str(np.round(d_range[np.argmin(weighted_R)], 1)) + ' nm')\n\nMinimum mean reflection occurs at d = 70.4 nm\nMinimum weighted reflection occurs at d = 75.4 nm\n\n\nWe see that the values of \\(d\\) for the two different ways of optimizing are very similar, but not exactly the same, as we would expect. The minimum in both cases occurs around 70 nm. We can also plot the variation of the mean and weighted \\(R\\) with ARC thickness \\(d\\):\n\nplt.figure()\nplt.plot(d_range, mean_R, label='Mean reflection')\nplt.plot(d_range[np.argmin(mean_R)], np.min(mean_R), 'ok')\nplt.plot(d_range, weighted_R, label='Weighted mean reflection')\nplt.plot(d_range[np.argmin(weighted_R)], np.min(weighted_R), 'ok')\nplt.xlabel('d$_{SiN}$')\nplt.ylabel('(Weighted) mean reflection 300-1200 nm')\nplt.legend()\nplt.show()\n\n\n\n\nNow, to see what the reflectance looks like for the optimized structure, we make new tmm_structures with the optimal values and calculate and plot the reflectance:\n\nstruct = tmm_structure([Layer(si(d_range[np.argmin(mean_R)], 'nm'), SiN), Layer(si('300um'), Si)], incidence=Air, transmission=Ag)\nRAT_1 = struct.calculate(opts)\n\nstruct = tmm_structure([Layer(si(d_range[np.argmin(weighted_R)], 'nm'), SiN), Layer(si('300um'), Si)], incidence=Air, transmission=Ag)\nRAT_2 = struct.calculate(opts)\n\nplt.figure()\nplt.plot(wavelengths*1e9, RAT_1['R'], label='Mean R minimum')\nplt.plot(wavelengths*1e9, RAT_2['R'], label='Weighted R minimum')\nplt.legend()\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"R\")\nplt.show()\n\n\n\n\nWe see that the two reflectance curves are very similar, as expected because the layer thicknesses are very similar."
  },
  {
    "objectID": "solcore-workshop/notebooks/6b-arc_optimization.html#double-layer-arc",
    "href": "solcore-workshop/notebooks/6b-arc_optimization.html#double-layer-arc",
    "title": "Section 6b: Optimizing an ARC",
    "section": "Double-layer ARC",
    "text": "Double-layer ARC\nWe will now consider a similar situation, but for a double-layer MgF\\(_2\\)/Ta\\(_2\\)O\\(_5\\) ARC on GaAs.\nSolcore can directly interface with the database from www.refractiveindex.info, which contains around 3000 sets of data for a large number of different materials. Before the first use, it is necessary to download the database. This only needs to be done once, so you can comment this line out after it’s done:\n\ndownload_db(confirm=True) # only needs to be done once\n\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaking request to https://refractiveindex.info/download/database/rii-database-2021-07-18.zip\nDownloaded and extracting...\nWrote /var/folders/60/mjbn28rj1ql_r4w004g_ryt00000gq/T/tmpf1zt2idh/database from https://refractiveindex.info/download/database/rii-database-2021-07-18.zip\nLOG: 2746,other,PtAl2,Chen : Bad Material YAML File.\n***Wrote SQLite DB on  /Users/phoebe/.solcore/nk/nk.db\n\n\nWe search for materials in the refractiveindex.info database, and use only the part of the solar spectrum relevant for absorption in GaAs (in this case, there is no benefit to reducing absorption above the GaAs bandgap around 900 nm). We will only consider the weighted mean \\(R\\) in this case. Since all the layers in the structure are relatively thin compared to the wavelengths of light, we do a coherent calculation.\n\npageid_MgF2 = search_db(os.path.join(\"MgF2\", \"Rodriguez-de Marcos\"))[0][0]\npageid_Ta2O5 = search_db(os.path.join(\"Ta2O5\", \"Rodriguez-de Marcos\"))[0][0]\n\nGaAs = material(\"GaAs\")()\nMgF2 = material(str(pageid_MgF2), nk_db=True)()\nTa2O5 = material(str(pageid_Ta2O5), nk_db=True)()\n\nMgF2_thickness = np.linspace(50, 100, 20)\nTa2O5_thickness = np.linspace(30, 80, 20)\n\nweighted_R_matrix = np.zeros((len(MgF2_thickness), len(Ta2O5_thickness)))\n\nwavelengths_GaAs = wavelengths[wavelengths &lt; 900e-9]\nnormalised_spectrum_GaAs = normalised_spectrum[wavelengths &lt; 900e-9]\n\nopts.coherent = True\nopts.wavelengths = wavelengths_GaAs\n\nWe now have two thicknesses to loop through; otherwise, the procedure is similar to the single-layer ARC example.\n\nfor i1, d_MgF2 in enumerate(MgF2_thickness):\n    for j1, d_Ta2O5 in enumerate(Ta2O5_thickness):\n        struct = tmm_structure([Layer(si(d_MgF2, 'nm'), MgF2), Layer(si(d_Ta2O5, 'nm'), Ta2O5),\n                                Layer(si('20um'), GaAs)],\n                               incidence=Air, transmission=Ag)\n        RAT = struct.calculate(opts)\n\n        weighted_R_matrix[i1, j1] = np.mean(RAT['R'] * normalised_spectrum_GaAs)\n\n# find the row and column indices of the minimum weighted R value\nri, ci = np.unravel_index(weighted_R_matrix.argmin(), weighted_R_matrix.shape)\n\nWe plot the total absorption (\\(1-R\\)) in the structure with the optimized ARC, and print the thicknesses of MgF\\(_2\\) and Ta\\(_2\\)O\\(_5\\) at which this occurs:\n\nplt.figure()\nplt.imshow(1-weighted_R_matrix, extent=[min(Ta2O5_thickness), max(Ta2O5_thickness),\n                                        min(MgF2_thickness), max(MgF2_thickness)],\n           origin='lower', aspect='equal')\nplt.plot(Ta2O5_thickness[ci], MgF2_thickness[ri], 'xk')\nplt.colorbar()\nplt.xlabel(\"Ta$_2$O$_5$ thickness (nm)\")\nplt.ylabel(\"MgF$_2$ thickness (nm)\")\nplt.show()\n\nprint(\"Minimum reflection occurs at MgF2 / Ta2O5 thicknesses of %.1f / %.1f nm \"\n     % (MgF2_thickness[ri], Ta2O5_thickness[ci]))\n\n\n\n\nMinimum reflection occurs at MgF2 / Ta2O5 thicknesses of 73.7 / 53.7 nm \n\n\nFor these two examples, where we are only trying to optimize one and two parameters respectively across a relatively small range, using a method (TMM) which executes quickly, brute force searching is possible. However, as we introduce more parameters, a wider parameter space, and slower simulation methods, it may no longer be computationally tractable; in that case, using for example differential evolution or other types of numerical optimization may be more appropriate (see this example)."
  },
  {
    "objectID": "solcore-workshop/notebooks/6b-arc_optimization.html#questions",
    "href": "solcore-workshop/notebooks/6b-arc_optimization.html#questions",
    "title": "Section 6b: Optimizing an ARC",
    "section": "Questions",
    "text": "Questions\n\nApart from varying the thickness of the layers, what else could we change?\nHow do we know where to start when desining an ARC (layer thickness/material)?"
  },
  {
    "objectID": "solcore-workshop/notebooks/10-perovskite_Si_rt.html",
    "href": "solcore-workshop/notebooks/10-perovskite_Si_rt.html",
    "title": "Section 10: Perovskite-Si tandem cell with pyramidal surfaces",
    "section": "",
    "text": "This example shows how you can simulate a perovskite-Si tandem cell with pyramidal surface textures, where the perovskite and other surface layers are assumed to be deposited conformally (i.e., also in a pyramid shape) on top of the Si. The perovskite optical constants are from this paper, while the structure is based on this paper We will calculate total reflection, transmission and absorption per layer as well as the wavelength-dependent absorption profiles in the perovskite and Si, which can be used in e.g. device simulations. We will look at the effect of treating the layers deposited on Si (including the perovskite) coherently or incoherently.\nFirst, import relevant packages and RayFlare functions:\nimport numpy as np\nimport os\n\nfrom solcore.structure import Layer\nfrom solcore.constants import q\nfrom solcore import material\nfrom solcore.absorption_calculator import search_db, download_db\nfrom solcore.light_source import LightSource\n\nfrom rayflare.textures import regular_pyramids\nfrom rayflare.options import default_options\nfrom rayflare.ray_tracing import rt_structure\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfrom cycler import cycler\nNow we set some relevant options. We will scan across 20 x 20 surface points of the pyramid unit cell between 300 and 1200 nm, for unpolarized, normally-incident light. The randomize_surface option is set to True to prevent correlation between the incident position on the front and rear pyramids. The n_jobs option is set to -1, which means that all available cores will be used. If you want to use all but one core, change this to -2 etc. We also need to provide a project_name to save the lookup tables which will be calculated using TMM to use during ray-tracing.\nwavelengths = np.linspace(300, 1200, 40) * 1e-9\n\nAM15G = LightSource(source_type=\"standard\", version=\"AM1.5g\", x=wavelengths,\n                    output_units=\"photon_flux_per_m\")\n\noptions = default_options()\noptions.wavelengths = wavelengths\noptions.nx = 20\noptions.ny = options.nx\noptions.n_rays = 4 * options.nx**2\noptions.depth_spacing = 1e-9\noptions.pol = \"u\"\noptions.I_thresh = 1e-3\noptions.project_name = \"perovskite_Si_rt\"\noptions.randomize_surface = True\noptions.n_jobs = -1 # use all cores; to use all but one, change to -2 etc.\nWe define our materials. Note that some of these are custom materials added to the database; we only need to do this once. We then define the front layer stack (i.e. all the materials which are on top of the Si, excluding Si itself, which will be the ‘bulk’ material) and the rear layer stack. Layer stacks are always defined starting with the layer closest to the top of the cell.\n# Can comment out this block after running once to add materials to the database\nfrom solcore.material_system import create_new_material\n\ncreate_new_material(\"Perovskite_CsBr_1p6eV\", \"data/CsBr10p_1to2_n_shifted.txt\",\n                    \"data/CsBr10p_1to2_k_shifted.txt\")\ncreate_new_material(\"ITO_lowdoping\", \"data/model_back_ito_n.txt\",\n                    \"data/model_back_ito_k.txt\")\ncreate_new_material(\"aSi_i\", \"data/model_i_a_silicon_n.txt\",\n                    \"data/model_i_a_silicon_k.txt\")\ncreate_new_material(\"aSi_p\", \"data/model_p_a_silicon_n.txt\",\n                    \"data/model_p_a_silicon_k.txt\")\ncreate_new_material(\"aSi_n\", \"data/model_n_a_silicon_n.txt\",\n                    \"data/model_n_a_silicon_k.txt\")\ncreate_new_material(\"C60\", \"data/C60_Ren_n.txt\",\n                    \"data/C60_Ren_k.txt\")\ncreate_new_material(\"IZO\", \"data/IZO_Ballif_rO2_10pcnt_n.txt\",\n                    \"data/IZO_Ballif_rO2_10pcnt_k.txt\")\n# Comment out until here\n\nMaterial created with optical constants n and k only.\nMaterial created with optical constants n and k only.\nMaterial created with optical constants n and k only.\nMaterial created with optical constants n and k only.\nMaterial created with optical constants n and k only.\nMaterial created with optical constants n and k only.\nMaterial created with optical constants n and k only.\ndownload_db()\nMgF2_pageid = search_db(os.path.join(\"MgF2\", \"Rodriguez-de Marcos\"))[0][0];\nAg_pageid = search_db(os.path.join(\"Ag\", \"Jiang\"))[0][0];\n\nSi = material(\"Si\")()\nAir = material(\"Air\")()\nMgF2 = material(str(MgF2_pageid), nk_db=True)()\nITO_back = material(\"ITO_lowdoping\")()\nPerovskite = material(\"Perovskite_CsBr_1p6eV\")()\nAg = material(str(Ag_pageid), nk_db=True)()\naSi_i = material(\"aSi_i\")()\naSi_p = material(\"aSi_p\")()\naSi_n = material(\"aSi_n\")()\nLiF = material(\"LiF\")()\nIZO = material(\"IZO\")()\nC60 = material(\"C60\")()\n\n# stack based on doi:10.1038/s41563-018-0115-4\nfront_materials = [\n    Layer(100e-9, MgF2),\n    Layer(110e-9, IZO),\n    Layer(15e-9, C60),\n    Layer(1e-9, LiF),\n    Layer(440e-9, Perovskite),\n    Layer(6.5e-9, aSi_n),\n    Layer(6.5e-9, aSi_i),\n]\n\nback_materials = [Layer(6.5e-9, aSi_i), Layer(6.5e-9, aSi_p), Layer(240e-9, ITO_back)]\n\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\n1 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n234 main    MgF2    Rodriguez-de_Marcos main/MgF2/Rodriguez-de Marcos.yml   1   1   0.0299919   2.00146 960\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\n1 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n2   main    Ag  Jiang   main/Ag/Jiang.yml   1   1   0.3 2.0 1701\nNow we define our front and back surfaces, including interface_layers. We will use regular pyramids for both the front and back surface; these pyramids point out on both sides, but since the direction of the pyramids is defined relative to the front surface, we must set upright=True for the top surface and upright=False for the rear surface. We also gives the surfaces a name (used to save the lookup table data) and ask RayFlare to calculate the absorption profile in the 5th layer, which is the perovskite.\ntriangle_surf = regular_pyramids(\n    elevation_angle=55,\n    upright=True,\n    size=1,\n    interface_layers=front_materials,\n    name=\"coh_front\",\n    prof_layers=[5],\n)\n\ntriangle_surf_back = regular_pyramids(\n    elevation_angle=55,\n    upright=False,\n    size=1,\n    interface_layers=back_materials,\n    name=\"Si_back\",\n    coherency_list=[\"i\"] * len(back_materials),\n)\nNow we make our ray-tracing structure by combining the front and back surfaces, specifying the material in between (Si) and setting its width to 260 microns. In order to use the TMM lookuptables to calculate reflection/transmission/absorption probabilities we must also set use_TMM=True.\nrtstr_coh = rt_structure(\n    textures=[triangle_surf, triangle_surf_back],\n    materials=[Si],\n    widths=[260e-6],\n    incidence=Air,\n    transmission=Ag,\n    use_TMM=True,\n    options=options,\n    overwrite=True,\n    save_location=\"current\",\n)\n\n# calculate:\nresult_coh = rtstr_coh.calculate(options)\n\nPre-computing TMM lookup table(s)\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/MgF2/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/MgF2/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/Ag/Jiang.yml loaded.\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/Ag/Jiang.yml loaded.\nNow we define the same front surface and structure again, except now we will treat all the layers incoherently (i.e. no thin-film interference) in the TMM.\ntriangle_surf = regular_pyramids(\n    elevation_angle=55,\n    upright=True,\n    size=1,\n    interface_layers=front_materials,\n    coherency_list=[\"i\"] * len(front_materials),\n    name=\"inc_front\",\n    prof_layers=[5],\n)\n\nrtstr_inc = rt_structure(\n    textures=[triangle_surf, triangle_surf_back],\n    materials=[Si],\n    widths=[260e-6],\n    incidence=Air,\n    transmission=Ag,\n    use_TMM=True,\n    options=options,\n    overwrite=True,\n    save_location=\"current\",\n)\n\nresult_inc = rtstr_inc.calculate(options)\n\nPre-computing TMM lookup table(s)\nNow we plot the results for reflection, transmission, and absorption per layer for both the coherent and incoherent cases.\npal = sns.color_palette(\"husl\", n_colors=len(front_materials) + len(back_materials) + 2)\n# create a colour palette\n\ncols = cycler(\"color\", pal)\n# set this as the default colour palette in matplotlib\n\nparams = {\n    \"axes.prop_cycle\": cols,\n}\n\nplt.rcParams.update(params)\n\nfig = plt.figure(figsize=(8, 3.7))\nplt.subplot(1, 1, 1)\nplt.plot(wavelengths * 1e9, result_coh[\"R\"], \"-ko\", label=\"R\")\nplt.plot(wavelengths * 1e9, result_coh[\"T\"], mfc=\"none\", label=\"T\")\nplt.plot(wavelengths * 1e9, result_coh[\"A_per_layer\"][:, 0], \"-o\", label='Si')\nplt.plot(wavelengths * 1e9, result_coh[\"A_per_interface\"][0], \"-o\",\n         label=[None, \"IZO\", \"C60\", None, \"Perovskite\", None, None])\nplt.plot(wavelengths * 1e9, result_coh[\"A_per_interface\"][1], \"-o\",\n         label=[None, None, \"ITO\"])\n\nplt.plot(wavelengths * 1e9, result_inc[\"R\"], \"--ko\", mfc=\"none\")\nplt.plot(wavelengths * 1e9, result_inc[\"T\"], mfc=\"none\")\nplt.plot(wavelengths * 1e9, result_inc[\"A_per_layer\"][:, 0], \"--o\", mfc=\"none\")\nplt.plot(wavelengths * 1e9, result_inc[\"A_per_interface\"][0], \"--o\", mfc=\"none\")\nplt.plot(wavelengths * 1e9, result_inc[\"A_per_interface\"][1], \"--o\", mfc=\"none\")\n\nplt.plot([300, 301], [0, 0], \"-k\", label=\"coherent\")\nplt.plot([300, 301], [0, 0], \"--k\", label=\"incoherent\")\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"R / A / T\")\nplt.ylim(0, 1)\nplt.xlim(300, 1200)\nplt.legend(bbox_to_anchor=(1.05, 1))\nplt.tight_layout()\nplt.show()\nCalculate and print the limiting short-circuit current per junction:\nJmax_Pero_coh = q*np.trapz(result_coh[\"A_per_interface\"][0][:,4]*AM15G.spectrum()[1],\n                                                        x=wavelengths)/10\nJmax_Si_coh = q*np.trapz(result_coh[\"A_per_layer\"][:, 0]*AM15G.spectrum()[1],\n                     x=wavelengths)/10\n\nprint(\"Limiting short-circuit currents in coherent calculation (mA/cm2): {:.2f} / {:\"\n      \".2f}\".format(Jmax_Pero_coh, Jmax_Si_coh))\n\nJmax_Pero_inc = q*np.trapz(result_inc[\"A_per_interface\"][0][:,4]*AM15G.spectrum()[1],\n                                                        x=wavelengths)/10\nJmax_Si_inc = q*np.trapz(result_inc[\"A_per_layer\"][:, 0]*AM15G.spectrum()[1],\n                     x=wavelengths)/10\n\nprint(\"Limiting short-circuit currents in coherent calculation (mA/cm2): {:.2f} / {:\"\n      \".2f}\".format(Jmax_Pero_inc, Jmax_Si_inc))\n\nLimiting short-circuit currents in coherent calculation (mA/cm2): 19.90 / 20.94\nLimiting short-circuit currents in coherent calculation (mA/cm2): 19.14 / 20.53\nWe can also plot the absorption profiles, for wavelengths up to 800 nm, in the perovskite (since we asked the solver to calculate the profile in the perovskite layer above).\nwl_Eg = wavelengths &lt; 800e-9\n\npal = sns.cubehelix_palette(sum(wl_Eg), reverse=True)\ncols = cycler(\"color\", pal)\nparams = {\n    \"axes.prop_cycle\": cols,\n}\nplt.rcParams.update(params)\n\npos = np.arange(0, rtstr_coh.interface_layer_widths[0][4], options.depth_spacing*1e9)\n\nfig, (ax1, ax2) = plt.subplots(1,2)\nax1.plot(pos, result_coh[\"interface_profiles\"][0][wl_Eg].T)\nax1.set_ylim(0, 0.02)\nax1.set_xlabel(\"z (nm)\")\nax1.set_ylabel(\"a(z)\")\nax1.set_title(\"Coherent\")\nax2.plot(pos, result_inc[\"interface_profiles\"][0][wl_Eg].T)\nax2.set_ylim(0, 0.02)\nax2.yaxis.set_ticklabels([])\nax2.set_xlabel(\"z (nm)\")\nax2.set_title(\"Incoherent\")\nplt.show()\nWe see that, as expected, the coherent case shows interference fringes while the incoherent case does not. We can also plot the absorption profile in the Si (&gt; 800 nm):\npos_bulk = pos = np.arange(0, rtstr_coh.widths[0]*1e6, options.depth_spacing_bulk*1e6)\n\nfig, (ax1, ax2) = plt.subplots(1,2)\nax1.semilogy(pos, result_coh[\"profile\"][~wl_Eg].T)\nax1.set_ylim(1e-8, 0.00015)\nax1.set_xlabel(\"z (um)\")\nax1.set_ylabel(\"a(z)\")\nax1.set_title(\"Coherent\")\nax2.semilogy(pos, result_inc[\"profile\"][~wl_Eg].T)\nax2.set_ylim(1e-8, 0.00015)\nax2.yaxis.set_ticklabels([])\nax2.set_xlabel(\"z (um)\")\nax2.set_title(\"Incoherent\")\nplt.show()\n\n260.0"
  },
  {
    "objectID": "solcore-workshop/notebooks/10-perovskite_Si_rt.html#questions",
    "href": "solcore-workshop/notebooks/10-perovskite_Si_rt.html#questions",
    "title": "Section 10: Perovskite-Si tandem cell with pyramidal surfaces",
    "section": "Questions",
    "text": "Questions\n\nWhy do you think the total absorption is slightly lower in the incoherent calculation?\nEven though the layers on top of the Si are not very thick compared to the wavelength, and they are the first thing encountered by the light, why might it make sense to treat them incoherently?\nCan you improve the current-matching (at least in terms of limiting currents) between the perovskite and the Si?"
  },
  {
    "objectID": "solcore-workshop/notebooks/8-grating_pyramids_OPTOS.html",
    "href": "solcore-workshop/notebooks/8-grating_pyramids_OPTOS.html",
    "title": "Section 8: Textured Si",
    "section": "",
    "text": "This example is based on Figures 6, 7 and 8 from this paper. This compares three different structures, all based on a 200 micron thick slab of silicon with different surface textures:\nThe methods which will be used to calculate the redistribution matrices in each case are given in brackets. If case 1 and 2 are calculated first, then case 3 does not require the calculations of any additional matrices, since it will use the rear matrix from (1) and the front matrix from (2)."
  },
  {
    "objectID": "solcore-workshop/notebooks/8-grating_pyramids_OPTOS.html#setting-up",
    "href": "solcore-workshop/notebooks/8-grating_pyramids_OPTOS.html#setting-up",
    "title": "Section 8: Textured Si",
    "section": "Setting up",
    "text": "Setting up\nFirst, importing relevant packages:\n\nimport numpy as np\nimport os\n\n# solcore imports\nfrom solcore.structure import Layer\nfrom solcore import material\nfrom solcore import si\n\nfrom rayflare.structure import Interface, BulkLayer, Structure\nfrom rayflare.matrix_formalism import process_structure, calculate_RAT\nfrom rayflare.utilities import get_savepath\nfrom rayflare.transfer_matrix_method import tmm_structure\nfrom rayflare.angles import theta_summary, make_angle_vector\nfrom rayflare.textures import regular_pyramids\nfrom rayflare.options import default_options\n\nfrom solcore.material_system import create_new_material\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport seaborn as sns\nfrom sparse import load_npz\n\nTo make sure we are using the same optical constants for Si, load the same Si n/k data used in the paper linked above:\n\ncreate_new_material(\"Si_OPTOS\", \"data/Si_OPTOS_n.txt\", \"data/Si_OPTOS_k.txt\",\n                    overwrite=True)\n\nMaterial created with optical constants n and k only.\n\n\nYou only need to do this one time, then the material will be stored in Solcore’s material database.\nSetting options (taking the default options for everything not specified explicitly):\n\nangle_degrees_in = 8 # same as in Fraunhofer paper\n\nwavelengths = np.linspace(900, 1200, 20) * 1e-9\n\nSi = material(\"Si_OPTOS\")()\nAir = material(\"Air\")()\n\noptions = default_options()\noptions.wavelengths = wavelengths\noptions.theta_in = angle_degrees_in * np.pi / 180 # incidence angle (polar angle)\noptions.n_theta_bins = 50\noptions.c_azimuth = 0.25\noptions.n_rays = 5e5 # number of rays per wavelength in ray-tracing\noptions.project_name = \"OPTOS_comparison\"\noptions.orders = 60 # number of RCWA orders to use (more = better convergence, but slower)\noptions.pol = \"u\" # unpolarized light\noptions.only_incidence_angle = False"
  },
  {
    "objectID": "solcore-workshop/notebooks/8-grating_pyramids_OPTOS.html#defining-the-structures",
    "href": "solcore-workshop/notebooks/8-grating_pyramids_OPTOS.html#defining-the-structures",
    "title": "Section 8: Textured Si",
    "section": "Defining the structures",
    "text": "Defining the structures\nNow, set up the grating basis vectors for the RCWA calculations and define the grating structure. These are squares, rotated by 45 degrees. The halfwidth is calculated based on the area fill factor of the etched pillars given in the paper.\n\nx = 1000\n\nd_vectors = ((x, 0), (0, x))\narea_fill_factor = 0.36\nhw = np.sqrt(area_fill_factor) * 500\n\nback_materials = [\n    Layer(width=si(\"120nm\"), material=Si,\n        geometry=[{\"type\": \"rectangle\", \"mat\": Air, \"center\": (x / 2, x / 2),\n                \"halfwidths\": (hw, hw), \"angle\": 45}],\n    )]\n\nNow we define the pyramid texture for the front surface in case (2) and (3) and make the four possible different surfaces: planar front and rear, front with pyramids, rear with grating. We specify the method to use to calculate the redistribution matrices in each case and create the bulk layer.\n\nsurf = regular_pyramids(elevation_angle=55, upright=False)\n\nfront_surf_pyramids = Interface(\n    \"RT_Fresnel\",\n    texture=surf,\n    layers=[],\n    name=\"inv_pyramids_front_\" + str(options[\"n_rays\"]),\n)\n\nfront_surf_planar = Interface(\"TMM\", layers=[], name=\"planar_front\")\n\nback_surf_grating = Interface(\n    \"RCWA\",\n    layers=back_materials,\n    name=\"crossed_grating_back\",\n    d_vectors=d_vectors,\n    rcwa_orders=20,\n)\n\nback_surf_planar = Interface(\"TMM\", layers=[], name=\"planar_back\")\n\nbulk_Si = BulkLayer(200e-6, Si, name=\"Si_bulk\")\n\nfixed h 0.7140740033710572\n\n\nNow we create the different structures and ‘process’ them (this will calculate the relevant matrices if necessary, or do nothing if it finds the matrices have previously been calculated and the files already exist). We don’t need to process the final structure because it will use matrices calculated for SC_fig6 and SC_fig7.\n\nSC_fig6 = Structure(\n    [front_surf_planar, bulk_Si, back_surf_grating], incidence=Air, transmission=Air\n)\nSC_fig7 = Structure(\n    [front_surf_pyramids, bulk_Si, back_surf_planar], incidence=Air, transmission=Air\n)\nSC_fig8 = Structure(\n    [front_surf_pyramids, bulk_Si, back_surf_grating], incidence=Air, transmission=Air\n)\n\nprocess_structure(SC_fig6, options, save_location='current')\nprocess_structure(SC_fig7, options, save_location='current')\n\nMaking matrix for planar surface using TMM for element 0 in structure\nExisting angular redistribution matrices found\nExisting angular redistribution matrices found\nRCWA calculation for element 2 in structure\nExisting angular redistribution matrices found\nRay tracing with Fresnel equations for element 0 in structure\nExisting angular redistribution matrices found\nExisting angular redistribution matrices found\nMaking matrix for planar surface using TMM for element 2 in structure\nExisting angular redistribution matrices found"
  },
  {
    "objectID": "solcore-workshop/notebooks/8-grating_pyramids_OPTOS.html#calculating-rat",
    "href": "solcore-workshop/notebooks/8-grating_pyramids_OPTOS.html#calculating-rat",
    "title": "Section 8: Textured Si",
    "section": "Calculating R/A/T",
    "text": "Calculating R/A/T\nThen we ask RayFlare to calculate the reflection, transmission and absorption through matrix multiplication, and get the required result out (absorption in the bulk) for each cell. We also load the results from the reference paper to compare them to the ones calculated with RayFlare.\n\nresults_fig6 = calculate_RAT(SC_fig6, options, save_location='current')\nresults_fig7 = calculate_RAT(SC_fig7, options, save_location='current')\nresults_fig8 = calculate_RAT(SC_fig8, options, save_location='current')\n\nRAT_fig6 = results_fig6[0]\nRAT_fig7 = results_fig7[0]\nRAT_fig8 = results_fig8[0]\n\nsim_fig6 = np.loadtxt(\"data/optos_fig6_sim.csv\", delimiter=\",\")\nsim_fig7 = np.loadtxt(\"data/optos_fig7_sim.csv\", delimiter=\",\")\nsim_fig8 = np.loadtxt(\"data/optos_fig8_sim.csv\", delimiter=\",\")\n\nFinally, we use TMM to calculate the absorption in a structure with a planar front and planar rear, as a reference.\n\nstruc = tmm_structure([Layer(si(\"200um\"), Si)], incidence=Air, transmission=Air)\noptions.coherent = False\noptions.coherency_list = [\"i\"]\nRAT = tmm_structure.calculate(struc, options)"
  },
  {
    "objectID": "solcore-workshop/notebooks/8-grating_pyramids_OPTOS.html#plotting",
    "href": "solcore-workshop/notebooks/8-grating_pyramids_OPTOS.html#plotting",
    "title": "Section 8: Textured Si",
    "section": "Plotting",
    "text": "Plotting\nPlot everything together, including data from the reference paper for comparison:\n\npalhf = sns.color_palette(\"hls\", 4)\n\nfig = plt.figure()\nplt.plot(sim_fig6[:, 0], sim_fig6[:, 1],\n    \"--\", color=palhf[0], label=\"OPTOS - rear grating (1)\")\nplt.plot(wavelengths * 1e9, RAT_fig6[\"A_bulk\"][0],\n    \"-o\", color=palhf[0], label=\"RayFlare - rear grating (1)\", fillstyle=\"none\")\nplt.plot(sim_fig7[:, 0], sim_fig7[:, 1],\n    \"--\", color=palhf[1], label=\"OPTOS - front pyramids (2)\",)\nplt.plot(wavelengths * 1e9, RAT_fig7[\"A_bulk\"][0],\n    \"-o\", color=palhf[1], label=\"RayFlare - front pyramids (2)\", fillstyle=\"none\")\nplt.plot(sim_fig8[:, 0], sim_fig8[:, 1],\n    \"--\", color=palhf[2], label=\"OPTOS - grating + pyramids (3)\")\nplt.plot(wavelengths * 1e9, RAT_fig8[\"A_bulk\"][0],\n    \"-o\", color=palhf[2],label=\"RayFlare - grating + pyramids (3)\", fillstyle=\"none\",)\nplt.plot(wavelengths * 1e9, RAT[\"A_per_layer\"][:, 0], \"-k\", label=\"Planar\")\nplt.legend(loc=\"lower left\")\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"Absorption in Si\")\nplt.xlim([900, 1200])\nplt.ylim([0, 1])\nplt.show()\n\n\n\n\nWe can see good agreement between the reference values and our calculated values. The structure with rear grating also behaves identically to the planar TMM reference case at the short wavelengths where front surface reflection dominates the result, as expected. Clearly, the pyramids perform much better overall, giving a large boost in the absorption at long wavelengths and also reducing the reflection significantly at shorter wavelengths. Plotting reflection and transmission emphasises this:\n\nfig = plt.figure()\nplt.plot(wavelengths * 1e9,RAT_fig6[\"R\"][0],\n    \"-o\", color=palhf[0], label=\"RayFlare - rear grating (1)\", fillstyle=\"none\")\nplt.plot(wavelengths * 1e9, RAT_fig7[\"R\"][0],\n    \"-o\", color=palhf[1], label=\"RayFlare - front pyramids (2)\", fillstyle=\"none\")\nplt.plot(wavelengths * 1e9, RAT_fig8[\"R\"][0],\n    \"-o\", color=palhf[2], label=\"RayFlare - grating + pyramids (3)\", fillstyle=\"none\")\n\nplt.plot(wavelengths * 1e9, RAT_fig6[\"T\"][0], \"--o\", color=palhf[0])\nplt.plot(wavelengths * 1e9, RAT_fig7[\"T\"][0], \"--o\", color=palhf[1])\nplt.plot(wavelengths * 1e9, RAT_fig8[\"T\"][0], \"--o\", color=palhf[2])\n\n# these are just to create the legend:\nplt.plot(-1, 0, \"k-o\", label=\"R\", fillstyle=\"none\")\nplt.plot(-1, 0, \"k--o\", label=\"T\")\n\nplt.legend()\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"Reflected/transmitted fraction\")\nplt.xlim([900, 1200])\nplt.ylim([0, 0.6])\nplt.show()"
  },
  {
    "objectID": "solcore-workshop/notebooks/8-grating_pyramids_OPTOS.html#redistribution-matrices",
    "href": "solcore-workshop/notebooks/8-grating_pyramids_OPTOS.html#redistribution-matrices",
    "title": "Section 8: Textured Si",
    "section": "Redistribution matrices",
    "text": "Redistribution matrices\nPlot the redistribution matrix for the rear grating (summed over azimuthal angles) at 1100 nm:\n\ntheta_intv, phi_intv, angle_vector = make_angle_vector(\n    options[\"n_theta_bins\"], options[\"phi_symmetry\"], options[\"c_azimuth\"])\n\npath = get_savepath(save_location='current', project_name=options.project_name)\nsprs = load_npz(os.path.join(path, SC_fig6[2].name + \"frontRT.npz\"))\n\nwl_to_plot = 1100e-9\nwl_index = np.argmin(np.abs(wavelengths - wl_to_plot))\n\nfull = sprs[wl_index].todense()\n\nsummat = theta_summary(full, angle_vector, options[\"n_theta_bins\"], \"front\")\nsummat_r = summat[: options[\"n_theta_bins\"], :]\nsummat_r = summat_r.rename({ r\"$\\theta_{in}$\": r\"$\\sin(\\theta_{in})$\",\n        r\"$\\theta_{out}$\": r\"$\\sin(\\theta_{out})$\"})\n\nsummat_r = summat_r.assign_coords({r\"$\\sin(\\theta_{in})$\": np.sin(summat_r.coords[r\"$\\sin(\\theta_{in})$\"]).data,\n    r\"$\\sin(\\theta_{out})$\": np.sin(summat_r.coords[r\"$\\sin(\\theta_{out})$\"]).data})\n\npalhf = sns.cubehelix_palette(256, start=0.5, rot=-0.9)\npalhf.reverse()\nseamap = mpl.colors.ListedColormap(palhf)\n\nfig = plt.figure()\nax = plt.subplot(111)\nax = summat_r.plot.imshow(ax=ax, cmap=seamap, vmax=0.3)\nplt.show()"
  },
  {
    "objectID": "solcore-workshop/notebooks/8-grating_pyramids_OPTOS.html#questions",
    "href": "solcore-workshop/notebooks/8-grating_pyramids_OPTOS.html#questions",
    "title": "Section 8: Textured Si",
    "section": "Questions",
    "text": "Questions\n\nIf you can add only one of the textures (pyramids or a grating), which one is better? Why?\nWhy do the structures with a front-surface texture have high reflection at long wavelengths? The anti-reflection properties of pyramids (treated with ray optics) are mostly independent of the wavelength, so why does apparent reflection increase’ near the bandgap of Si?\nCan you explain any of the features present in the angular redistribution matrix of the rear grating surface?"
  },
  {
    "objectID": "solcore-workshop/notebooks/7-InGaP_Si_planar.html",
    "href": "solcore-workshop/notebooks/7-InGaP_Si_planar.html",
    "title": "Section 7: Planar GaInP//Si tandem cell",
    "section": "",
    "text": "This example is partly based on the structure presented in this paper, but with planar interfaces instead of a textured Si surface. This is a four-terminal GaInP/Si device which uses an epoxy and glass to bond the two cells together mechanically. First, we will do optical-only calculations to look at the effect of an intermediate anti-reflection coating (on top of the epoxy/glass) on the absorption in the bottom Si cell, and then we will use the results of the optical calculation to do a device simulation and calculate external quantum efficiency and current-voltage under AM1.5G.\nNote: the paper linked above has a GaInP/AlGaInP heterojunction as the top junction. Because we do not have AlGaInP built in to Solcore’s database, this is replaced by a GaInP homojunction in this example.\nfrom solcore import material, si\nfrom solcore.absorption_calculator import search_db, download_db\nimport os\nfrom solcore.structure import Layer, Junction\nfrom solcore.solar_cell_solver import solar_cell_solver, default_options\nfrom solcore.solar_cell import SolarCell\nfrom solcore.light_source import LightSource\nfrom solcore.constants import q\nimport numpy as np\nimport matplotlib.pyplot as plt"
  },
  {
    "objectID": "solcore-workshop/notebooks/7-InGaP_Si_planar.html#defining-materials-layers-and-junctions",
    "href": "solcore-workshop/notebooks/7-InGaP_Si_planar.html#defining-materials-layers-and-junctions",
    "title": "Section 7: Planar GaInP//Si tandem cell",
    "section": "Defining materials, layers and junctions",
    "text": "Defining materials, layers and junctions\nThe paper referenced above uses a double-layer anti-reflection coating (ARC) made of MgF\\(_2\\) and ZnS. As in the previous example, we use the interface to the refractiveindex.info database to select optical constant data from specific sources, and define Solcore materials using this data. The III-V materials are taken from Solcore’s own material database.\nNote that for the epoxy/glass layer, we use only a single material (BK7 glass). The epoxy and glass used in the paper have the same refractive index (n = 1.56), so we can use a single material with an appropriate refractive index to represent them.\n\ndownload_db() # uncomment to download database\n\n\nMgF2_pageid = search_db(os.path.join(\"MgF2\", \"Rodriguez-de Marcos\"))[0][0];\nZnS_pageid = search_db(os.path.join(\"ZnS\", \"Querry\"))[0][0];\nMgF2 = material(str(MgF2_pageid), nk_db=True)();\nZnS = material(str(ZnS_pageid), nk_db=True)();\n\nwindow = material(\"AlInP\")(Al=0.52)\nGaInP = material(\"GaInP\")\nBSF = material(\"AlGaAs\")(Al=0.5)\n\nepoxy = material(\"BK7\")()\n\nFor the Si cell, the front surface has both a low-index and high-index SiN\\(x\\) layer. The rear surface uses Al\\(2\\)O\\(3\\), and the cell has Al at the rear surface.\n\nSiOx = material(\"SiO\")()\nSiN_191_pageid = search_db(\"Vogt-1.91\")[0][0];\nSiN_213_pageid = search_db(\"Vogt-2.13\")[0][0];\nSiN_191 = material(str(SiN_191_pageid), nk_db=True)();\nSiN_213 = material(str(SiN_213_pageid), nk_db=True)();\n\nSi = material(\"Si\")\n\nAl2O3 = material(\"Al2O3P\")()\nAl = material(\"Al\")()\n\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\n1 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n2816    other   SiN Vogt-1.91   anti-reflective coatings/SiN/Vogt-1.91.yml  1   1   0.25    1.7 146\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\n1 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n2818    other   SiN Vogt-2.13   anti-reflective coatings/SiN/Vogt-2.13.yml  1   1   0.25    1.7 146\n\n\nWe now define the layers used in the top cell stack: the ARC and window layer for the top cell, and the GaInP junction itself. The ARC and window layers are not involved in the electrical calculation using the depletion approximation, so they are defined as simple layers, while the GaInP emitter and base are defined as part of a Junction object.\n\nARC_window = [\n    Layer(97e-9, MgF2),\n    Layer(41e-9, ZnS),\n    Layer(17e-9, window, role=\"window\"),\n]\n\nGaInP_junction = Junction([\n    Layer(200e-9, GaInP(In=0.50, Nd=si(\"2e18cm-3\"), hole_diffusion_length=si(\"300nm\")),\n          role=\"emitter\"),\n    Layer(750e-9, GaInP(In=0.50, Na=si(\"1e17cm-3\"), electron_diffusion_length=si(\n        \"800nm\")),\n          role=\"base\"),\n    Layer(500e-9, BSF, role=\"bsf\")], kind=\"DA\", sn=1, sp=1\n)\n\nWe now define the spacer layer, with and without a ZnS anti-reflection coating, so we can compare their performance in the cell stack. Note that we set the epoxy thickness here to be 10 microns, although the real thickness is much higher - this is because the epoxy/glass is not absorbing at the wavelengths which are able to reach it (which are not absorbed in the GaInP top cell), and we will treat it incoherently (no thin-film interference), so the exact thickness does not matter.\n\nspacer = [\n    Layer(82e-9, ZnS),\n    Layer(10e-6, epoxy), # real thickness is much higher, but since this layer is\n    # non-absorbing at the relevant wavelength (&gt; 650 nm) and treated incoherently,\n    # this does not matter\n]\n\nspacer_noARC = [\n    Layer(10e-6, epoxy),\n]\n\nNow we define the layer stacks for the Si cell, including the front SiO\\(_x\\)/SiN\\(_x\\) stack, the junction itself, and the back dielectric layers.\n\nSi_front_surf = [\n    Layer(100e-9, SiOx),\n    Layer(70e-9, SiN_191),\n    Layer(15e-9, SiN_213),\n    ]\n\nSi_junction = Junction([\n    Layer(1e-6, Si(Nd=si(\"2e18cm-3\"), hole_diffusion_length=2e-6), role=\"emitter\"),\n    Layer(150e-6, Si(Na=si(\"2e15cm-3\"), electron_diffusion_length=150e-6), role=\"base\"),\n], kind=\"DA\", sn=0.1, sp=0.1)\n\nSi_back_surf = [\n    Layer(15e-9, Al2O3),\n    Layer(120e-9, SiN_191)\n]"
  },
  {
    "objectID": "solcore-workshop/notebooks/7-InGaP_Si_planar.html#comparing-the-optical-performance-with-and-without-intermediate-arc",
    "href": "solcore-workshop/notebooks/7-InGaP_Si_planar.html#comparing-the-optical-performance-with-and-without-intermediate-arc",
    "title": "Section 7: Planar GaInP//Si tandem cell",
    "section": "Comparing the optical performance with and without intermediate ARC",
    "text": "Comparing the optical performance with and without intermediate ARC\nNow we will run the calculation. We will treat some of the layers (those above the epoxy) with a coherent TMM calculation, and the epoxy and the layers below it using incoherent TMM. We will discuss the difference this makes, why this is important, and when to use coherent and incoherent layers.\n\nn_coh_layers = len(ARC_window + GaInP_junction)\nn_inc_layers = 1 + len(Si_front_surf + Si_junction + Si_back_surf)\n\nwl = np.linspace(300, 1200, 600) * 1e-9\n\noptions = default_options\noptions.recalculate_absorption = True\noptions.wavelength = wl\noptions.optics_method = 'TMM'\n\nAM15G = LightSource(source_type=\"standard\", version=\"AM1.5g\", x=wl*1e9,\n                    output_units=\"photon_flux_per_nm\")\n\nNow we define two versions of the cell for optical calculations, without and with the ZnS anti-reflection coating on the epoxy. Note that we also set the substrate for the calculation (aluminium) here.\n\ncell_no_ARC = SolarCell(\n    ARC_window + GaInP_junction + spacer_noARC + Si_front_surf + Si_junction +\n    Si_back_surf,\n    substrate=Al,\n)\n\ncell_with_ARC = SolarCell(\n    ARC_window + GaInP_junction + spacer + Si_front_surf + Si_junction + Si_back_surf,\n    substrate=Al,\n)\n\nWe set the appropriate coherency list for the structure (a list with entry ‘c’ for a coherent layer or ‘i’ for an incoherent layer), and solve for the cell optics of the cell without the intermediate ARC. We get the total absorption in the GaInP and Si junctions.\n\noptions.coherency_list = ['c']*(n_coh_layers) + ['i']*n_inc_layers\nsolar_cell_solver(cell_no_ARC, \"optics\", options)\n\nGaInP_A = cell_no_ARC[3].layer_absorption + cell_no_ARC[4].layer_absorption\nSi_A = cell_no_ARC[10].layer_absorption + cell_no_ARC[11].layer_absorption\n\nAs above, but for the cell with an intermediate ARC:\n\noptions.coherency_list = [\"c\"]*(n_coh_layers + 1) + ['i']*n_inc_layers\nsolar_cell_solver(cell_with_ARC, \"optics\", options)\n\nGaInP_A_ARC = cell_with_ARC[3].layer_absorption + cell_with_ARC[4].layer_absorption\nSi_A_ARC = cell_with_ARC[11].layer_absorption + cell_with_ARC[12].layer_absorption\n\nTreating layer(s) 12 incoherently\nCalculating RAT...\nCalculating absorption profile...\n\n\nNow we plot the GaInP and Si absorption, and the reflectance of the whole structure, for both cells:\n\nplt.figure()\nplt.plot(wl * 1e9, GaInP_A, \"--k\")\nplt.plot(wl * 1e9, Si_A, \"--r\")\nplt.plot(wl * 1e9, cell_no_ARC.reflected, '--b')\n\nplt.plot(wl * 1e9, GaInP_A_ARC, \"-k\", label=\"GaInP\")\nplt.plot(wl * 1e9, Si_A_ARC, \"-r\", label=\"Si\")\nplt.plot(wl * 1e9, cell_with_ARC.reflected, '-b', label=\"R\")\nplt.legend(loc='upper right')\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"Absorptance/Reflectance\")\nplt.tight_layout()\nplt.show()\n\n\n\n\nWe see that the cell without an ARC on the epoxy shows much stronger interference fringes (due to the thickness of the top stack), and higher reflectance overall in the long-wavelength region (at short wavelengths, light is absorbed before it is able to reach the epoxy at all). Before doing an actual electrical calculation, we will calculate the limiting current in both of the sub-cells (assuming all the generated charge carriers can be collected):\n\nJ_GaInP = q*np.trapz(GaInP_A * AM15G.spectrum()[1], wl*1e9)\nJ_Si = q*np.trapz(Si_A * AM15G.spectrum()[1], wl*1e9)\n\nprint(\"Limiting short-circuit currents without ARC (mA/cm2): {:.1f} / {:.1f}\".format(\n      J_GaInP/10, J_Si/10))\n\nJ_GaInP_ARC = q*np.trapz(GaInP_A_ARC * AM15G.spectrum()[1], wl*1e9)\nJ_Si_ARC = q*np.trapz(Si_A_ARC * AM15G.spectrum()[1], wl*1e9)\n\nprint(\"Limiting short-circuit currents with ARC (mA/cm2): {:.1f} / {:.1f}\".format(\n    J_GaInP_ARC/10, J_Si_ARC/10))\n\nLimiting short-circuit currents without ARC (mA/cm2): 16.4 / 15.5\nLimiting short-circuit currents with ARC (mA/cm2): 16.4 / 17.4\n\n\nAs expected from the reduced reflection and increased absorption in the Si, the cell with an intermediate ARC has significantly higher maximum current in the bottom Si cell."
  },
  {
    "objectID": "solcore-workshop/notebooks/7-InGaP_Si_planar.html#eqe-and-iv-calculation",
    "href": "solcore-workshop/notebooks/7-InGaP_Si_planar.html#eqe-and-iv-calculation",
    "title": "Section 7: Planar GaInP//Si tandem cell",
    "section": "EQE and IV calculation",
    "text": "EQE and IV calculation\nNow, just taking the structure with an intermediate ARC, we do a cell calculation using the depletion approximation.\n\noptions.mpp = True\noptions.light_iv = True\noptions.voltages = np.linspace(0, 1.9, 100)\noptions.light_source = AM15G\n\nsolar_cell = SolarCell(\n    ARC_window + [GaInP_junction] + spacer + Si_front_surf + [Si_junction] +\n    Si_back_surf,\n    substrate=Al,\n)\n\nFirst, we calculate and plot the external quantum efficiency (EQE):\n\nsolar_cell_solver(solar_cell, 'qe', options)\n\nplt.figure()\nplt.plot(wl * 1e9, GaInP_A_ARC, \"--k\", label=\"GaInP only absorption\")\nplt.plot(wl * 1e9, Si_A_ARC, \"--r\", label=\"Si only absorption\")\nplt.plot(wl*1e9, solar_cell[3].eqe(wl), '-k')\nplt.plot(wl*1e9, solar_cell[9].eqe(wl), '-r')\nplt.legend(loc='upper right')\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"Absorptance/EQE\")\nplt.ylim(0,1)\nplt.tight_layout()\nplt.show()\n\nTreating layer(s) 12 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving QE of the solar cell...\n\n\n/Users/phoebe/Documents/develop/solcore-education/venv/lib/python3.11/site-packages/solcore/analytic_solar_cells/depletion_approximation.py:617: RuntimeWarning: invalid value encountered in divide\n  iqe =  j_sc / current_absorbed\n\n\n\n\n\nAnd the current-voltage under AM1.5G:\n\nsolar_cell_solver(solar_cell, 'iv', options)\n\nplt.figure()\nplt.plot(options.voltages, solar_cell.iv['IV'][1]/10, 'k', linewidth=3,\n         label='Total (2-terminal)')\nplt.plot(options.voltages, -solar_cell[3].iv(options.voltages)/10, 'b',\n         label='GaInP')\nplt.plot(options.voltages, -solar_cell[9].iv(options.voltages)/10, 'g',\n         label='Si')\nplt.text(0.1, 18, r\"2-terminal $\\eta$ = {:.2f}%\".format(solar_cell.iv[\"Eta\"]*100))\nplt.legend()\nplt.ylim(0, 20)\nplt.xlim(0, 1.9)\nplt.ylabel('Current (mA/cm$^2$)')\nplt.xlabel('Voltage (V)')\nplt.tight_layout()\nplt.show()\n\nTreating layer(s) 12 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell..."
  },
  {
    "objectID": "solcore-workshop/notebooks/7-InGaP_Si_planar.html#two-vs.-four-terminal-efficiency",
    "href": "solcore-workshop/notebooks/7-InGaP_Si_planar.html#two-vs.-four-terminal-efficiency",
    "title": "Section 7: Planar GaInP//Si tandem cell",
    "section": "Two vs. four-terminal efficiency",
    "text": "Two vs. four-terminal efficiency\nBy default, Solcore assumes any SolarCell object is a two-terminal device, and will thus calculate the total I-V curve assuming the cells are connected in series and that the current is limited by the lowest-current sub-cell. However, it will also calculate the I-V curves of the individual cells, so we can use this information to calculate the possible power output in a 4-terminal configuration where the cells operate independently from an electrical point of view:\n\nV = np.linspace(0, 1.3, 100)\nP_GaInP = V*solar_cell[3].iv(V)\nP_Si = V*solar_cell[9].iv(V)\n\nP_MPP_GaInP = max(-P_GaInP)\n\nP_MPP_Si = max(-P_Si)\n\neta_4T = (P_MPP_GaInP + P_MPP_Si)/AM15G.power_density\n\nprint('4-terminal efficiency: {:.1f} %'.format(eta_4T*100))\n\n4-terminal efficiency: 23.6 %"
  },
  {
    "objectID": "solcore-workshop/notebooks/7-InGaP_Si_planar.html#questionschallenges",
    "href": "solcore-workshop/notebooks/7-InGaP_Si_planar.html#questionschallenges",
    "title": "Section 7: Planar GaInP//Si tandem cell",
    "section": "Questions/challenges",
    "text": "Questions/challenges\n\nWhat causes the strange, sharp fringes in the simulation data of Fig. 1 in the reference paper? Can you reproduce them by modifying this code? Which version of the simulation do you think is more correct, and why?\nHow could you increase the current in one or both of the sub-cells (remember, unlike the paper, we assumed all the layers in the cell are planar!).\nOnce the light encounters an ‘incoherent’ (thick) layer, does it make sense to treat any layers below that as coherent?"
  },
  {
    "objectID": "solcore-workshop/notebooks/9a-GaInP_GaAs_Si_grating.html",
    "href": "solcore-workshop/notebooks/9a-GaInP_GaAs_Si_grating.html",
    "title": "Section 9a: Planar III-V on planar Si, with rear grating",
    "section": "",
    "text": "In this example, we will build two structures similar to those described in this paper. These are both triple-junction, two-terminal GaInP/GaAs/Si cells; one cell is planar, while the other has a diffraction grating deposited on the rear of the bottom Si cell to boost its current."
  },
  {
    "objectID": "solcore-workshop/notebooks/9a-GaInP_GaAs_Si_grating.html#setting-up",
    "href": "solcore-workshop/notebooks/9a-GaInP_GaAs_Si_grating.html#setting-up",
    "title": "Section 9a: Planar III-V on planar Si, with rear grating",
    "section": "Setting up",
    "text": "Setting up\n\nfrom solcore import material, si\nfrom solcore.absorption_calculator import search_db, download_db\nimport os\nfrom solcore.structure import Layer\nfrom solcore.light_source import LightSource\nfrom rayflare.transfer_matrix_method import tmm_structure\nfrom rayflare.options import default_options\nfrom rayflare.structure import Interface, BulkLayer, Structure\nfrom rayflare.matrix_formalism import process_structure, calculate_RAT\nfrom solcore.constants import q\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nAs before, we load some materials from the refractiveindex.info database. The MgF\\(_2\\) and Ta\\(_2\\)O\\(_5\\) are the same as the ARC example; the SU8 is a negative photoresist which was used in the reference paper The optical constants for silver are also loaded from a reliable literature source. Note that the exact compositions of some semiconductor alloy layers (InGaP, AlInP and AlGaAs) are not given in the paper and are thus reasonable guesses.\n\ndownload_db() # only needs to be run once\n\n\nMgF2_pageid = search_db(os.path.join(\"MgF2\", \"Rodriguez-de Marcos\"))[0][0];\nTa2O5_pageid = search_db(os.path.join(\"Ta2O5\", \"Rodriguez-de Marcos\"))[0][0];\nSU8_pageid = search_db(\"SU8\")[0][0];\nAg_pageid = search_db(os.path.join(\"Ag\", \"Jiang\"))[0][0];\n\nMgF2 = material(str(MgF2_pageid), nk_db=True)();\nTa2O5 = material(str(Ta2O5_pageid), nk_db=True)();\nSU8 = material(str(SU8_pageid), nk_db=True)();\nAg = material(str(Ag_pageid), nk_db=True)();\n\nwindow = material(\"AlInP\")(Al=0.52)\nGaInP = material(\"GaInP\")(In=0.5)\nAlGaAs = material(\"AlGaAs\")(Al=0.8)\nGaAs = material(\"GaAs\")()\nSi = material(\"Si\")\n\nAir = material(\"Air\")()\nAl2O3 = material(\"Al2O3P\")()\nAl = material(\"Al\")()"
  },
  {
    "objectID": "solcore-workshop/notebooks/9a-GaInP_GaAs_Si_grating.html#defining-the-cell-layers",
    "href": "solcore-workshop/notebooks/9a-GaInP_GaAs_Si_grating.html#defining-the-cell-layers",
    "title": "Section 9a: Planar III-V on planar Si, with rear grating",
    "section": "Defining the cell layers",
    "text": "Defining the cell layers\nNow we define the layers for the III-V top junctions, and the Si wafer, grouping them together in a logical way. In this example, we will only do optical simulations, so we will not set e.g. diffusion lengths or doping levels.\n\nARC = [\n    Layer(110e-9, MgF2),\n    Layer(65e-9, Ta2O5),\n]\n\nGaInP_junction = [\n    Layer(17e-9, window),\n    Layer(400e-9, GaInP),\n    Layer(100e-9, AlGaAs)\n]\n\ntunnel_1 = [\n    Layer(80e-9, AlGaAs),\n    Layer(20e-9, GaInP),\n]\n\nGaAs_junction = [\n    Layer(17e-9, GaInP),\n    Layer(1050e-9, GaAs),\n    Layer(70e-9, AlGaAs)]\n\ntunnel_2 = [\n    Layer(50e-9, AlGaAs),\n    Layer(125e-9, GaAs),\n    ]\n\nSi_junction = [\n    Layer(280e-6, Si(Nd=si(\"2e18cm-3\"), hole_diffusion_length=2e-6), role=\"emitter\"),\n]\n\ncoh_layers = len(ARC) + len(GaInP_junction) + len(tunnel_1) + len(GaAs_junction) + \\\n               len(tunnel_2)\n\nAs for Example 7, to get physically reasonable results we must treat the very thick layers in the structure incoherently. The coh_layers variable sums up how many thin layers (which must be treated coherently) must be included in the coherency_list options."
  },
  {
    "objectID": "solcore-workshop/notebooks/9a-GaInP_GaAs_Si_grating.html#planar-cell",
    "href": "solcore-workshop/notebooks/9a-GaInP_GaAs_Si_grating.html#planar-cell",
    "title": "Section 9a: Planar III-V on planar Si, with rear grating",
    "section": "Planar cell",
    "text": "Planar cell\nNow we define the planar cell, and options for the solver:\n\ncell_planar = tmm_structure(\n    ARC + GaInP_junction + tunnel_1 + GaAs_junction + tunnel_2 + Si_junction,\n    incidence=Air,\n    transmission=Ag,\n)\n\nn_layers = cell_planar.layer_stack.num_layers\n\ncoherency_list = [\"c\"]*coh_layers + [\"i\"]*(n_layers-coh_layers)\n\noptions = default_options()\n\nwl = np.arange(300, 1201, 10) * 1e-9\nAM15G = LightSource(source_type=\"standard\", version=\"AM1.5g\", x=wl,\n                    output_units=\"photon_flux_per_m\")\n\noptions.wavelengths = wl\noptions.coherency_list = coherency_list\noptions.coherent = False\n\nRun the TMM calculation for the planar cell, and then extract the relevant layer absorptions. These are used to calculate limiting currents (100% internal quantum efficiency), which are displayed on the plot with the absorption in each layer.\n\ntmm_result = cell_planar.calculate(options=options)\n\nGaInP_A = tmm_result['A_per_layer'][:,3]\nGaAs_A = tmm_result['A_per_layer'][:,8]\nSi_A = tmm_result['A_per_layer'][:,coh_layers]\n\nJmax_GaInP = q*np.trapz(GaInP_A*AM15G.spectrum()[1], x=wl)/10\nJmax_GaAs = q*np.trapz(GaAs_A*AM15G.spectrum()[1], x=wl)/10\nJmax_Si = q*np.trapz(Si_A*AM15G.spectrum()[1], x=wl)/10\n\nR_spacer_ARC = tmm_result['R']\n\nplt.figure(figsize=(6,4))\nplt.plot(wl * 1e9, GaInP_A, \"-k\", label=\"GaInP\")\nplt.plot(wl * 1e9, GaAs_A, \"-b\", label=\"GaAs\")\nplt.plot(wl * 1e9, Si_A, \"-r\", label=\"Si\")\nplt.plot(wl * 1e9, 1 - R_spacer_ARC, '-y', label=\"1 - R\")\n\nplt.text(450, 0.55, r\"{:.1f} mA/cm$^2$\".format(Jmax_GaInP))\nplt.text(670, 0.55, r\"{:.1f} mA/cm$^2$\".format(Jmax_GaAs))\nplt.text(860, 0.55, r\"{:.1f} mA/cm$^2$\".format(Jmax_Si))\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"Absorptance\")\nplt.tight_layout()\nplt.legend(loc='upper right')\nplt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)\nplt.show()\n\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/Ag/Jiang.yml loaded.\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/Ag/Jiang.yml loaded.\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/MgF2/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/MgF2/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/Ta2O5/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/Ta2O5/Rodriguez-de Marcos.yml loaded."
  },
  {
    "objectID": "solcore-workshop/notebooks/9a-GaInP_GaAs_Si_grating.html#cell-with-rear-grating",
    "href": "solcore-workshop/notebooks/9a-GaInP_GaAs_Si_grating.html#cell-with-rear-grating",
    "title": "Section 9a: Planar III-V on planar Si, with rear grating",
    "section": "Cell with rear grating",
    "text": "Cell with rear grating\nNow, for the cell with a grating on the rear, we have a multi-scale problem where we must combine the calculation of absorption in a very thick (compared to the wavelengths of light) layer of Si with the effect of a wavelength-scale (1000 nm pitch) diffraction grating. For this, we will use the Angular Redistribution Matrix Method (ARMM) which was also used in Example 8.\nThe front surface of the cell (i.e. all the layers on top of Si) are planar, and can be treated using TMM. The rear surface of the cell, which has a crossed grating consisting of silver and SU8, must be treated with RCWA to account for diffraction. The thick Si layer will be the bulk coupling layer between these two interfaces.\nFirst, we set up the rear grating surface; we must define its lattice vectors, and place the Ag rectangle in the unit cell of the grating. More details on how unit cells of different shapes can be defined for the RCWA solver can be found here.\n\nx = 1000\n\nd_vectors = ((x, 0), (0, x))\narea_fill_factor = 0.4\nhw = np.sqrt(area_fill_factor) * 500\n\nback_materials = [Layer(width=si(\"250nm\"),\n        material=SU8,\n        geometry=[{\"type\": \"rectangle\", \"mat\": Ag, \"center\": (x / 2, x / 2),\n                   \"halfwidths\": (hw, hw), \"angle\": 0}],\n    )]\n\nNow, we define the Si bulk layer, and the III-V layers which go in the front interface. Finally, we put everything together into the ARMM Structure, also giving the incidence and transmission materials.\n\nbulk_Si = BulkLayer(280e-6, Si(), name=\"Si_bulk\")\n\nIII_V_layers = ARC + GaInP_junction + tunnel_1 + GaAs_junction + tunnel_2\n\nfront_surf_planar = Interface(\"TMM\", layers=III_V_layers, name=\"III_V_front\",\n                              coherent=True)\n\nback_surf_grating = Interface(\n    \"RCWA\",\n    layers=back_materials,\n    name=\"crossed_grating_back\",\n    d_vectors=d_vectors,\n    rcwa_orders=60,\n)\n\ncell_grating = Structure(\n    [front_surf_planar, bulk_Si, back_surf_grating],\n    incidence=Air,\n    transmission=Ag,\n)\n\nBecause RCWA calculations are very slow compared to TMM, it makes sense to only carry out the RCWA calculation at wavelengths where the grating has any effect. Depending on the wavelength, all the incident light may be absorbed in the III-V layers or in its first pass through the Si, so it never reaches the grating. We check this by seeing which wavelengths have even a small amount of transmission into the silver back mirror, and only doing the new calculation at these wavelengths. At shorter wavelengths, the results previously calculated using TMM can be used.\n\nwl_rcwa = wl[tmm_result['T'] &gt; 1e-4] # check where transmission fraction is bigger\n# than 1E-4\n\noptions.wavelengths = wl_rcwa\noptions.project_name = \"III_V_Si_cell\"\noptions.n_theta_bins = 30\noptions.c_azimuth = 0.25\n\nprocess_structure(cell_grating, options, save_location='current')\nresults_armm = calculate_RAT(cell_grating, options, save_location='current')\nRAT = results_armm[0]"
  },
  {
    "objectID": "solcore-workshop/notebooks/9a-GaInP_GaAs_Si_grating.html#comparison-of-planar-and-grating-cell",
    "href": "solcore-workshop/notebooks/9a-GaInP_GaAs_Si_grating.html#comparison-of-planar-and-grating-cell",
    "title": "Section 9a: Planar III-V on planar Si, with rear grating",
    "section": "Comparison of planar and grating cell",
    "text": "Comparison of planar and grating cell\nWe extract the relevant absorption per layer, and use it to calculate the new limiting current for the Si junction. The plot compares the absorption in the Si with and without the grating.\n\nSi_A_total = np.zeros(len(wl))\nSi_A_total[tmm_result['T'] &gt; 1e-4] = RAT['A_bulk'][0]\nSi_A_total[tmm_result['T'] &lt;= 1e-4] = Si_A[tmm_result['T'] &lt;= 1e-4]\n\nJmax_Si_grating = q*np.trapz(Si_A_total*AM15G.spectrum()[1], x=wl)/10\n\nplt.figure(figsize=(6,3))\nplt.plot(wl * 1e9, GaInP_A, \"-k\", label=\"GaInP\")\nplt.plot(wl * 1e9, GaAs_A, \"-b\", label=\"GaAs\")\nplt.plot(wl * 1e9, Si_A, \"--r\", label=\"Si (planar)\")\nplt.plot(wl * 1e9, Si_A_total, '-r', label=\"Si (with grating)\")\nplt.text(420, 0.55, r\"{:.1f} mA/cm$^2$\".format(Jmax_GaInP))\nplt.text(670, 0.50, r\"{:.1f} mA/cm$^2$\".format(Jmax_GaAs))\nplt.text(860, 0.45, r\"{:.1f} mA/cm$^2$\".format(Jmax_Si_grating))\nplt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"Absorptance\")\n\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "solcore-workshop/notebooks/9a-GaInP_GaAs_Si_grating.html#questions",
    "href": "solcore-workshop/notebooks/9a-GaInP_GaAs_Si_grating.html#questions",
    "title": "Section 9a: Planar III-V on planar Si, with rear grating",
    "section": "Questions",
    "text": "Questions\n\nWhy does the grating only affect the absorption in Si at long wavelengths?\nWhat is the reason for using the angular redistribution matrix method, rather than defining an RCWA-only structure (rcwa_structure)?"
  },
  {
    "objectID": "solcore-workshop/workshop2023.html",
    "href": "solcore-workshop/workshop2023.html",
    "title": "Solcore Workshop 2023 (SKKU)",
    "section": "",
    "text": "Click here to view all the slides.\nOutline:\nDay 1:\n\nIntroduction to Solcore & computer modelling (lecture)\nIntegration for limiting current, limiting voltage model\nShockley-Queisser efficiency limit and detailed balance (DB) junction model (lecture)\n\nDay 2:\n\nIntroduction to drift-diffusion junction model, depletion approximation (lecture) & spectral irradiance\nThe depletion approximation: Si cell and GaAs cell\nOptical modelling using the transfer-matrix model (TMM):\n\nTMM introduction\nOptimizing an anti-reflection coating\n\nPlanar III-V on Si tandem solar cell\n\nDay 3:\n\nOptical absorption in textured Si: ray-tracing for pyramid textures, rigorous coupled-wave analysis (RCWA) for nano-scale gratings\nIII-V/Si cells with light-trapping structures:\n\nPlanar III-V wafer-bonded to silicon with planar front using e.g. epoxy\nPlanar III-V bonded to textured silicon with diffraction grating on rear\n\nConformal perovskite on silicon tandem cells"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/9b-GaInP_GaAs_Si_pyramids.html",
    "href": "solcore-workshop-2/notebooks/9b-GaInP_GaAs_Si_pyramids.html",
    "title": "Section 9b: Planar III-V epoxy-bonded to textured Si",
    "section": "",
    "text": "The structure in this example is based on that of the previous example (9a), but with the planar bottom Si cell replaced by a Si cell with a pyramidal texture, bonded to the III-V top cells with a low-index epoxy/glass layer.\nWe could use the angular redistribution matrix method as in the previous example - however, because in this example we only need to use TMM and ray-tracing (RT), we can use the ray-tracing method with integrated RT directly (this is generally faster, because we do not need to calculate the behaviour of the surfaces for every angle of incidence)."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/9b-GaInP_GaAs_Si_pyramids.html#setting-up",
    "href": "solcore-workshop-2/notebooks/9b-GaInP_GaAs_Si_pyramids.html#setting-up",
    "title": "Section 9b: Planar III-V epoxy-bonded to textured Si",
    "section": "Setting up",
    "text": "Setting up\nWe load relevant packages and define materials, the same as in the previous example.\n\nfrom solcore import material, si\nfrom solcore.absorption_calculator import search_db, download_db\nimport os\nfrom solcore.structure import Layer\nfrom solcore.light_source import LightSource\nfrom rayflare.ray_tracing import rt_structure\nfrom rayflare.transfer_matrix_method import tmm_structure\nfrom rayflare.textures import planar_surface, regular_pyramids\nfrom rayflare.options import default_options\nfrom solcore.constants import q\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# download_db()\n\n\nMgF2_pageid = search_db(os.path.join(\"MgF2\", \"Rodriguez-de Marcos\"))[0][0];\nTa2O5_pageid = search_db(os.path.join(\"Ta2O5\", \"Rodriguez-de Marcos\"))[0][0];\nSU8_pageid = search_db(\"SU8\")[0][0];\nAg_pageid = search_db(os.path.join(\"Ag\", \"Jiang\"))[0][0];\n\nepoxy = material(\"BK7\")()\n\nMgF2 = material(str(MgF2_pageid), nk_db=True)();\nTa2O5 = material(str(Ta2O5_pageid), nk_db=True)();\nSU8 = material(str(SU8_pageid), nk_db=True)();\nAg = material(str(Ag_pageid), nk_db=True)();\n\nwindow = material(\"AlInP\")(Al=0.52)\nGaInP = material(\"GaInP\")\nAlGaAs = material(\"AlGaAs\")\n\nAir = material(\"Air\")()\n\nGaAs = material(\"GaAs\")\n\nSi = material(\"Si\")\n\nAl2O3 = material(\"Al2O3P\")()\nAl = material(\"Al\")()\n\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\n1 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n234 main    MgF2    Rodriguez-de_Marcos main/MgF2/Rodriguez-de Marcos.yml   1   1   0.0299919   2.00146 960\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\n1 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n475 main    Ta2O5   Rodriguez-de_Marcos main/Ta2O5/Rodriguez-de Marcos.yml  1   1   0.0294938   1.51429 212\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\n2 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n2835    other   negative_tone_photoresists  Microchem_SU8_2000  other/resists/Microchem SU-8 2000.yml   1   0   0.32    0.8 200\n2836    other   negative_tone_photoresists  Microchem_SU8_3000  other/resists/Microchem SU-8 3000.yml   1   0   0.32    1.7 200\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\n1 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n2   main    Ag  Jiang   main/Ag/Jiang.yml   1   1   0.3 2.0 1701\n\n\nWe define the layers we will need, as before. We specify the thickness of the silicon (280 \\(\\mu\\)m) and epoxy (1 mm) at the top:\n\nd_Si = 280e-6 # thickness of Si wafer\nd_epoxy = 1e-6 # thickness of epoxy. In reality, the epoxy is much thicker, but the exact thickness doesn't matter \n               # because the material is transparent and we will treat it incoherently.\n\nGaInP_total_thickness = 350e-9\nGaAs_total_thickness = 1200e-9\n\nARC = [Layer(110e-9, MgF2), Layer(65e-9, Ta2O5)]\n\nGaInP_junction = [Layer(20e-9, window), Layer(GaInP_total_thickness, GaInP(In=0.50))]\n\n# 100 nm TJ\ntunnel_1 = [Layer(100e-9, AlGaAs(Al=0.8)), Layer(20e-9, GaInP(In=0.5))]\n\nGaAs_junction = [Layer(20e-9, GaInP(In=0.5)), Layer(GaAs_total_thickness, GaAs()), Layer(70e-9, AlGaAs(Al=0.8))]\n\nspacer_ARC = [Layer(80e-9, Ta2O5)]"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/9b-GaInP_GaAs_Si_pyramids.html#defining-the-cell-layers",
    "href": "solcore-workshop-2/notebooks/9b-GaInP_GaAs_Si_pyramids.html#defining-the-cell-layers",
    "title": "Section 9b: Planar III-V epoxy-bonded to textured Si",
    "section": "Defining the cell layers",
    "text": "Defining the cell layers\nThere are three interfaces in the cell which will define the structure to simulate:\n\nthe III-V/epoxy interface, where the epoxy itself will be treated as a bulk layer in the simulation\nthe epoxy/Si interface, where the Si has a pyramidal texture (the Si itself is another bulk layer in the simulation).\nthe rear surface of the cell, where the Si again has a pyramidal texture (and we assume there is a silver back mirror behind the cell)\n\nThese 3 interfaces are defined here, using the pre-defined textures for a planar surface or regular pyramids:\n\nfront_layers = ARC + GaInP_junction + tunnel_1 + GaAs_junction + spacer_ARC\n\nfront_surf = planar_surface(interface_layers = front_layers, prof_layers=np.arange(1, len(front_layers)+1))\n\nSi_front = regular_pyramids(elevation_angle=50, upright=True)\n\nSi_back = regular_pyramids(elevation_angle=50, upright=False)\n\nNow we set relevant options for the solver. We set the number of rays to trace at each wavelength (more rays will make the result less noisy, but increase computation time) and whether to calculate the absorption profile in the bulk layers (no, in this case). The randomize_surface options determines whether the ray keeps track of its positions in the unit cell while travelling between surfaces; we set this to False to mimic random pyramids.\n\noptions = default_options()\n\nwl = np.arange(300, 1201, 10) * 1e-9\nAM15G = LightSource(source_type=\"standard\", version=\"AM1.5g\", x=wl, output_units=\"photon_flux_per_m\")\n\noptions.wavelength = wl\noptions.project_name = \"III_V_Si_cell\"\n\n# options for ray-tracing\noptions.randomize_surface = True\noptions.n_rays = 1000\noptions.bulk_profile = False"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/9b-GaInP_GaAs_Si_pyramids.html#defining-the-structures",
    "href": "solcore-workshop-2/notebooks/9b-GaInP_GaAs_Si_pyramids.html#defining-the-structures",
    "title": "Section 9b: Planar III-V epoxy-bonded to textured Si",
    "section": "Defining the structures",
    "text": "Defining the structures\nFinally, we define the ray-tracing structure we will use, using the interfaces, bulk materials, and options set above. Because we want to calculate the reflection/absorption/transmission probabilities at the front surface using TMM, we set the use_TMM argument to True. We also define a completely planar cell with the same layer thicknesses etc. to compare and evaluate the effect of the textures Si surfaces.\n\noptical_structure = rt_structure(\n    textures=[front_surf, Si_front, Si_back],\n    materials=[epoxy, Si()],\n    widths=[d_epoxy, d_Si],\n    incidence=Air,\n    transmission=Ag,\n    options=options,\n    use_TMM=True,\n    save_location=\"current\", # lookup table save location\n    overwrite=True, # whether to overwrite any previously existing results, if found\n)\n\n# options for TMM\noptions.coherent = False\noptions.coherency_list = len(front_layers)*['c'] + ['i']*2\n\nplanar_optical_structure = tmm_structure(\n    layer_stack = front_layers + [Layer(d_epoxy, epoxy), Layer(d_Si, Si())],\n    incidence=Air,\n    transmission=Ag,\n)\n\nINFO: Pre-computing TMM lookup table(s)\n\n\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial main/MgF2/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial main/MgF2/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial main/Ta2O5/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial main/Ta2O5/Rodriguez-de Marcos.yml loaded."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/9b-GaInP_GaAs_Si_pyramids.html#calculations",
    "href": "solcore-workshop-2/notebooks/9b-GaInP_GaAs_Si_pyramids.html#calculations",
    "title": "Section 9b: Planar III-V epoxy-bonded to textured Si",
    "section": "Calculations",
    "text": "Calculations\nCalculate the R/A/T for the planar reference cell:\n\ntmm_result = planar_optical_structure.calculate(options=options)\n\nGaInP_A_tmm = tmm_result['A_per_layer'][:,3]\nGaAs_A_tmm = tmm_result['A_per_layer'][:,7]\nSi_A_tmm = tmm_result['A_per_layer'][:,len(front_layers)+1]\n\nJmax_GaInP_tmm = q*np.trapz(GaInP_A_tmm*AM15G.spectrum()[1], x=wl)/10\nJmax_GaAs_tmm = q*np.trapz(GaAs_A_tmm*AM15G.spectrum()[1], x=wl)/10\nJmax_Si_tmm = q*np.trapz(Si_A_tmm*AM15G.spectrum()[1], x=wl)/10\n\nCalculate the R/A/T for the textured cell:\n\nrt_result = optical_structure.calculate(options=options)\n\nGaInP_absorption_ARC = rt_result['A_per_interface'][0][:,3]\nGaAs_absorption_ARC = rt_result['A_per_interface'][0][:,7]\nSi_absorption_ARC = rt_result['A_per_layer'][:,1]\n\nJmax_GaInP = q*np.trapz(GaInP_absorption_ARC*AM15G.spectrum()[1], x=wl)/10\nJmax_GaAs = q*np.trapz(GaAs_absorption_ARC*AM15G.spectrum()[1], x=wl)/10\nJmax_Si = q*np.trapz(Si_absorption_ARC*AM15G.spectrum()[1], x=wl)/10"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/9b-GaInP_GaAs_Si_pyramids.html#plotting-the-results",
    "href": "solcore-workshop-2/notebooks/9b-GaInP_GaAs_Si_pyramids.html#plotting-the-results",
    "title": "Section 9b: Planar III-V epoxy-bonded to textured Si",
    "section": "Plotting the results",
    "text": "Plotting the results\nFinally, we plot the results; the solid lines show the results for the textured Si cell (calculated using ray-tracing), the dashed lines for the planar cell (calculated using TMM). The maximum possible currents are shown in the plot, with the value in brackets for Si being for the planar cell.\n\nplt.figure(figsize=(6,3))\nplt.plot(wl * 1e9, GaInP_absorption_ARC, \"-k\", label=\"GaInP\")\nplt.plot(wl * 1e9, GaAs_absorption_ARC, \"-b\", label=\"GaAs\")\nplt.plot(wl * 1e9, Si_absorption_ARC, \"-r\", label=\"Si\")\nplt.plot(wl * 1e9, GaInP_A_tmm, \"--k\")\nplt.plot(wl * 1e9, GaAs_A_tmm, \"--b\")\nplt.plot(wl * 1e9, Si_A_tmm, \"--r\")\nplt.plot(wl * 1e9, rt_result['R'], '-', color='grey', label=\"Reflected\")\nplt.plot(wl * 1e9, tmm_result['R'], '--', color='grey')\n\nplt.text(420, 0.55, r\"{:.1f} mA/cm$^2$\".format(Jmax_GaInP))\nplt.text(670, 0.55, r\"{:.1f} mA/cm$^2$\".format(Jmax_GaAs))\nplt.text(870, 0.55, r\"{:.1f} mA/cm$^2$\".format(Jmax_Si))\nplt.text(870, 0.45, r\"({:.1f} mA/cm$^2)$\".format(Jmax_Si_tmm))\n\nplt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/9b-GaInP_GaAs_Si_pyramids.html#questionschallenges",
    "href": "solcore-workshop-2/notebooks/9b-GaInP_GaAs_Si_pyramids.html#questionschallenges",
    "title": "Section 9b: Planar III-V epoxy-bonded to textured Si",
    "section": "Questions/challenges",
    "text": "Questions/challenges\n\nDoes it make sense to do a ray-tracing calculation for short wavelengths? For this structure, can you speed up the calculation and avoid the random noise at short wavelengths?\nHow much current is lost to parasitic absorption in e.g. tunnel junctions, window layers etc.?\nHow can we reduce reflection at the epoxy interfaces?\nIf the epoxy/glass layer is much thicker than the relevant incident wavelengths, and not absorbing, does the exact thickness matter in the simulation?\nWhat happens if only the rear surface is textured? Would a structure without the front texture have other advantages?\nWhy does the Si have lower absorption/limiting current in this structure compared to the previous example?"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/9b-GaInP_GaAs_Si_pyramids.html#electrical-calculation",
    "href": "solcore-workshop-2/notebooks/9b-GaInP_GaAs_Si_pyramids.html#electrical-calculation",
    "title": "Section 9b: Planar III-V epoxy-bonded to textured Si",
    "section": "Electrical calculation",
    "text": "Electrical calculation\nNow we can also use RayFlare’s optical results to run an electrical simulation in Solcore. To use the depletion approximation (DA) or drift-diffusion (PDD) solvers, we need the front surface reflectivity, and a depth-dependent absorption/generation profile. While so far we have been plotting total absorption per layer, RayFlare can calculate depth-dependent profiles too.\nWe need to import some more things, and set some options for solar_cell_solver, as we did before. We must set the optics_method option to 'external', since we want to pass the values calculated by RayFlare into Solcore.\n\nfrom solcore.solar_cell import SolarCell, Junction\nfrom solcore.solar_cell_solver import solar_cell_solver\nfrom rayflare.utilities import make_absorption_function\nfrom solcore.state import State\n\noptions = State(options) # convert the RayFlare options to Solcore options object so Solcore will recognise it\nV = np.linspace(-3, 0, 100)\noptions.optics_method = 'external'\noptions.voltages = V\noptions.internal_voltages = np.linspace(-4, 1, 200)\noptions.light_iv = True\noptions.mpp = True\noptions.light_source = AM15G\noptions.recalculate_absorption = True\n\n/Users/z3533914/.pyenv/versions/3.11.5/lib/python3.11/site-packages/solcore/registries.py:73: UserWarning: Optics solver 'RCWA' will not be available. An installation of S4 has not been found.\n  warn(\n\n\nNow, previously we only calculate total reflection/absorption/transmission. Now we want to calculate depth-dependent absorption (generation) profiles at every wavelength. We set some options for RayFlare for this (we can use the same options object) and then ask RayFlare to calculate the absorption profile:\n\noptions.bulk_profile = True\noptions.depth_spacing = 1e-9\noptions.depth_spacing_bulk = 10e-9\n\nprofile_data = optical_structure.calculate_profile(options)\n\nWe not only want to calculate the absorption profile in the bulk layers (the Si) but also the front surface layers, since the GaInP and GaAs junctions are defined as part of the front interface. This was the reason for defining the surface as:\nfront_surf = planar_surface(interface_layers = front_layers, prof_layers=np.arange(1, len(front_layers)+1))\nnear the start of the script. The prof_layers argument tells RayFlare we want to calculate the absorption profile in the surface layers, in addition to the total absorption.\nIn order for Solcore to use the information we just calculated, it must be in the right format. We need to provide Solcore with two things: the reflectance, and a function which describes the depth-dependent absorption. This function expects an argument which is an array of positions, and returns the generation (units of \\(m^{-1}\\)) at each position and each wavelength. Fortunately, RayFlare has a function which takes your layer structure, results, and user options, and creates such a function for you:\n\ndepths, external_optics_func = make_absorption_function(profile_data, optical_structure, options)\n\noptions.position = depths\n\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\n\n\nPreviously, we defined RayFlare rt_structure and tmm_structure objects to do the optical calculation. For the cell calculation, we need a Solcore SolarCell object, which needs different information (such as doping levels) to perform the electrical calculation. Here we create the junctions, making sure that the total layer thicknesses of each material are the same as they were in the ray-traced structure.\n\nGaInP_emitter_thickness = 100e-9\nGaAs_emitter_thickness = 200e-9\nSi_emitter_thickness = 1e-6\n\nGaInP_base_thickness = GaInP_total_thickness - GaInP_emitter_thickness\nGaAs_base_thickness = GaAs_total_thickness - GaAs_emitter_thickness\nSi_base_thickness = d_Si - Si_emitter_thickness\n\nGaInP_junction = Junction([\n    Layer(20e-9, material(\"AlInP\")(Al=0.52), Nd=si(\"1e18cm-3\"), role=\"window\"), # window\n    Layer(GaInP_emitter_thickness, GaInP(In=0.50, Nd=si(\"1e18cm-3\"), hole_diffusion_length=si(\"200nm\")), role=\"emitter\"), # emitter\n    Layer(GaInP_base_thickness, GaInP(In=0.50, Na=si(\"1e17cm-3\"), electron_diffusion_length=si(\"300nm\")), role=\"base\"), # base\n   ], kind=\"DA\") # TJ\n\nGaAs_junction = Junction([\n    Layer(20e-9, GaInP(In=0.5, Nd=si(\"1e18cm-3\")), role=\"window\"), # window\n    Layer(GaAs_emitter_thickness, GaAs(Nd=si(\"1e18cm-3\"), hole_diffusion_length=si(\"250nm\")), role=\"emitter\"), # emitter\n    Layer(GaAs_base_thickness, GaAs(Na=si(\"9e16cm-3\"), electron_diffusion_length=si(\"1000nm\")), role=\"base\"), # basee\n    Layer(70e-9, AlGaAs(Al=0.8, Na=si(\"4e18cm-3\")), role=\"bsf\") # BSF\n    ], kind=\"DA\")\n\nSi_junction = Junction([\n    Layer(Si_emitter_thickness, Si(Nd=si(\"1e19cm-3\"), hole_diffusion_length=si(\"1000nm\")), role=\"emitter\"),\n    Layer(Si_base_thickness, Si(Na=si(\"1e16cm-3\"), electron_diffusion_length=si(\"250um\")), role=\"base\")],\n    kind=\"DA\")\n\nsolar_cell = SolarCell(\n    ARC + [GaInP_junction] + tunnel_1 + [GaAs_junction] + spacer_ARC + [Layer(d_epoxy, epoxy)] + [Si_junction],\n    external_reflected=rt_result[\"R\"],\n    external_absorbed=external_optics_func)\n\nFinally, we are ready to the our cell calculations; first, we calculate and plot the light I-V:\n\nsolar_cell_solver(solar_cell, 'iv', options)\n\nplt.figure(2)\nplt.plot(-V, -solar_cell.iv['IV'][1]/10, 'k', linewidth=3, label='3J cell')\nplt.plot(-V, solar_cell(0).iv(V)/10, 'b', label='InGaP sub-cell')\nplt.plot(-V, solar_cell(1).iv(V)/10, 'g', label='GaAs sub-cell')\nplt.plot(-V, solar_cell(2).iv(V)/10, 'r', label='Si sub-cell')\nplt.text(1.5, 5,f'Jsc= {abs(solar_cell.iv.Isc/10):.2f} mA.cm' + r'$^{-2}$')\nplt.text(1.5, 4,f'Voc= {abs(solar_cell.iv.Voc):.2f} V')\nplt.text(1.5, 3,f'FF= {solar_cell.iv.FF*100:.2f} %')\nplt.text(1.5, 2,f'Eta= {solar_cell.iv.Eta*100:.2f} %')\n\nplt.legend()\nplt.ylim(-10, 15)\nplt.xlim(0, 3)\nplt.ylabel('Current (mA/cm$^2$)')\nplt.xlabel('Voltage (V)')\nplt.show()\n\nINFO: Solving optics of the solar cell...\n\n\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\n\n\n\n\n\nAnd now the QE (we also plot the total absorption in each junction for comparison with the EQE):\n\n\nsolar_cell_solver(solar_cell, 'qe', options)\n\nplt.figure(1)\nplt.plot(wl * 1e9, solar_cell(0).eqe(wl) * 100, 'b', label='GaInP QE')\nplt.plot(wl * 1e9, solar_cell(1).eqe(wl) * 100, 'g', label='GaAs QE')\nplt.plot(wl * 1e9, solar_cell(2).eqe(wl) * 100, 'r', label='Si QE')\nplt.fill_between(wl * 1e9, GaInP_absorption_ARC * 100, 0, alpha=0.3,\n         label='GaInP Abs.', color='b')\nplt.fill_between(wl * 1e9, GaAs_absorption_ARC * 100, 0, alpha=0.3,\n         label='GaAs Abs.', color='g')\nplt.fill_between(wl * 1e9, Si_absorption_ARC * 100, 0, alpha=0.3,\n         label='Ge Abs.', color='r')\n\nplt.plot(wl*1e9, 100*(1-solar_cell.reflected), '--k', label=\"100 - Reflectivity\")\nplt.legend()\nplt.ylim(0, 100)\nplt.ylabel('EQE (%)')\nplt.xlabel('Wavelength (nm)')\nplt.show()\n\nINFO: Solving optics of the solar cell...\n\n\nSolving QE of the solar cell..."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/10-perovskite_Si_rt.html",
    "href": "solcore-workshop-2/notebooks/10-perovskite_Si_rt.html",
    "title": "Section 10: Perovskite-Si tandem cell with pyramidal surfaces",
    "section": "",
    "text": "This example shows how you can simulate a perovskite-Si tandem cell with pyramidal surface textures, where the perovskite and other surface layers are assumed to be deposited conformally (i.e., also in a pyramid shape) on top of the Si. The perovskite optical constants are from this paper, while the structure is based on this paper We will calculate total reflection, transmission and absorption per layer as well as the wavelength-dependent absorption profiles in the perovskite and Si, which can be used in e.g. device simulations. We will look at the effect of treating the layers deposited on Si (including the perovskite) coherently or incoherently.\nFirst, import relevant packages and RayFlare functions:\nimport numpy as np\nimport os\n\nfrom solcore.structure import Layer\nfrom solcore.constants import q\nfrom solcore import material\nfrom solcore.absorption_calculator import search_db, download_db\nfrom solcore.light_source import LightSource\n\nfrom rayflare.textures import regular_pyramids\nfrom rayflare.options import default_options\nfrom rayflare.ray_tracing import rt_structure\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfrom cycler import cycler\n\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nNow we set some relevant options. We will scan across 20 x 20 surface points of the pyramid unit cell between 300 and 1200 nm, for unpolarized, normally-incident light. The randomize_surface option is set to True to prevent correlation between the incident position on the front and rear pyramids. The n_jobs option is set to -1, which means that all available cores will be used. If you want to use all but one core, change this to -2 etc. We also need to provide a project_name to save the lookup tables which will be calculated using TMM to use during ray-tracing.\nwavelengths = np.linspace(300, 1200, 40) * 1e-9\n\nAM15G = LightSource(source_type=\"standard\", version=\"AM1.5g\", x=wavelengths,\n                    output_units=\"photon_flux_per_m\")\n\noptions = default_options()\noptions.wavelength = wavelengths\noptions.nx = 20\noptions.ny = options.nx\noptions.n_rays = 4 * options.nx**2\noptions.depth_spacing = 1e-9\noptions.pol = \"u\"\noptions.I_thresh = 1e-3\noptions.project_name = \"perovskite_Si_rt\"\noptions.randomize_surface = True\noptions.n_jobs = -1 # use all cores; to use all but one, change to -2 etc."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/10-perovskite_Si_rt.html#adding-custom-materials",
    "href": "solcore-workshop-2/notebooks/10-perovskite_Si_rt.html#adding-custom-materials",
    "title": "Section 10: Perovskite-Si tandem cell with pyramidal surfaces",
    "section": "Adding custom materials",
    "text": "Adding custom materials\nWe define our materials. Note that some of these are custom materials added to the database; we only need to do this once. We then define the front layer stack (i.e. all the materials which are on top of the Si, excluding Si itself, which will be the ‘bulk’ material) and the rear layer stack. Layer stacks are always defined starting with the layer closest to the top of the cell.\n\n# Can comment out this block after running once to add materials to the database\nfrom solcore.material_system import create_new_material\n\ncreate_new_material(\"Perovskite_CsBr_1p6eV\", \"data/CsBr10p_1to2_n_shifted.txt\",\n                    \"data/CsBr10p_1to2_k_shifted.txt\")\ncreate_new_material(\"ITO_lowdoping\", \"data/model_back_ito_n.txt\",\n                    \"data/model_back_ito_k.txt\")\ncreate_new_material(\"aSi_i\", \"data/model_i_a_silicon_n.txt\",\n                    \"data/model_i_a_silicon_k.txt\")\ncreate_new_material(\"aSi_p\", \"data/model_p_a_silicon_n.txt\",\n                    \"data/model_p_a_silicon_k.txt\")\ncreate_new_material(\"aSi_n\", \"data/model_n_a_silicon_n.txt\",\n                    \"data/model_n_a_silicon_k.txt\")\ncreate_new_material(\"C60\", \"data/C60_Ren_n.txt\",\n                    \"data/C60_Ren_k.txt\")\ncreate_new_material(\"IZO\", \"data/IZO_Ballif_rO2_10pcnt_n.txt\",\n                    \"data/IZO_Ballif_rO2_10pcnt_k.txt\")\n# Comment out until here\n\n\n# download_db()\n\n\nMgF2_pageid = search_db(os.path.join(\"MgF2\", \"Rodriguez-de Marcos\"))[0][0];\nAg_pageid = search_db(os.path.join(\"Ag\", \"Jiang\"))[0][0];\n\nSi = material(\"Si\")()\nAir = material(\"Air\")()\nMgF2 = material(str(MgF2_pageid), nk_db=True)()\nITO_back = material(\"ITO_lowdoping\")()\nPerovskite = material(\"Perovskite_CsBr_1p6eV\")()\nAg = material(str(Ag_pageid), nk_db=True)()\naSi_i = material(\"aSi_i\")()\naSi_p = material(\"aSi_p\")()\naSi_n = material(\"aSi_n\")()\nLiF = material(\"LiF\")()\nIZO = material(\"IZO\")()\nC60 = material(\"C60\")()\n\n# stack based on doi:10.1038/s41563-018-0115-4\nfront_materials = [\n    Layer(100e-9, MgF2),\n    Layer(110e-9, IZO),\n    Layer(15e-9, C60),\n    Layer(1e-9, LiF),\n    Layer(440e-9, Perovskite),\n    Layer(6.5e-9, aSi_n),\n    Layer(6.5e-9, aSi_i),\n]\n\nback_materials = [Layer(6.5e-9, aSi_i), Layer(6.5e-9, aSi_p), Layer(240e-9, ITO_back)]\n\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\n1 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n234 main    MgF2    Rodriguez-de_Marcos main/MgF2/Rodriguez-de Marcos.yml   1   1   0.0299919   2.00146 960\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\n1 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n2   main    Ag  Jiang   main/Ag/Jiang.yml   1   1   0.3 2.0 1701"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/10-perovskite_Si_rt.html#defining-the-interfaces-and-structure",
    "href": "solcore-workshop-2/notebooks/10-perovskite_Si_rt.html#defining-the-interfaces-and-structure",
    "title": "Section 10: Perovskite-Si tandem cell with pyramidal surfaces",
    "section": "Defining the interfaces and structure",
    "text": "Defining the interfaces and structure\nNow we define our front and back surfaces, including interface_layers. We will use regular pyramids for both the front and back surface; these pyramids point out on both sides, but since the direction of the pyramids is defined relative to the front surface, we must set upright=True for the top surface and upright=False for the rear surface. We also gives the surfaces a name (used to save the lookup table data) and ask RayFlare to calculate the absorption profile in the 5th layer, which is the perovskite.\n\ntriangle_surf = regular_pyramids(\n    elevation_angle=55,\n    upright=True,\n    size=1,\n    interface_layers=front_materials,\n    name=\"coh_front\",\n    prof_layers=[5],\n)\n\ntriangle_surf_back = regular_pyramids(\n    elevation_angle=55,\n    upright=False,\n    size=1,\n    interface_layers=back_materials,\n    name=\"Si_back\",\n    coherency_list=[\"i\"] * len(back_materials),\n)\n\nNow we make our ray-tracing structure by combining the front and back surfaces, specifying the material in between (Si) and setting its width to 260 microns. In order to use the TMM lookuptables to calculate reflection/transmission/absorption probabilities we must also set use_TMM=True.\n\n%%capture\n\nrtstr_coh = rt_structure(\n    textures=[triangle_surf, triangle_surf_back],\n    materials=[Si],\n    widths=[260e-6],\n    incidence=Air,\n    transmission=Ag,\n    use_TMM=True,\n    options=options,\n    overwrite=True,\n    save_location=\"current\",\n)\n\n# calculate:\nresult_coh = rtstr_coh.calculate(options)\n\nINFO: Pre-computing TMM lookup table(s)\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\n\n\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial main/MgF2/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial main/MgF2/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial main/Ag/Jiang.yml loaded.\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial main/Ag/Jiang.yml loaded.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.WARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\n\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/10-perovskite_Si_rt.html#incoherent-calculation",
    "href": "solcore-workshop-2/notebooks/10-perovskite_Si_rt.html#incoherent-calculation",
    "title": "Section 10: Perovskite-Si tandem cell with pyramidal surfaces",
    "section": "Incoherent calculation",
    "text": "Incoherent calculation\nNow we define the same front surface and structure again, except now we will treat all the layers incoherently (i.e. no thin-film interference) in the TMM.\n\n%%capture\n\ntriangle_surf = regular_pyramids(\n    elevation_angle=55,\n    upright=True,\n    size=1,\n    interface_layers=front_materials,\n    coherency_list=[\"i\"] * len(front_materials),\n    name=\"inc_front\",\n    prof_layers=[5],\n)\n\nrtstr_inc = rt_structure(\n    textures=[triangle_surf, triangle_surf_back],\n    materials=[Si],\n    widths=[260e-6],\n    incidence=Air,\n    transmission=Ag,\n    use_TMM=True,\n    options=options,\n    overwrite=True,\n    save_location=\"current\",\n)\n\nresult_inc = rtstr_inc.calculate(options)\n\nINFO: Pre-computing TMM lookup table(s)\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\nINFO: Calculating next wavelength...\n\n\nNow we plot the results for reflection, transmission, and absorption per layer for both the coherent and incoherent cases.\n\npal = sns.color_palette(\"husl\", n_colors=len(front_materials) + len(back_materials) + 2)\n# create a colour palette\n\ncols = cycler(\"color\", pal)\n# set this as the default colour palette in matplotlib\n\nparams = {\n    \"axes.prop_cycle\": cols,\n}\n\nplt.rcParams.update(params)\n\nfig = plt.figure(figsize=(8, 3.7))\nplt.subplot(1, 1, 1)\nplt.plot(wavelengths * 1e9, result_coh[\"R\"], \"-ko\", label=\"R\")\nplt.plot(wavelengths * 1e9, result_coh[\"T\"], mfc=\"none\", label=\"T\")\nplt.plot(wavelengths * 1e9, result_coh[\"A_per_layer\"][:, 0], \"-o\", label='Si')\nplt.plot(wavelengths * 1e9, result_coh[\"A_per_interface\"][0], \"-o\",\n         label=[None, \"IZO\", \"C60\", None, \"Perovskite\", None, None])\nplt.plot(wavelengths * 1e9, result_coh[\"A_per_interface\"][1], \"-o\",\n         label=[None, None, \"ITO\"])\n\nplt.plot(wavelengths * 1e9, result_inc[\"R\"], \"--ko\", mfc=\"none\")\nplt.plot(wavelengths * 1e9, result_inc[\"T\"], mfc=\"none\")\nplt.plot(wavelengths * 1e9, result_inc[\"A_per_layer\"][:, 0], \"--o\", mfc=\"none\")\nplt.plot(wavelengths * 1e9, result_inc[\"A_per_interface\"][0], \"--o\", mfc=\"none\")\nplt.plot(wavelengths * 1e9, result_inc[\"A_per_interface\"][1], \"--o\", mfc=\"none\")\n\nplt.plot([300, 301], [0, 0], \"-k\", label=\"coherent\")\nplt.plot([300, 301], [0, 0], \"--k\", label=\"incoherent\")\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"R / A / T\")\nplt.ylim(0, 1)\nplt.xlim(300, 1200)\nplt.legend(bbox_to_anchor=(1.05, 1))\nplt.tight_layout()\nplt.show()\n\n\n\n\nCalculate and print the limiting short-circuit current per junction:\n\nJmax_Pero_coh = q*np.trapz(result_coh[\"A_per_interface\"][0][:,4]*AM15G.spectrum()[1],\n                                                        x=wavelengths)/10\nJmax_Si_coh = q*np.trapz(result_coh[\"A_per_layer\"][:, 0]*AM15G.spectrum()[1],\n                     x=wavelengths)/10\n\nprint(\"Limiting short-circuit currents in coherent calculation (mA/cm2): {:.2f} / {:\"\n      \".2f}\".format(Jmax_Pero_coh, Jmax_Si_coh))\n\nJmax_Pero_inc = q*np.trapz(result_inc[\"A_per_interface\"][0][:,4]*AM15G.spectrum()[1],\n                                                        x=wavelengths)/10\nJmax_Si_inc = q*np.trapz(result_inc[\"A_per_layer\"][:, 0]*AM15G.spectrum()[1],\n                     x=wavelengths)/10\n\nprint(\"Limiting short-circuit currents in coherent calculation (mA/cm2): {:.2f} / {:\"\n      \".2f}\".format(Jmax_Pero_inc, Jmax_Si_inc))\n\nLimiting short-circuit currents in coherent calculation (mA/cm2): 19.27 / 21.47\nLimiting short-circuit currents in coherent calculation (mA/cm2): 18.67 / 20.98"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/10-perovskite_Si_rt.html#absorption-profiles",
    "href": "solcore-workshop-2/notebooks/10-perovskite_Si_rt.html#absorption-profiles",
    "title": "Section 10: Perovskite-Si tandem cell with pyramidal surfaces",
    "section": "Absorption profiles",
    "text": "Absorption profiles\nWe can also plot the absorption profiles, for wavelengths up to 800 nm, in the perovskite (since we asked the solver to calculate the profile in the perovskite layer above).\n\nwl_Eg = wavelengths &lt; 800e-9\n\npal = sns.cubehelix_palette(sum(wl_Eg), reverse=True)\ncols = cycler(\"color\", pal)\nparams = {\n    \"axes.prop_cycle\": cols,\n}\nplt.rcParams.update(params)\n\npos = np.arange(0, rtstr_coh.interface_layer_widths[0][4], options.depth_spacing*1e9)\n\nfig, (ax1, ax2) = plt.subplots(1,2)\nax1.plot(pos, result_coh[\"interface_profiles\"][0][wl_Eg].T)\nax1.set_ylim(0, 0.02)\nax1.set_xlabel(\"z (nm)\")\nax1.set_ylabel(\"a(z)\")\nax1.set_title(\"Coherent\")\nax2.plot(pos, result_inc[\"interface_profiles\"][0][wl_Eg].T)\nax2.set_ylim(0, 0.02)\nax2.yaxis.set_ticklabels([])\nax2.set_xlabel(\"z (nm)\")\nax2.set_title(\"Incoherent\")\nplt.show()\n\n\n\n\nWe see that, as expected, the coherent case shows interference fringes while the incoherent case does not. We can also plot the absorption profile in the Si (&gt; 800 nm):\n\npos_bulk = pos = np.arange(0, rtstr_coh.widths[0]*1e6, options.depth_spacing_bulk*1e6)\n\nfig, (ax1, ax2) = plt.subplots(1,2)\nax1.semilogy(pos, result_coh[\"profile\"][~wl_Eg].T)\nax1.set_ylim(1e-8, 0.00015)\nax1.set_xlabel(\"z (um)\")\nax1.set_ylabel(\"a(z)\")\nax1.set_title(\"Coherent\")\nax2.semilogy(pos, result_inc[\"profile\"][~wl_Eg].T)\nax2.set_ylim(1e-8, 0.00015)\nax2.yaxis.set_ticklabels([])\nax2.set_xlabel(\"z (um)\")\nax2.set_title(\"Incoherent\")\nplt.show()"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/10-perovskite_Si_rt.html#questions",
    "href": "solcore-workshop-2/notebooks/10-perovskite_Si_rt.html#questions",
    "title": "Section 10: Perovskite-Si tandem cell with pyramidal surfaces",
    "section": "Questions",
    "text": "Questions\n\nWhy do you think the total absorption is slightly lower in the incoherent calculation?\nEven though the layers on top of the Si are not very thick compared to the wavelength, and they are the first thing encountered by the light, why might it make sense to treat them incoherently?\nCan you improve the current-matching (at least in terms of limiting currents) between the perovskite and the Si?"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/8-grating_pyramids_OPTOS.html",
    "href": "solcore-workshop-2/notebooks/8-grating_pyramids_OPTOS.html",
    "title": "Section 8: Textured Si",
    "section": "",
    "text": "This example is based on Figures 6, 7 and 8 from this paper. This compares three different structures, all based on a 200 micron thick slab of silicon with different surface textures:\nThe methods which will be used to calculate the redistribution matrices in each case are given in brackets. If case 1 and 2 are calculated first, then case 3 does not require the calculations of any additional matrices, since it will use the rear matrix from (1) and the front matrix from (2)."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/8-grating_pyramids_OPTOS.html#setting-up",
    "href": "solcore-workshop-2/notebooks/8-grating_pyramids_OPTOS.html#setting-up",
    "title": "Section 8: Textured Si",
    "section": "Setting up",
    "text": "Setting up\nFirst, importing relevant packages:\n\nimport numpy as np\nimport os\n\n# solcore imports\nfrom solcore.structure import Layer\nfrom solcore import material\nfrom solcore import si\n\nfrom rayflare.structure import Interface, BulkLayer, Structure\nfrom rayflare.matrix_formalism import process_structure, calculate_RAT\nfrom rayflare.utilities import get_savepath\nfrom rayflare.transfer_matrix_method import tmm_structure\nfrom rayflare.angles import theta_summary, make_angle_vector\nfrom rayflare.textures import regular_pyramids\nfrom rayflare.options import default_options\n\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport seaborn as sns\nfrom sparse import load_npz\n\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\n\n\nSetting options (taking the default options for everything not specified explicitly):\n\nangle_degrees_in = 8 # same as in Fraunhofer paper\n\nwavelengths = np.linspace(900, 1200, 20) * 1e-9\n\nSi = material(\"Si\")()\nAir = material(\"Air\")()\n\noptions = default_options()\noptions.wavelength = wavelengths\noptions.theta_in = angle_degrees_in * np.pi / 180 # incidence angle (polar angle)\noptions.n_theta_bins = 30\noptions.c_azimuth = 0.25\noptions.n_rays = 5e4 # number of rays per wavelength in ray-tracing\noptions.project_name = \"OPTOS_comparison\"\noptions.orders = 60 # number of RCWA orders to use (more = better convergence, but slower)\noptions.pol = \"u\" # unpolarized light\noptions.only_incidence_angle = True\noptions.RCWA_method = \"Inkstone\""
  },
  {
    "objectID": "solcore-workshop-2/notebooks/8-grating_pyramids_OPTOS.html#defining-the-structures",
    "href": "solcore-workshop-2/notebooks/8-grating_pyramids_OPTOS.html#defining-the-structures",
    "title": "Section 8: Textured Si",
    "section": "Defining the structures",
    "text": "Defining the structures\nNow, set up the grating basis vectors for the RCWA calculations and define the grating structure. These are squares, rotated by 45 degrees. The halfwidth is calculated based on the area fill factor of the etched pillars given in the paper.\n\nx = 1000\n\nd_vectors = ((x, 0), (0, x))\narea_fill_factor = 0.36\nhw = np.sqrt(area_fill_factor) * 500\n\nback_materials = [\n    Layer(width=si(\"120nm\"), material=Si,\n        geometry=[{\"type\": \"rectangle\", \"mat\": Air, \"center\": (x / 2, x / 2),\n                \"halfwidths\": (hw, hw), \"angle\": 45}],\n    )]\n\nNow we define the pyramid texture for the front surface in case (2) and (3) and make the four possible different surfaces: planar front and rear, front with pyramids, rear with grating. We specify the method to use to calculate the redistribution matrices in each case and create the bulk layer.\n\nsurf = regular_pyramids(elevation_angle=55, upright=False)\n\nfront_surf_pyramids = Interface(\n    \"RT_Fresnel\",\n    texture=surf,\n    layers=[],\n    name=\"inv_pyramids_front_\" + str(options[\"n_rays\"]),\n)\n\nfront_surf_planar = Interface(\"TMM\", layers=[], name=\"planar_front\")\n\nback_surf_grating = Interface(\n    \"RCWA\",\n    layers=back_materials,\n    name=\"crossed_grating_back\",\n    d_vectors=d_vectors,\n    rcwa_orders=20,\n)\n\nback_surf_planar = Interface(\"TMM\", layers=[], name=\"planar_back\")\n\nbulk_Si = BulkLayer(200e-6, Si, name=\"Si_bulk\")\n\nNow we create the different structures and ‘process’ them (this will calculate the relevant matrices if necessary, or do nothing if it finds the matrices have previously been calculated and the files already exist). We don’t need to process the final structure because it will use matrices calculated for SC_fig6 and SC_fig7.\n\n%%capture\n\nSC_fig6 = Structure(\n    [front_surf_planar, bulk_Si, back_surf_grating], incidence=Air, transmission=Air\n)\nSC_fig7 = Structure(\n    [front_surf_pyramids, bulk_Si, back_surf_planar], incidence=Air, transmission=Air\n)\nSC_fig8 = Structure(\n    [front_surf_pyramids, bulk_Si, back_surf_grating], incidence=Air, transmission=Air\n)\n\nprocess_structure(SC_fig6, options, save_location='current') # if you want to overwrite previous results, add overwrite=Trues\nprocess_structure(SC_fig7, options, save_location='current')\n\nINFO: Making matrix for planar surface using TMM for element 0 in structure\nINFO: Existing angular redistribution matrices found\nINFO: Existing angular redistribution matrices found\nINFO: RCWA calculation for element 2 in structure\nINFO: Existing angular redistribution matrices found\nINFO: Ray tracing with Fresnel equations for element 0 in structure\nINFO: Existing angular redistribution matrices found\nINFO: RT calculation for wavelength = 947.3684210526316 nm\nINFO: RT calculation for wavelength = 915.7894736842105 nm\nINFO: RT calculation for wavelength = 931.578947368421 nm\nINFO: RT calculation for wavelength = 994.7368421052631 nm\nINFO: RT calculation for wavelength = 1010.5263157894736 nm\nINFO: RT calculation for wavelength = 900.0000000000001 nm\nINFO: RT calculation for wavelength = 1026.3157894736842 nm\nINFO: RT calculation for wavelength = 978.9473684210526 nm\nINFO: RT calculation for wavelength = 1042.1052631578948 nm\nINFO: RT calculation for wavelength = 963.1578947368421 nm\nINFO: RT calculation for wavelength = 1057.8947368421054 nm\nINFO: RT calculation for wavelength = 1073.6842105263158 nm\nINFO: RT calculation for wavelength = 1089.4736842105265 nm\nINFO: RT calculation for wavelength = 1105.2631578947369 nm\nINFO: RT calculation for wavelength = 1121.0526315789475 nm\nINFO: RT calculation for wavelength = 1136.842105263158 nm\nINFO: RT calculation for wavelength = 1152.6315789473683 nm\nINFO: RT calculation for wavelength = 1168.421052631579 nm\nINFO: RT calculation for wavelength = 1184.2105263157896 nm\nINFO: RT calculation for wavelength = 1200.0000000000002 nm\nINFO: Making matrix for planar surface using TMM for element 2 in structure\n\n\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.WARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\n\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/8-grating_pyramids_OPTOS.html#calculating-rat",
    "href": "solcore-workshop-2/notebooks/8-grating_pyramids_OPTOS.html#calculating-rat",
    "title": "Section 8: Textured Si",
    "section": "Calculating R/A/T",
    "text": "Calculating R/A/T\nThen we ask RayFlare to calculate the reflection, transmission and absorption through matrix multiplication, and get the required result out (absorption in the bulk) for each cell. We also load the results from the reference paper to compare them to the ones calculated with RayFlare.\n\n%%capture\n\nresults_fig6 = calculate_RAT(SC_fig6, options, save_location='current')\nresults_fig7 = calculate_RAT(SC_fig7, options, save_location='current')\nresults_fig8 = calculate_RAT(SC_fig8, options, save_location='current')\n\nRAT_fig6 = results_fig6[0]\nRAT_fig7 = results_fig7[0]\nRAT_fig8 = results_fig8[0]\n\nsim_fig6 = np.loadtxt(\"data/optos_fig6_sim.csv\", delimiter=\",\")\nsim_fig7 = np.loadtxt(\"data/optos_fig7_sim.csv\", delimiter=\",\")\nsim_fig8 = np.loadtxt(\"data/optos_fig8_sim.csv\", delimiter=\",\")\n\nINFO: After iteration 1: maximum power fraction remaining = 0.2955034746873003\nINFO: After iteration 2: maximum power fraction remaining = 0.24735134017097984\nINFO: After iteration 3: maximum power fraction remaining = 0.2163507471365699\nINFO: After iteration 4: maximum power fraction remaining = 0.19159890069625435\nINFO: After iteration 5: maximum power fraction remaining = 0.17095529483161526\nINFO: After iteration 6: maximum power fraction remaining = 0.15344062600062974\nINFO: After iteration 7: maximum power fraction remaining = 0.1384291294436452\nINFO: After iteration 8: maximum power fraction remaining = 0.12547688890130715\nINFO: After iteration 9: maximum power fraction remaining = 0.11424326382940328\nINFO: After iteration 10: maximum power fraction remaining = 0.10445704654991224\nINFO: After iteration 11: maximum power fraction remaining = 0.09589761402726735\nINFO: After iteration 12: maximum power fraction remaining = 0.0883830436692257\nINFO: After iteration 13: maximum power fraction remaining = 0.08176193170317834\nINFO: After iteration 14: maximum power fraction remaining = 0.07590744044348399\nINFO: After iteration 15: maximum power fraction remaining = 0.07071278644058707\nINFO: After iteration 16: maximum power fraction remaining = 0.06608771669781371\nINFO: After iteration 17: maximum power fraction remaining = 0.0619556977477\nINFO: After iteration 18: maximum power fraction remaining = 0.05825164073869242\nINFO: After iteration 19: maximum power fraction remaining = 0.05492004211445781\nINFO: After iteration 20: maximum power fraction remaining = 0.05191345343864926\nINFO: After iteration 21: maximum power fraction remaining = 0.04919121562204323\nINFO: After iteration 22: maximum power fraction remaining = 0.046718407568182026\nINFO: After iteration 23: maximum power fraction remaining = 0.044464969858259776\nINFO: After iteration 24: maximum power fraction remaining = 0.042404972041952975\nINFO: After iteration 25: maximum power fraction remaining = 0.04051599822739152\nINFO: After iteration 26: maximum power fraction remaining = 0.038778630473564266\nINFO: After iteration 27: maximum power fraction remaining = 0.03717601330766723\nINFO: After iteration 28: maximum power fraction remaining = 0.03569348574421198\nINFO: After iteration 29: maximum power fraction remaining = 0.034318269637635124\nINFO: After iteration 30: maximum power fraction remaining = 0.03303920518123784\nINFO: After iteration 31: maximum power fraction remaining = 0.031846525969740455\nINFO: After iteration 32: maximum power fraction remaining = 0.030731667346668046\nINFO: After iteration 33: maximum power fraction remaining = 0.029687102821135403\nINFO: After iteration 34: maximum power fraction remaining = 0.028706204208766243\nINFO: After iteration 35: maximum power fraction remaining = 0.027783121866022602\nINFO: After iteration 36: maximum power fraction remaining = 0.026912681975976842\nINFO: After iteration 37: maximum power fraction remaining = 0.026090298330296663\nINFO: After iteration 38: maximum power fraction remaining = 0.025311896455915424\nINFO: After iteration 39: maximum power fraction remaining = 0.024573848270729514\nINFO: After iteration 40: maximum power fraction remaining = 0.023872915732924625\nINFO: After iteration 41: maximum power fraction remaining = 0.023206202183040037\nINFO: After iteration 42: maximum power fraction remaining = 0.022571110274614448\nINFO: After iteration 43: maximum power fraction remaining = 0.02196530555470288\nINFO: After iteration 44: maximum power fraction remaining = 0.021386684895000417\nINFO: After iteration 45: maximum power fraction remaining = 0.02083334909208419\nINFO: After iteration 46: maximum power fraction remaining = 0.020303579054949197\nINFO: After iteration 47: maximum power fraction remaining = 0.019795815082497975\nINFO: After iteration 48: maximum power fraction remaining = 0.019308638805378607\nINFO: After iteration 49: maximum power fraction remaining = 0.018840757427562815\nINFO: After iteration 50: maximum power fraction remaining = 0.018390989954995544\nINFO: After iteration 51: maximum power fraction remaining = 0.01795825514292941\nINFO: After iteration 52: maximum power fraction remaining = 0.017541560931354713\nINFO: After iteration 53: maximum power fraction remaining = 0.017139995170233478\nINFO: After iteration 54: maximum power fraction remaining = 0.016752717463871532\nINFO: After iteration 55: maximum power fraction remaining = 0.016378951987414226\nINFO: After iteration 56: maximum power fraction remaining = 0.01601798114871917\nINFO: After iteration 57: maximum power fraction remaining = 0.01566913998624118\nINFO: After iteration 58: maximum power fraction remaining = 0.015331811208484045\nINFO: After iteration 59: maximum power fraction remaining = 0.015005420793388834\nINFO: After iteration 60: maximum power fraction remaining = 0.014689434077044667\nINFO: After iteration 61: maximum power fraction remaining = 0.014383352270584045\nINFO: After iteration 62: maximum power fraction remaining = 0.014086709352282257\nINFO: After iteration 63: maximum power fraction remaining = 0.013799069288907425\nINFO: After iteration 64: maximum power fraction remaining = 0.013520023546425057\nINFO: After iteration 65: maximum power fraction remaining = 0.013249188855386125\nINFO: After iteration 66: maximum power fraction remaining = 0.012986205200837965\nINFO: After iteration 67: maximum power fraction remaining = 0.01273073401049334\nINFO: After iteration 68: maximum power fraction remaining = 0.012482456518260769\nINFO: After iteration 69: maximum power fraction remaining = 0.012241072283152531\nINFO: After iteration 70: maximum power fraction remaining = 0.012006297846108658\nINFO: After iteration 71: maximum power fraction remaining = 0.011777865509460205\nINFO: After iteration 72: maximum power fraction remaining = 0.011555522225649468\nINFO: After iteration 73: maximum power fraction remaining = 0.011339028583468616\nINFO: After iteration 74: maximum power fraction remaining = 0.011128157881506017\nINFO: After iteration 75: maximum power fraction remaining = 0.010922695279730358\nINFO: After iteration 76: maximum power fraction remaining = 0.010722437021222662\nINFO: After iteration 77: maximum power fraction remaining = 0.010527189717006499\nINFO: After iteration 78: maximum power fraction remaining = 0.010336769687746671\nINFO: After iteration 79: maximum power fraction remaining = 0.010151002356801959\nINFO: After iteration 80: maximum power fraction remaining = 0.009969721689742805\nINFO: After iteration 1: maximum power fraction remaining = 0.6904687021340956\nINFO: After iteration 2: maximum power fraction remaining = 0.5529545101509352\nINFO: After iteration 3: maximum power fraction remaining = 0.511292942194319\nINFO: After iteration 4: maximum power fraction remaining = 0.44224378131338016\nINFO: After iteration 5: maximum power fraction remaining = 0.39997454451423775\nINFO: After iteration 6: maximum power fraction remaining = 0.3485295085904421\nINFO: After iteration 7: maximum power fraction remaining = 0.3138482613917786\nINFO: After iteration 8: maximum power fraction remaining = 0.27553594442668927\nINFO: After iteration 9: maximum power fraction remaining = 0.24751635054463023\nINFO: After iteration 10: maximum power fraction remaining = 0.21840401464945428\nINFO: After iteration 11: maximum power fraction remaining = 0.19583800968944132\nINFO: After iteration 12: maximum power fraction remaining = 0.17344166256983365\nINFO: After iteration 13: maximum power fraction remaining = 0.15530793273842505\nINFO: After iteration 14: maximum power fraction remaining = 0.13789731413300393\nINFO: After iteration 15: maximum power fraction remaining = 0.12335775256871925\nINFO: After iteration 16: maximum power fraction remaining = 0.10971979419070547\nINFO: After iteration 17: maximum power fraction remaining = 0.09808315863565356\nINFO: After iteration 18: maximum power fraction remaining = 0.08734240233208478\nINFO: After iteration 19: maximum power fraction remaining = 0.0780417094944075\nINFO: After iteration 20: maximum power fraction remaining = 0.06955082453103606\nINFO: After iteration 21: maximum power fraction remaining = 0.06212436763500962\nINFO: After iteration 22: maximum power fraction remaining = 0.05539475523478134\nINFO: After iteration 23: maximum power fraction remaining = 0.04946888092506737\nINFO: After iteration 24: maximum power fraction remaining = 0.04412586351647957\nINFO: After iteration 25: maximum power fraction remaining = 0.03939959150147595\nINFO: After iteration 26: maximum power fraction remaining = 0.035152466756422904\nINFO: After iteration 27: maximum power fraction remaining = 0.03138417210722542\nINFO: After iteration 28: maximum power fraction remaining = 0.02800549474394666\nINFO: After iteration 29: maximum power fraction remaining = 0.025001662835576158\nINFO: After iteration 30: maximum power fraction remaining = 0.022336528444980536\nINFO: After iteration 31: maximum power fraction remaining = 0.019970345021341422\nINFO: After iteration 32: maximum power fraction remaining = 0.017850251895806992\nINFO: After iteration 33: maximum power fraction remaining = 0.01595879897926111\nINFO: After iteration 34: maximum power fraction remaining = 0.014265341950741119\nINFO: After iteration 35: maximum power fraction remaining = 0.012753479233909213\nINFO: After iteration 36: maximum power fraction remaining = 0.01140055750519969\nINFO: After iteration 37: maximum power fraction remaining = 0.010192162654957652\nINFO: After iteration 38: maximum power fraction remaining = 0.009111167021520275\nINFO: After iteration 1: maximum power fraction remaining = 0.7673983435875205\nINFO: After iteration 2: maximum power fraction remaining = 0.6372585557661392\nINFO: After iteration 3: maximum power fraction remaining = 0.5414879294120498\nINFO: After iteration 4: maximum power fraction remaining = 0.46198278041320184\nINFO: After iteration 5: maximum power fraction remaining = 0.39433973016867285\nINFO: After iteration 6: maximum power fraction remaining = 0.33676090679898063\nINFO: After iteration 7: maximum power fraction remaining = 0.28761095693740824\nINFO: After iteration 8: maximum power fraction remaining = 0.2456437571054792\nINFO: After iteration 9: maximum power fraction remaining = 0.20980167029275584\nINFO: After iteration 10: maximum power fraction remaining = 0.17918990119472689\nINFO: After iteration 11: maximum power fraction remaining = 0.15304474763794992\nINFO: After iteration 12: maximum power fraction remaining = 0.13071442653724563\nINFO: After iteration 13: maximum power fraction remaining = 0.11164227220874255\nINFO: After iteration 14: maximum power fraction remaining = 0.09535288871681696\nINFO: After iteration 15: maximum power fraction remaining = 0.08144024158383945\nINFO: After iteration 16: maximum power fraction remaining = 0.06955754767323634\nINFO: After iteration 17: maximum power fraction remaining = 0.059408621208283954\nINFO: After iteration 18: maximum power fraction remaining = 0.05074049344792487\nINFO: After iteration 19: maximum power fraction remaining = 0.04333710537780831\nINFO: After iteration 20: maximum power fraction remaining = 0.03701392274486675\nINFO: After iteration 21: maximum power fraction remaining = 0.03161333608191989\nINFO: After iteration 22: maximum power fraction remaining = 0.02700073227373622\nINFO: After iteration 23: maximum power fraction remaining = 0.02306113917976735\nINFO: After iteration 24: maximum power fraction remaining = 0.0196963598948841\nINFO: After iteration 25: maximum power fraction remaining = 0.016822525118259837\nINFO: After iteration 26: maximum power fraction remaining = 0.014368002659713427\nINFO: After iteration 27: maximum power fraction remaining = 0.012271611959434315\nINFO: After iteration 28: maximum power fraction remaining = 0.010481099123494625\nINFO: After iteration 29: maximum power fraction remaining = 0.008951834461485581\n\n\nFinally, we use TMM to calculate the absorption in a structure with a planar front and planar rear, as a reference.\n\nstruc = tmm_structure([Layer(si(\"200um\"), Si)], incidence=Air, transmission=Air)\noptions.coherent = False\noptions.coherency_list = [\"i\"]\nRAT = tmm_structure.calculate(struc, options)"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/8-grating_pyramids_OPTOS.html#plotting",
    "href": "solcore-workshop-2/notebooks/8-grating_pyramids_OPTOS.html#plotting",
    "title": "Section 8: Textured Si",
    "section": "Plotting",
    "text": "Plotting\nPlot everything together, including data from the reference paper for comparison:\n\npalhf = sns.color_palette(\"hls\", 4)\n\nfig = plt.figure()\nplt.plot(sim_fig6[:, 0], sim_fig6[:, 1],\n    \"--\", color=palhf[0], label=\"OPTOS - rear grating (1)\")\nplt.plot(wavelengths * 1e9, RAT_fig6[\"A_bulk\"][0],\n    \"-o\", color=palhf[0], label=\"RayFlare - rear grating (1)\", fillstyle=\"none\")\nplt.plot(sim_fig7[:, 0], sim_fig7[:, 1],\n    \"--\", color=palhf[1], label=\"OPTOS - front pyramids (2)\",)\nplt.plot(wavelengths * 1e9, RAT_fig7[\"A_bulk\"][0],\n    \"-o\", color=palhf[1], label=\"RayFlare - front pyramids (2)\", fillstyle=\"none\")\nplt.plot(sim_fig8[:, 0], sim_fig8[:, 1],\n    \"--\", color=palhf[2], label=\"OPTOS - grating + pyramids (3)\")\nplt.plot(wavelengths * 1e9, RAT_fig8[\"A_bulk\"][0],\n    \"-o\", color=palhf[2],label=\"RayFlare - grating + pyramids (3)\", fillstyle=\"none\",)\nplt.plot(wavelengths * 1e9, RAT[\"A_per_layer\"][:, 0], \"-k\", label=\"Planar\")\nplt.legend(loc=\"lower left\")\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"Absorption in Si\")\nplt.xlim([900, 1200])\nplt.ylim([0, 1])\nplt.show()\n\n\n\n\nWe can see good agreement between the reference values and our calculated values. The structure with rear grating also behaves identically to the planar TMM reference case at the short wavelengths where front surface reflection dominates the result, as expected. Clearly, the pyramids perform much better overall, giving a large boost in the absorption at long wavelengths and also reducing the reflection significantly at shorter wavelengths. Plotting reflection and transmission emphasises this:\n\nfig = plt.figure()\nplt.plot(wavelengths * 1e9,RAT_fig6[\"R\"][0],\n    \"-o\", color=palhf[0], label=\"RayFlare - rear grating (1)\", fillstyle=\"none\")\nplt.plot(wavelengths * 1e9, RAT_fig7[\"R\"][0],\n    \"-o\", color=palhf[1], label=\"RayFlare - front pyramids (2)\", fillstyle=\"none\")\nplt.plot(wavelengths * 1e9, RAT_fig8[\"R\"][0],\n    \"-o\", color=palhf[2], label=\"RayFlare - grating + pyramids (3)\", fillstyle=\"none\")\n\nplt.plot(wavelengths * 1e9, RAT_fig6[\"T\"][0], \"--o\", color=palhf[0])\nplt.plot(wavelengths * 1e9, RAT_fig7[\"T\"][0], \"--o\", color=palhf[1])\nplt.plot(wavelengths * 1e9, RAT_fig8[\"T\"][0], \"--o\", color=palhf[2])\n\n# these are just to create the legend:\nplt.plot(-1, 0, \"k-o\", label=\"R\", fillstyle=\"none\")\nplt.plot(-1, 0, \"k--o\", label=\"T\")\n\nplt.legend()\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"Reflected/transmitted fraction\")\nplt.xlim([900, 1200])\nplt.ylim([0, 0.6])\nplt.show()"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/8-grating_pyramids_OPTOS.html#redistribution-matrices",
    "href": "solcore-workshop-2/notebooks/8-grating_pyramids_OPTOS.html#redistribution-matrices",
    "title": "Section 8: Textured Si",
    "section": "Redistribution matrices",
    "text": "Redistribution matrices\nPlot the redistribution matrix for the rear grating (summed over azimuthal angles) at 1100 nm:\n\ntheta_intv, phi_intv, angle_vector = make_angle_vector(\n    options[\"n_theta_bins\"], options[\"phi_symmetry\"], options[\"c_azimuth\"])\n\npath = get_savepath(save_location='current', project_name=options.project_name)\nsprs = load_npz(os.path.join(path, SC_fig6[2].name + \"frontRT.npz\"))\n\nwl_to_plot = 1100e-9\nwl_index = np.argmin(np.abs(wavelengths - wl_to_plot))\n\nfull = sprs[wl_index].todense()\n\nsummat = theta_summary(full, angle_vector, options[\"n_theta_bins\"], \"front\")\nsummat_r = summat[: options[\"n_theta_bins\"], :]\nsummat_r = summat_r.rename({ r\"$\\theta_{in}$\": r\"$\\sin(\\theta_{in})$\",\n        r\"$\\theta_{out}$\": r\"$\\sin(\\theta_{out})$\"})\n\nsummat_r = summat_r.assign_coords({r\"$\\sin(\\theta_{in})$\": np.sin(summat_r.coords[r\"$\\sin(\\theta_{in})$\"]).data,\n    r\"$\\sin(\\theta_{out})$\": np.sin(summat_r.coords[r\"$\\sin(\\theta_{out})$\"]).data})\n\npalhf = sns.cubehelix_palette(256, start=0.5, rot=-0.9)\npalhf.reverse()\nseamap = mpl.colors.ListedColormap(palhf)\n\nfig = plt.figure()\nax = plt.subplot(111)\nax = summat_r.plot.imshow(ax=ax, cmap=seamap, vmax=0.3)\nplt.show()"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/8-grating_pyramids_OPTOS.html#questions",
    "href": "solcore-workshop-2/notebooks/8-grating_pyramids_OPTOS.html#questions",
    "title": "Section 8: Textured Si",
    "section": "Questions",
    "text": "Questions\n\nIf you can add only one of the textures (pyramids or a grating), which one is better? Why?\nWhy do the structures with a front-surface texture have high reflection at long wavelengths? The anti-reflection properties of pyramids (treated with ray optics) are mostly independent of the wavelength, so why does apparent reflection increase near the bandgap of Si?\nCan you explain any of the features present in the angular redistribution matrix of the rear grating surface?"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/7-InGaP_Si_planar.html",
    "href": "solcore-workshop-2/notebooks/7-InGaP_Si_planar.html",
    "title": "Section 7: Planar GaInP//Si tandem cell",
    "section": "",
    "text": "This example is partly based on the structure presented in this paper, but with planar interfaces instead of a textured Si surface. This is a four-terminal GaInP/Si device which uses an epoxy and glass to bond the two cells together mechanically. First, we will do optical-only calculations to look at the effect of an intermediate anti-reflection coating (on top of the epoxy/glass) on the absorption in the bottom Si cell, and then we will use the results of the optical calculation to do a device simulation and calculate external quantum efficiency and current-voltage under AM1.5G.\nNote: the paper linked above has a GaInP/AlGaInP heterojunction as the top junction. Because we do not have AlGaInP built in to Solcore’s database, this is replaced by a GaInP homojunction in this example.\nfrom solcore import material, si\nfrom solcore.absorption_calculator import search_db, download_db\nimport os\nfrom solcore.structure import Layer, Junction\nfrom solcore.solar_cell_solver import solar_cell_solver, default_options\nfrom solcore.solar_cell import SolarCell\nfrom solcore.light_source import LightSource\nfrom solcore.constants import q\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\n\n\n/Users/z3533914/.pyenv/versions/3.11.5/lib/python3.11/site-packages/solcore/registries.py:73: UserWarning: Optics solver 'RCWA' will not be available. An installation of S4 has not been found.\n  warn("
  },
  {
    "objectID": "solcore-workshop-2/notebooks/7-InGaP_Si_planar.html#defining-materials-layers-and-junctions",
    "href": "solcore-workshop-2/notebooks/7-InGaP_Si_planar.html#defining-materials-layers-and-junctions",
    "title": "Section 7: Planar GaInP//Si tandem cell",
    "section": "Defining materials, layers and junctions",
    "text": "Defining materials, layers and junctions\nThe paper referenced above uses a double-layer anti-reflection coating (ARC) made of MgF\\(_2\\) and ZnS. As in the previous example, we use the interface to the refractiveindex.info database to select optical constant data from specific sources, and define Solcore materials using this data. The III-V materials are taken from Solcore’s own material database.\nNote that for the epoxy/glass layer, we use only a single material (BK7 glass). The epoxy and glass used in the paper have the same refractive index (n = 1.56), so we can use a single material with an appropriate refractive index to represent them.\n\ndownload_db(confirm=True) # uncomment to download database\n\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaking request to https://refractiveindex.info/download/database/rii-database-2021-07-18.zip\nDownloaded and extracting...\nWrote /var/folders/wh/w5k56r_927j4yp3mh91bggfc0000gq/T/tmpxl4nacr8/database from https://refractiveindex.info/download/database/rii-database-2021-07-18.zip\nLOG: 2746,other,PtAl2,Chen : Bad Material YAML File.\n***Wrote SQLite DB on  /Users/z3533914/.solcore/nk/nk.db\n\n\n/Users/z3533914/.pyenv/versions/3.11.5/lib/python3.11/site-packages/solcore/material_data/refractiveindex_info_DB/dbmaterial.py:278: RuntimeWarning: invalid value encountered in sqrt\n  n = numpy.sqrt(nsq)\n/Users/z3533914/.pyenv/versions/3.11.5/lib/python3.11/site-packages/solcore/material_data/refractiveindex_info_DB/dbmaterial.py:299: RuntimeWarning: invalid value encountered in sqrt\n  n = numpy.sqrt(n)\n\n\n\n%%capture\n\nMgF2_pageid = search_db(os.path.join(\"MgF2\", \"Rodriguez-de Marcos\"))[0][0];\nZnS_pageid = search_db(os.path.join(\"ZnS\", \"Querry\"))[0][0];\nMgF2 = material(str(MgF2_pageid), nk_db=True)();\nZnS = material(str(ZnS_pageid), nk_db=True)();\n\nwindow = material(\"AlInP\")(Al=0.52)\nGaInP = material(\"GaInP\")\nBSF = material(\"AlGaAs\")(Al=0.5)\n\nepoxy = material(\"BK7\")()\n\nFor the Si cell, the front surface has both a low-index and high-index SiN\\(x\\) layer. The rear surface uses Al\\(2\\)O\\(3\\), and the cell has Al at the rear surface.\n\nSiOx = material(\"SiO\")()\nSiN_191_pageid = search_db(\"Vogt-1.91\")[0][0];\nSiN_213_pageid = search_db(\"Vogt-2.13\")[0][0];\nSiN_191 = material(str(SiN_191_pageid), nk_db=True)();\nSiN_213 = material(str(SiN_213_pageid), nk_db=True)();\n\nSi = material(\"Si\")\n\nAl2O3 = material(\"Al2O3P\")()\nAl = material(\"Al\")()\n\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\n1 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n2816    other   SiN Vogt-1.91   anti-reflective coatings/SiN/Vogt-1.91.yml  1   1   0.25    1.7 146\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\n1 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n2818    other   SiN Vogt-2.13   anti-reflective coatings/SiN/Vogt-2.13.yml  1   1   0.25    1.7 146\n\n\nWe now define the layers used in the top cell stack: the ARC and window layer for the top cell, and the GaInP junction itself. The ARC and window layers are not involved in the electrical calculation using the depletion approximation, so they are defined as simple layers, while the GaInP emitter and base are defined as part of a Junction object.\n\nARC_window = [\n    Layer(97e-9, MgF2),\n    Layer(41e-9, ZnS),\n    Layer(17e-9, window, role=\"window\"),\n]\n\nGaInP_junction = Junction([\n    Layer(200e-9, GaInP(In=0.50, Nd=si(\"2e18cm-3\"), hole_diffusion_length=si(\"300nm\")),\n          role=\"emitter\"),\n    Layer(750e-9, GaInP(In=0.50, Na=si(\"1e17cm-3\"), electron_diffusion_length=si(\n        \"800nm\")),\n          role=\"base\"),\n    Layer(500e-9, BSF, role=\"bsf\")], kind=\"DA\", sn=1, sp=1\n)\n\nWe now define the spacer layer, with and without a ZnS anti-reflection coating, so we can compare their performance in the cell stack. Note that we set the epoxy thickness here to be 10 microns, although the real thickness is much higher - this is because the epoxy/glass is not absorbing at the wavelengths which are able to reach it (which are not absorbed in the GaInP top cell), and we will treat it incoherently (no thin-film interference), so the exact thickness does not matter.\n\nspacer = [\n    Layer(82e-9, ZnS),\n    Layer(10e-6, epoxy), # real thickness is much higher, but since this layer is\n    # non-absorbing at the relevant wavelength (&gt; 650 nm) and treated incoherently,\n    # this does not matter\n]\n\nspacer_noARC = [\n    Layer(10e-6, epoxy),\n]\n\nNow we define the layer stacks for the Si cell, including the front SiO\\(_x\\)/SiN\\(_x\\) stack, the junction itself, and the back dielectric layers.\n\nSi_front_surf = [\n    Layer(100e-9, SiOx),\n    Layer(70e-9, SiN_191),\n    Layer(15e-9, SiN_213),\n    ]\n\nSi_junction = Junction([\n    Layer(1e-6, Si(Nd=si(\"2e18cm-3\"), hole_diffusion_length=2e-6), role=\"emitter\"),\n    Layer(150e-6, Si(Na=si(\"2e15cm-3\"), electron_diffusion_length=150e-6), role=\"base\"),\n], kind=\"DA\", sn=0.1, sp=0.1)\n\nSi_back_surf = [\n    Layer(15e-9, Al2O3),\n    Layer(120e-9, SiN_191)\n]"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/7-InGaP_Si_planar.html#comparing-the-optical-performance-with-and-without-intermediate-arc",
    "href": "solcore-workshop-2/notebooks/7-InGaP_Si_planar.html#comparing-the-optical-performance-with-and-without-intermediate-arc",
    "title": "Section 7: Planar GaInP//Si tandem cell",
    "section": "Comparing the optical performance with and without intermediate ARC",
    "text": "Comparing the optical performance with and without intermediate ARC\nNow we will run the calculation. We will treat some of the layers (those above the epoxy) with a coherent TMM calculation, and the epoxy and the layers below it using incoherent TMM. We will discuss the difference this makes, why this is important, and when to use coherent and incoherent layers.\n\nn_coh_layers = len(ARC_window + GaInP_junction)\nn_inc_layers = 1 + len(Si_front_surf + Si_junction + Si_back_surf)\n\nwl = np.linspace(300, 1200, 600) * 1e-9\n\noptions = default_options\noptions.recalculate_absorption = True\noptions.wavelength = wl\noptions.optics_method = 'TMM'\n\nAM15G = LightSource(source_type=\"standard\", version=\"AM1.5g\", x=wl*1e9,\n                    output_units=\"photon_flux_per_nm\")\n\nNow we define two versions of the cell for optical calculations, without and with the ZnS anti-reflection coating on the epoxy. Note that we also set the substrate for the calculation (aluminium) here.\n\ncell_no_ARC = SolarCell(\n    ARC_window + GaInP_junction + spacer_noARC + Si_front_surf + Si_junction +\n    Si_back_surf,\n    substrate=Al,\n)\n\ncell_with_ARC = SolarCell(\n    ARC_window + GaInP_junction + spacer + Si_front_surf + Si_junction + Si_back_surf,\n    substrate=Al,\n)\n\nWe set the appropriate coherency list for the structure (a list with entry ‘c’ for a coherent layer or ‘i’ for an incoherent layer), and solve for the cell optics of the cell without the intermediate ARC. We get the total absorption in the GaInP and Si junctions.\n\n%%capture\n\noptions.coherency_list = ['c']*(n_coh_layers) + ['i']*n_inc_layers\nsolar_cell_solver(cell_no_ARC, \"optics\", options)\n\nGaInP_A = cell_no_ARC[3].layer_absorption + cell_no_ARC[4].layer_absorption\nSi_A = cell_no_ARC[10].layer_absorption + cell_no_ARC[11].layer_absorption\n\nTreating layer(s) 11 incoherently\nCalculating RAT...\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial main/MgF2/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial main/MgF2/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial main/ZnS/Querry.yml loaded.\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial main/ZnS/Querry.yml loaded.\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial anti-reflective coatings/SiN/Vogt-1.91.yml loaded.\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial anti-reflective coatings/SiN/Vogt-1.91.yml loaded.\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial anti-reflective coatings/SiN/Vogt-2.13.yml loaded.\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial anti-reflective coatings/SiN/Vogt-2.13.yml loaded.\nCalculating absorption profile...\n\n\nAs above, but for the cell with an intermediate ARC:\n\noptions.coherency_list = [\"c\"]*(n_coh_layers + 1) + ['i']*n_inc_layers\nsolar_cell_solver(cell_with_ARC, \"optics\", options)\n\nGaInP_A_ARC = cell_with_ARC[3].layer_absorption + cell_with_ARC[4].layer_absorption\nSi_A_ARC = cell_with_ARC[11].layer_absorption + cell_with_ARC[12].layer_absorption\n\nTreating layer(s) 12 incoherently\nCalculating RAT...\nCalculating absorption profile...\n\n\nNow we plot the GaInP and Si absorption, and the reflectance of the whole structure, for both cells:\n\nplt.figure()\n\nplt.plot(wl * 1e9, GaInP_A_ARC, \"-k\", label=\"GaInP\")\nplt.plot(wl * 1e9, Si_A_ARC, \"-r\", label=\"Si\")\nplt.plot(wl * 1e9, cell_with_ARC.reflected, '-b', label=\"R\")\n\nplt.plot(wl * 1e9, GaInP_A, \"--k\", label=\"No middle ARC\")\nplt.plot(wl * 1e9, Si_A, \"--r\")\nplt.plot(wl * 1e9, cell_no_ARC.reflected, '--b')\n\nplt.legend(loc='upper right')\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"Absorptance/Reflectance\")\nplt.tight_layout()\nplt.show()\n\n\n\n\nWe see that the cell without an ARC on the epoxy shows much stronger interference fringes (due to the thickness of the top stack), and higher reflectance overall in the long-wavelength region (at short wavelengths, light is absorbed before it is able to reach the epoxy at all). Before doing an actual electrical calculation, we will calculate the limiting current in both of the sub-cells (assuming all the generated charge carriers can be collected):\n\nJ_GaInP = q*np.trapz(GaInP_A * AM15G.spectrum()[1], wl*1e9)\nJ_Si = q*np.trapz(Si_A * AM15G.spectrum()[1], wl*1e9)\n\nprint(\"Limiting short-circuit currents without ARC (mA/cm2): {:.1f} / {:.1f}\".format(\n      J_GaInP/10, J_Si/10))\n\nJ_GaInP_ARC = q*np.trapz(GaInP_A_ARC * AM15G.spectrum()[1], wl*1e9)\nJ_Si_ARC = q*np.trapz(Si_A_ARC * AM15G.spectrum()[1], wl*1e9)\n\nprint(\"Limiting short-circuit currents with ARC (mA/cm2): {:.1f} / {:.1f}\".format(\n    J_GaInP_ARC/10, J_Si_ARC/10))\n\nLimiting short-circuit currents without ARC (mA/cm2): 16.4 / 15.5\nLimiting short-circuit currents with ARC (mA/cm2): 16.4 / 17.4\n\n\nAs expected from the reduced reflection and increased absorption in the Si, the cell with an intermediate ARC has significantly higher maximum current in the bottom Si cell."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/7-InGaP_Si_planar.html#eqe-and-iv-calculation",
    "href": "solcore-workshop-2/notebooks/7-InGaP_Si_planar.html#eqe-and-iv-calculation",
    "title": "Section 7: Planar GaInP//Si tandem cell",
    "section": "EQE and IV calculation",
    "text": "EQE and IV calculation\nNow, just taking the structure with an intermediate ARC, we do a cell calculation using the depletion approximation.\n\noptions.mpp = True\noptions.light_iv = True\noptions.voltages = np.linspace(-1.9, 0.1, 100)\noptions.light_source = AM15G\n\nsolar_cell = SolarCell(\n    ARC_window + [GaInP_junction] + spacer + Si_front_surf + [Si_junction] +\n    Si_back_surf,\n    substrate=Al,\n)\n\nFirst, we calculate and plot the external quantum efficiency (EQE):\n\nsolar_cell_solver(solar_cell, 'qe', options)\n\nplt.figure()\nplt.plot(wl * 1e9, GaInP_A_ARC, \"--k\", label=\"GaInP only absorption\")\nplt.plot(wl * 1e9, Si_A_ARC, \"--r\", label=\"Si only absorption\")\nplt.plot(wl*1e9, solar_cell[3].eqe(wl), '-k')\nplt.plot(wl*1e9, solar_cell[9].eqe(wl), '-r')\nplt.legend(loc='upper right')\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"Absorptance/EQE\")\nplt.ylim(0,1)\nplt.tight_layout()\nplt.show()\n\nTreating layer(s) 12 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving QE of the solar cell...\n\n\n\n\n\nAnd the current-voltage under AM1.5G:\n\nsolar_cell_solver(solar_cell, 'iv', options)\n\nplt.figure()\nplt.plot(-options.voltages, -solar_cell.iv['IV'][1]/10, 'k', linewidth=3,\n         label='Total (2-terminal)')\nplt.plot(-options.voltages, solar_cell[3].iv(options.voltages)/10, 'b',\n         label='GaInP')\nplt.plot(-options.voltages, solar_cell[9].iv(options.voltages)/10, 'g',\n         label='Si')\nplt.text(0.1, 18, r\"2-terminal $\\eta$ = {:.2f}%\".format(solar_cell.iv[\"Eta\"]*100))\nplt.legend()\nplt.ylim(0, 20)\nplt.xlim(0, 1.9)\nplt.ylabel('Current (mA/cm$^2$)')\nplt.xlabel('Voltage (V)')\nplt.tight_layout()\nplt.show()\n\nTreating layer(s) 12 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell..."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/7-InGaP_Si_planar.html#two-vs.-four-terminal-efficiency",
    "href": "solcore-workshop-2/notebooks/7-InGaP_Si_planar.html#two-vs.-four-terminal-efficiency",
    "title": "Section 7: Planar GaInP//Si tandem cell",
    "section": "Two vs. four-terminal efficiency",
    "text": "Two vs. four-terminal efficiency\nBy default, Solcore assumes any SolarCell object is a two-terminal device, and will thus calculate the total I-V curve assuming the cells are connected in series and that the current is limited by the lowest-current sub-cell. However, it will also calculate the I-V curves of the individual cells, so we can use this information to calculate the possible power output in a 4-terminal configuration where the cells operate independently from an electrical point of view:\n\nV = np.linspace(0, 1.3, 100)\nP_GaInP = V*solar_cell[3].iv(V)\nP_Si = V*solar_cell[9].iv(V)\n\nP_MPP_GaInP = max(P_GaInP)\n\nP_MPP_Si = max(P_Si)\n\neta_4T = (P_MPP_GaInP + P_MPP_Si)/AM15G.power_density\n\nprint('4-terminal efficiency: {:.1f} %'.format(eta_4T*100))\n\n4-terminal efficiency: 39.6 %"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/7-InGaP_Si_planar.html#questionschallenges",
    "href": "solcore-workshop-2/notebooks/7-InGaP_Si_planar.html#questionschallenges",
    "title": "Section 7: Planar GaInP//Si tandem cell",
    "section": "Questions/challenges",
    "text": "Questions/challenges\n\nWhat causes the strange, sharp fringes in the simulation data of Fig. 1 in the reference paper? Can you reproduce them by modifying this code? Which version of the simulation do you think is more correct, and why?\nHow could you increase the current in one or both of the sub-cells (remember, unlike the paper, we assumed all the layers in the cell are planar!).\nOnce the light encounters an ‘incoherent’ (thick) layer, does it make sense to treat any layers below that as coherent?"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/5b-Si_cell_PDD.html",
    "href": "solcore-workshop-2/notebooks/5b-Si_cell_PDD.html",
    "title": "Section 5b: Planar Si solar cell using PDD",
    "section": "",
    "text": "In the previous example, we looked at a silicon cell using the depletion approximation. Here, we will instead use one of Solcore’s Poisson drift-diffusion (PDD) solvers, which can handle doping profiles (not just constant doping levels). Note that Solcore actually has two PDD solvers: a built-in one which was developed in Fortran specifically for cells with quantum wells, and an interface to the Sesame package, which was written in Python and developed for silicon-based cells. Here, we will use the Sesame solver.\nThe script starts of in much the same way as the DA cell in the previous example: we import relevant external packages and Solcore features, define some of the materials we will use, and set user options for solar_cell_solver.\nfrom solcore.solar_cell import SolarCell, Junction, Layer\nfrom solcore.state import State\nfrom solcore.solar_cell_solver import solar_cell_solver\nimport numpy as np\nfrom solcore.light_source import LightSource\nfrom scipy.special import erfc\n\nimport matplotlib.pyplot as plt\n\nfrom solcore import material, si\n\nAir = material(\"Air\")()\nMgF2 = material(\"MgF2\")()\nAg = material(\"Ag\")()\nTCO = material('ITO2')()\n\nwavelengths = np.linspace(280, 1200, 100)*1e-9\n\noptions = State() # initialise the options\noptions.wavelength = wavelengths\noptions.optics_method = 'TMM'\noptions.light_iv = True\noptions.T = 298\noptions.light_source = LightSource(source_type=\"standard\",\n                           version=\"AM1.5g\", x=options.wavelength)\n\noptions.voltages = np.linspace(0, 0.8, 40)\noptions.internal_voltages = options.voltages\noptions.mpp = True\noptions.no_back_reflection = False\noptions.position = 1e-9"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/5b-Si_cell_PDD.html#defining-materials-and-doping-profile",
    "href": "solcore-workshop-2/notebooks/5b-Si_cell_PDD.html#defining-materials-and-doping-profile",
    "title": "Section 5b: Planar Si solar cell using PDD",
    "section": "Defining materials and doping profile",
    "text": "Defining materials and doping profile\nThe Sesame PDD solver which we will be using can accept depth-dependent doping profiles (although you can also still set constant doping, like in the previous example, for each layer). Because we are going to pass a doping profile rather than distinct p and n-type materials, we just define one Si material which will be used for the whole junction, with electron and hole mobilities and lifetimes.\nOf course, there are many other material parameters which the PDD solver must have access to, such as radiative and Auger recombination rates, electron affinity, etc.; these are stored in Solcore’s material database, but they can always be overridden by user-specified values when calling the material function.\n\nSi_pn = material(\"Si\")(electron_mobility=si(\"1e4cm2\"), hole_mobility=si(\"1e3cm2\"),\n                       electron_minority_lifetime=0.001, hole_minority_lifetime=0.001)\n\nNow we will define the doping profile. We will define a p-n junction, with the highly-doped region (the emitter) at the rear and an complimentary error function (‘erfc’) profile at the front and rear surfaces. Note that Solcore expects the doping to be provided in base Si units (per m3). Solcore expects the doping profile information in the form of a function which returns the doping at a given depth (in m) in the junction. Positive values are n-type doping, negative values are p-type.\n\nnD = si(\"1e20cm-3\") # maximum n-type (donor) doping\nnA = si(\"1e19cm-3\") # maximum p-type (acceptor) doping\nbulk_doping = si(\"5e15cm-3\") # n type bulk doping\n\nd_bulk = 100e-6 # Si thickness, in m\n\n# rear junction (n-type)\ndef doping_profile_func(x):\n\n    L = d_bulk\n\n    doping_profile = - nA * erfc(x/300e-9) # characteristic depth of 300 nm - front p-type doping\n\n    doping_profile_rear = nD * erfc((L - x)/200e-9) # characteristic depth of 200 nm - rear n-type doping\n\n    return doping_profile + doping_profile_rear + bulk_doping\n\nTo check it looks reasonable, let’s plot this doping profile:\n\ndepth = np.linspace(0, d_bulk, int(1e5))\n\nplt.figure()\nplt.plot(depth*1e6, doping_profile_func(depth))\nplt.xlabel(r\"Depth ($\\mu$m)\")\nplt.ylabel(r\"Doping (m$^{-3}$)\")\nplt.show()\n\n\n\n\nThat didn’t help very much, because the cell is too wide compared to the region where the doping is changing! Let’s try again but splitting the plot into two parts for the front and rear surface (since nothing interesting is happening in the middle).\n\nfig, (ax1, ax2) = plt.subplots(1, 2, sharey=True, figsize=(5, 3))\n\nax1.plot(depth*1e6, doping_profile_func(depth))\nax1.set_xlim(0, 0.5)\nax1.set_ylabel(r\"Doping (m$^{-3}$)\")\nax1.set_xlabel('x (um)')\n\nax2.plot(depth*1e6, doping_profile_func(depth))\nax2.set_xlim(d_bulk*1e6 - 0.5, d_bulk*1e6)\nax2.set_xlabel('x (um)')\nplt.tight_layout()\nplt.show()\n\n\n\n\nWe will add transparent conducting oxides (TCOs) and an anti-reflection coating. Note that a real Si cell would have a more complicated layer structure (for example, for a heterojunction cell, the amorphous Si layers); we can add as many layers as we want for Solcore to consider, but will keep it simple here. In this case, these layers will be outside the junction: this means they will have optical effects but will not be included in the drift-diffusion calculation. They can be included in the junction, but this requires setting the relevant transport-related parameters.\n\nfront_materials = [Layer(80e-9, MgF2), Layer(55e-9, TCO)]\n\nback_materials = [Layer(55e-9, TCO),\n                  Layer(120e-9, MgF2)]"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/5b-Si_cell_PDD.html#defining-the-junction-and-the-cell",
    "href": "solcore-workshop-2/notebooks/5b-Si_cell_PDD.html#defining-the-junction-and-the-cell",
    "title": "Section 5b: Planar Si solar cell using PDD",
    "section": "Defining the junction and the cell",
    "text": "Defining the junction and the cell\nAnother important cell parameter, for both the depletion approximation and the drift-diffusion solvers, is the surface recombination. This is passed to Solcore as a surface recombination velocity (SRV). With the Si_pn material, the doping profile function, and the SRVs, we define the Junction. We set the kind of junction to sesame_PDD, so that Solcore knows to use the Sesame PDD solver.\n\nSi_junction = [Junction([Layer(d_bulk, Si_pn)],\n                        doping_profile=doping_profile_func, kind='sesame_PDD',\n                        sn=2, sp=1 # SRVs. Note these should be in m/s, not cm/s! sn refers to the n-type region (can be at the back or the front!), sp to the p-type.\n                        )]\n\nNow we combine the surface layers and the junction into a solar cell, with 2% shading and a silver back mirror.\n\nSi_cell = SolarCell(front_materials +\n                     Si_junction +\n                     back_materials,\n                    shading=0.02,\n                    substrate=Ag,\n                    )"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/5b-Si_cell_PDD.html#calculating-the-iv-and-qe",
    "href": "solcore-workshop-2/notebooks/5b-Si_cell_PDD.html#calculating-the-iv-and-qe",
    "title": "Section 5b: Planar Si solar cell using PDD",
    "section": "Calculating the IV and QE",
    "text": "Calculating the IV and QE\nNow we ask Solcore to solve both the light IV and QE of the cell:\n\nsolar_cell_solver(Si_cell, 'qe', options)\nsolar_cell_solver(Si_cell, 'iv', options)\n\nTreating layer(s) 2 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving QE of the solar cell...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\n\n\nNow we plot the results. Here we have multiple layers, and the junction is actually the third element in the solar cell, so we could access its properties by typing Si_cell[2] (since Python starts counting at 0). However, Solcore has a built-in way to find only the junctions (so, the electrically active) parts of the cell: Si_cell(0) will automatically find the first junction. Similarly, Si_cell(1) would give us the second junction, etc. This avoids having to manually count layers to find out which ones are the Junctions.\n\nresult_stack = np.vstack([Si_cell.reflected, [layer.layer_absorption for layer in Si_cell], Si_cell.transmitted])\n\nfig, (ax, ax2) = plt.subplots(1, 2, figsize=(10, 3.5))\nax.stackplot(wavelengths * 1e9, 100 * result_stack[::-1], linewidth=0.5, alpha=0.5,\n             labels=['Ag', 'MgF2 (rear)', 'TCO (rear)', 'Si bulk', 'TCO (front)', 'MgF2 (front)',\n                     'Reflection'])\nax.plot(wavelengths * 1e9, 100 * Si_cell(0).eqe(wavelengths), '-k', linewidth=2,\n        label='EQE')\n\nax.set_xlim(280, 1200)\nax.set_ylim(0, 100)\nax.set_xlabel(\"Wavelength (nm)\")\nax.set_ylabel(\"R / A / EQE (%)\")\nax.set_title('a) EQE and cell optics', loc='left')\nax.legend()\n\njsc = Si_cell.iv.Isc / 10\n\nax2.plot(Si_cell.iv['IV'][0], Si_cell.iv['IV'][1] / 10, '-', label='IV',\n         linewidth=2, color='k')\n\nax2.set_ylim(0, 1.03 * jsc)\nax2.set_xlim(np.min(options.voltages), np.max(options.voltages))\nax2.set_xlabel('Voltage (V)')\nax2.set_ylabel('Current density (mA/cm$^2$)')\nax2.set_title('b) IV characteristics and power output', loc='left')\n\nax3 = ax2.twinx()\nax3.plot(options.voltages, Si_cell.iv['IV'][0] * Si_cell.iv['IV'][1],\n         '-r', label='Power', linewidth=2)\nax3.set_ylabel('Power density (W m$^{-2}$)')\nax3.set_ylim(0, 1.03 * jsc * 10)\n\nax3.spines['right'].set_color('r')\nax3.yaxis.label.set_color('r')\nax3.tick_params(axis='y', colors='r')\n\nax2.set_axisbelow(True)\nax3.set_axisbelow(True)\n\nax2.text(0.02, 0.9 * jsc, r'$J_{SC}$', zorder=5)\nax2.text(0.02, 0.8 * jsc, r'$V_{OC}$')\nax2.text(0.02, 0.7 * jsc, 'FF')\nax2.text(0.02, 0.6 * jsc, r'$\\eta$')\nax2.text(0.02, 0.5 * jsc, r'$J_{MPP}$')\nax2.text(0.02, 0.4 * jsc, r'$V_{MPP}$')\n\nax2.text(0.1, 0.9 * jsc, r'= {:.2f} mA/cm$^2$'.format(jsc))\nax2.text(0.1, 0.8 * jsc, r'= {:.3f} V'.format(Si_cell.iv.Voc))\nax2.text(0.1, 0.7 * jsc, '= {:.2f} %'.format(Si_cell.iv.FF * 100))\nax2.text(0.1, 0.6 * jsc, r'= {:.2f} %'.format(Si_cell.iv.Eta * 100))\nax2.text(0.1, 0.5 * jsc, r'= {:.2f} mA/cm$^2$'.format( Si_cell.iv.Impp / 10))\nax2.text(0.1, 0.4 * jsc, r'= {:.3f} V'.format(Si_cell.iv.Vmpp))\nax2.grid(which='major', alpha=0.35)\n\nax3.grid(False)\nplt.tight_layout()\n\nplt.show()\n\n\n\n\nSince this is a planar cell (i.e. no pyramids or other textured surface to reduce reflectance and increase the path length inside the cell), we see high losses due to reflection. We also see parasitic absorption in the front and rear TCO."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/5b-Si_cell_PDD.html#auger-limited-cell",
    "href": "solcore-workshop-2/notebooks/5b-Si_cell_PDD.html#auger-limited-cell",
    "title": "Section 5b: Planar Si solar cell using PDD",
    "section": "Auger-limited cell",
    "text": "Auger-limited cell\nRecently, record-efficiency silicon cells have been optimized to such a level that Auger recombination (rather than Shockley-Read-Hall recombination) becomes the dominant recombination mechanism. SRH recombination is parameterized in the PDD solver through the minority lifetimes. Here, we will scan through different minority carrier lifetimes and look at the effect on cell parameters. Other cell parameters are assumed to stay the same.\n\nlifetime_exp = np.linspace(-4, -1.5, 6) # exponent for the lifetimes\n\nlifetimes = 10.0**lifetime_exp # lifetimes which are linearly spaced on a log scale\n\ncell_results = np.zeros(([len(lifetimes), 4])) # make an array to store the efficiency, FF, Voc, Jsc for each lifetime\n\nfor i1, lt in enumerate(lifetimes): # loop through the lifetimes\n\n    options.recalculate_absorption = True\n\n    Si_pn = material(\"Si\")(electron_mobility=si(\"1e4cm2\"), hole_mobility=si(\"1e3cm2\"),\n                           electron_minority_lifetime=lt, hole_minority_lifetime=lt)\n\n    Si_junction = [Junction([Layer(d_bulk, Si_pn)],\n                            doping_profile=doping_profile_func, kind='sesame_PDD',\n                             sn=2, sp=1)]\n\n    Si_cell = SolarCell(front_materials +\n                         Si_junction +\n                         back_materials,\n                        shading=0.02,\n                        substrate=Ag,\n                        )\n\n    solar_cell_solver(Si_cell, 'iv', options)\n\n    cell_results[i1] = np.array([100*Si_cell.iv.Eta, 100*Si_cell.iv.FF, Si_cell.iv.Voc, Si_cell.iv.Isc/10])\n\nTreating layer(s) 2 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\nTreating layer(s) 2 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\nTreating layer(s) 2 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\nTreating layer(s) 2 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\nTreating layer(s) 2 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\nTreating layer(s) 2 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\n\n\nNow we plot the results. The points are labelled with the lifetime in ms in the left-hand plot.\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 3.5))\n\nax1.plot(cell_results[:, 2], cell_results[:, 1], 'ko')\n\nfor i, lt in enumerate(lifetimes):\n    ax1.annotate(str(np.round(1000*lt,2)), (cell_results[i, 2] - 0.001, cell_results[i, 1]), ha='right')\n\nax1.set_xlabel(r'V$_{oc}$ (V)')\nax1.set_ylabel('FF (%)')\nax1.set_xlim(0.69, 0.75)\n\nax2.semilogx(lifetimes, cell_results[:, 0], 'o', color='k')\nax2.set_ylabel('Efficiency (%)')\nax3 = ax2.twinx()\nax3.plot(lifetimes, cell_results[:, 3], 'o', color='r', markerfacecolor='none')\nax3.set_ylim(33, 34)\nax3.set_ylabel(r'$J_{sc}$ (mA/cm$^2$)', color='r')\n\nax2.set_xlabel(r'$\\tau$ (s)')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\nAs the lifetimes become very long, the fill factor shoots up rapidly, while the open-circuit voltage saturates. This increase in FF is faster than would be expected with an ideality factor of 1 (for SRH recombination) in the diode equation, and occurs because recombination becomes increasingly dominated by Auger recombination (ideality factor = 2/3). Compare the plot on the left with Figure 1b in this paper, where much the same behaviour is observed with data from real record efficiency devices."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/5b-Si_cell_PDD.html#other-outputs-from-the-pdd-solver",
    "href": "solcore-workshop-2/notebooks/5b-Si_cell_PDD.html#other-outputs-from-the-pdd-solver",
    "title": "Section 5b: Planar Si solar cell using PDD",
    "section": "Other outputs from the PDD solver",
    "text": "Other outputs from the PDD solver\nBecause we used a PDD solver, there are additional outputs in additional to the ones provided by all the junction models (open-circuit voltage, short-circuit current, efficiency, fill factor, etc.). Since solving the PDD equations requires calculating the distribution of carriers in the cell depending on the light and voltage biasing, we can access this information. Here, we will plot the energy levels of the conduction and valence band, and the electron and hole quasi-Fermi levels.\nFirst, we find the index in the voltage array where the voltage is zero (i.e. short circuit), and the index where it is closest to the voltage at the maximum power point (Vmpp), which was calculated during the IV calculation earlier.\n\n# index where voltage is zero:\nSC_ind = np.argmin(np.abs(options.internal_voltages)) # index in voltage array where voltage is (closest to) zero: short circuit\nMPP_ind = np.argmin(np.abs(options.internal_voltages - Si_cell.iv.Vmpp)) # index in voltage array where voltage is closest to Vmpp.\n\nNow we get the conduction and valence band energy levels (Ec and Ev) and the electron and hole quasi-Fermi levels (Efe and Efh), at both of these voltages. The additional outpit from the PDD model are stored in each junction:\nEc_sc = Si_cell(0).pdd_output.Ec[SC_ind] Ev_sc = Si_cell(0).pdd_output.Ev[SC_ind]\nEfe_sc = Si_cell(0).pdd_output.Efe[SC_ind] Efh_sc = Si_cell(0).pdd_output.Efh[SC_ind]\nEc_mpp = Si_cell(0).pdd_output.Ec[MPP_ind] Ev_mpp = Si_cell(0).pdd_output.Ev[MPP_ind]\nEfe_mpp = Si_cell(0).pdd_output.Efe[MPP_ind] Efh_mpp = Si_cell(0).pdd_output.Efh[MPP_ind]\nNow we plot thesince the cell is very wide, let’s split the plot into two parts again, like we did for the doping, and plot the quantities we just extracted for at short circuit:\n\nfig, (ax1, ax2) = plt.subplots(1, 2, sharey=True, figsize=(5, 3))\nax1.plot(Si_cell(0).mesh*1e6, Ec_sc, label='CB', color='k')\nax1.plot(Si_cell(0).mesh*1e6, Ev_sc, label='VB', color='g')\nax1.plot(Si_cell(0).mesh*1e6, Efe_sc, label=r'$E_{f, e}$', color='r')\nax1.plot(Si_cell(0).mesh*1e6, Efh_sc, label=r'$E_{f, h}$', color='b')\n\nax1.set_xlim(0, 2)\nax1.set_xlabel('x (um)')\nax1.legend()\nax1.set_title(\"Short circuit\", loc='left')\n\nax2.plot(Si_cell(0).mesh*1e6, Ec_sc, label='CB', color='k')\nax2.plot(Si_cell(0).mesh*1e6, Ev_sc, label='VB', color='g')\nax2.plot(Si_cell(0).mesh*1e6, Efe_sc, label=r'$E_{f, e}$', color='r')\nax2.plot(Si_cell(0).mesh*1e6, Efh_sc, label=r'$E_{f, h}$', color='b')\n\nax2.set_xlim(d_bulk*1e6 - 2, d_bulk*1e6)\nax2.set_xlabel('x (um)')\nplt.tight_layout()\nplt.show()\n\n\n\n\nAnd at the maximum power point:\n\nfig, (ax1, ax2) = plt.subplots(1, 2, sharey=True, figsize=(5, 3))\n\nax1.plot(Si_cell(0).mesh*1e6, Ec_mpp, label='CB', color='k')\nax1.plot(Si_cell(0).mesh*1e6, Ev_mpp, label='VB', color='g')\nax1.plot(Si_cell(0).mesh*1e6, Efe_mpp, label=r'$E_{f, e}$', color='r')\nax1.plot(Si_cell(0).mesh*1e6, Efh_mpp, label=r'$E_{f, h}$', color='b')\nax1.set_xlim(0, 2)\nax1.set_xlabel('x (um)')\nax1.legend()\nax1.set_title(\"Maximum power point\", loc='left')\n\nax2.plot(Si_cell(0).mesh*1e6, Ec_mpp, label='CB', color='k')\nax2.plot(Si_cell(0).mesh*1e6, Ev_mpp, label='VB', color='g')\nax2.plot(Si_cell(0).mesh*1e6, Efe_mpp, label=r'$E_{f, e}$', color='r')\nax2.plot(Si_cell(0).mesh*1e6, Efh_mpp, label=r'$E_{f, h}$', color='b')\n\nax2.set_xlim(d_bulk*1e6 - 2, d_bulk*1e6)\nax2.set_xlabel('x (um)')\nplt.tight_layout()\nplt.show()\n\n\n\n\nAs expected, we see that at forward bias, the band-bending is reduced. We also see that at the rear, where the cell is very highly doped, the electron quasi-Fermi level is inside the conduction band."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/9a-GaInP_GaAs_Si_grating.html",
    "href": "solcore-workshop-2/notebooks/9a-GaInP_GaAs_Si_grating.html",
    "title": "Section 9a: Planar III-V on planar Si, with rear grating",
    "section": "",
    "text": "In this example, we will build two structures similar to those described in this paper. These are both triple-junction, two-terminal GaInP/GaAs/Si cells; one cell is planar, while the other has a diffraction grating deposited on the rear of the bottom Si cell to boost its current."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/9a-GaInP_GaAs_Si_grating.html#setting-up",
    "href": "solcore-workshop-2/notebooks/9a-GaInP_GaAs_Si_grating.html#setting-up",
    "title": "Section 9a: Planar III-V on planar Si, with rear grating",
    "section": "Setting up",
    "text": "Setting up\n\nfrom solcore import material, si\nfrom solcore.absorption_calculator import search_db, download_db\nimport os\nfrom solcore.structure import Layer\nfrom solcore.light_source import LightSource\nfrom rayflare.transfer_matrix_method import tmm_structure\nfrom rayflare.options import default_options\nfrom rayflare.structure import Interface, BulkLayer, Structure\nfrom rayflare.matrix_formalism import process_structure, calculate_RAT\nfrom solcore.constants import q\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\n\n\nAs before, we load some materials from the refractiveindex.info database. The MgF\\(_2\\) and Ta\\(_2\\)O\\(_5\\) are the same as the ARC example; the SU8 is a negative photoresist which was used in the reference paper The optical constants for silver are also loaded from a reliable literature source. Note that the exact compositions of some semiconductor alloy layers (InGaP, AlInP and AlGaAs) are not given in the paper and are thus reasonable guesses.\n\n# download_db(confirm=True) # only needs to be run once\n# commented out because this should have already been done in a previous example. Uncomment if necessary.\n\n\n%%capture\n\nMgF2_pageid = search_db(os.path.join(\"MgF2\", \"Rodriguez-de Marcos\"))[0][0];\nTa2O5_pageid = search_db(os.path.join(\"Ta2O5\", \"Rodriguez-de Marcos\"))[0][0];\nSU8_pageid = search_db(\"SU8\")[0][0];\nAg_pageid = search_db(os.path.join(\"Ag\", \"Jiang\"))[0][0];\n\nMgF2 = material(str(MgF2_pageid), nk_db=True)();\nTa2O5 = material(str(Ta2O5_pageid), nk_db=True)();\nSU8 = material(str(SU8_pageid), nk_db=True)();\nAg = material(str(Ag_pageid), nk_db=True)();\n\nwindow = material(\"AlInP\")(Al=0.52)\nGaInP = material(\"GaInP\")(In=0.5)\nAlGaAs = material(\"AlGaAs\")(Al=0.8)\nGaAs = material(\"GaAs\")()\nSi = material(\"Si\")\n\nAir = material(\"Air\")()\nAl2O3 = material(\"Al2O3P\")()\nAl = material(\"Al\")()"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/9a-GaInP_GaAs_Si_grating.html#defining-the-cell-layers",
    "href": "solcore-workshop-2/notebooks/9a-GaInP_GaAs_Si_grating.html#defining-the-cell-layers",
    "title": "Section 9a: Planar III-V on planar Si, with rear grating",
    "section": "Defining the cell layers",
    "text": "Defining the cell layers\nNow we define the layers for the III-V top junctions, and the Si wafer, grouping them together in a logical way. In this example, we will only do optical simulations, so we will not set e.g. diffusion lengths or doping levels.\n\nARC = [Layer(110e-9, MgF2), Layer(65e-9, Ta2O5)]\n\nGaInP_junction = [Layer(17e-9, window), Layer(400e-9, GaInP), Layer(100e-9, AlGaAs)]\n\ntunnel_1 = [Layer(80e-9, AlGaAs), Layer(20e-9, GaInP)]\n\nGaAs_junction = [Layer(17e-9, GaInP), Layer(1050e-9, GaAs), Layer(70e-9, AlGaAs)]\n\ntunnel_2 = [Layer(50e-9, AlGaAs), Layer(125e-9, GaAs)]\n\nSi_junction = [Layer(280e-6, Si(Nd=si(\"2e18cm-3\"), hole_diffusion_length=2e-6), role=\"emitter\")]\n\ncoh_layers = len(ARC) + len(GaInP_junction) + len(tunnel_1) + len(GaAs_junction) + len(tunnel_2)\n\nAs for Example 7, to get physically reasonable results we must treat the very thick layers in the structure incoherently. The coh_layers variable sums up how many thin layers (which must be treated coherently) must be included in the coherency_list options."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/9a-GaInP_GaAs_Si_grating.html#planar-cell",
    "href": "solcore-workshop-2/notebooks/9a-GaInP_GaAs_Si_grating.html#planar-cell",
    "title": "Section 9a: Planar III-V on planar Si, with rear grating",
    "section": "Planar cell",
    "text": "Planar cell\nNow we define the planar cell, and options for the solver:\n\ncell_planar = tmm_structure(\n    ARC + GaInP_junction + tunnel_1 + GaAs_junction + tunnel_2 + Si_junction,\n    incidence=Air, transmission=Ag,\n)\n\nn_layers = cell_planar.layer_stack.num_layers\n\ncoherency_list = [\"c\"]*coh_layers + [\"i\"]*(n_layers-coh_layers)\n\noptions = default_options()\n\nwl = np.arange(300, 1201, 10) * 1e-9\nAM15G = LightSource(source_type=\"standard\", version=\"AM1.5g\", x=wl,\n                    output_units=\"photon_flux_per_m\")\n\noptions.wavelength = wl\noptions.coherency_list = coherency_list\noptions.coherent = False\n\nRun the TMM calculation for the planar cell, and then extract the relevant layer absorptions. These are used to calculate limiting currents (100% internal quantum efficiency), which are displayed on the plot with the absorption in each layer.\n\ntmm_result = cell_planar.calculate(options=options)\n\nGaInP_A = tmm_result['A_per_layer'][:,3]\nGaAs_A = tmm_result['A_per_layer'][:,8]\nSi_A = tmm_result['A_per_layer'][:,coh_layers]\n\nJmax_GaInP = q*np.trapz(GaInP_A*AM15G.spectrum()[1], x=wl)/10\nJmax_GaAs = q*np.trapz(GaAs_A*AM15G.spectrum()[1], x=wl)/10\nJmax_Si = q*np.trapz(Si_A*AM15G.spectrum()[1], x=wl)/10\n\nR_spacer_ARC = tmm_result['R']\n\nplt.figure(figsize=(6,4))\nplt.plot(wl * 1e9, GaInP_A, \"-k\", label=\"GaInP\")\nplt.plot(wl * 1e9, GaAs_A, \"-b\", label=\"GaAs\")\nplt.plot(wl * 1e9, Si_A, \"-r\", label=\"Si\")\nplt.plot(wl * 1e9, 1 - R_spacer_ARC, '-y', label=\"1 - R\")\n\nplt.text(450, 0.55, r\"{:.1f} mA/cm$^2$\".format(Jmax_GaInP))\nplt.text(670, 0.55, r\"{:.1f} mA/cm$^2$\".format(Jmax_GaAs))\nplt.text(860, 0.55, r\"{:.1f} mA/cm$^2$\".format(Jmax_Si))\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"Absorptance\")\nplt.tight_layout()\nplt.legend(loc='upper right')\nplt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)\nplt.show()\n\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial main/Ag/Jiang.yml loaded.\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial main/Ag/Jiang.yml loaded.\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial main/MgF2/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial main/MgF2/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial main/Ta2O5/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaterial main/Ta2O5/Rodriguez-de Marcos.yml loaded."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/9a-GaInP_GaAs_Si_grating.html#cell-with-rear-grating",
    "href": "solcore-workshop-2/notebooks/9a-GaInP_GaAs_Si_grating.html#cell-with-rear-grating",
    "title": "Section 9a: Planar III-V on planar Si, with rear grating",
    "section": "Cell with rear grating",
    "text": "Cell with rear grating\nNow, for the cell with a grating on the rear, we have a multi-scale problem where we must combine the calculation of absorption in a very thick (compared to the wavelengths of light) layer of Si with the effect of a wavelength-scale (1000 nm pitch) diffraction grating. For this, we will use the Angular Redistribution Matrix Method (ARMM) which was also used in Example 8.\nThe front surface of the cell (i.e. all the layers on top of Si) are planar, and can be treated using TMM. The rear surface of the cell, which has a crossed grating consisting of silver and SU8, must be treated with RCWA to account for diffraction. The thick Si layer will be the bulk coupling layer between these two interfaces.\nFirst, we set up the rear grating surface; we must define its lattice vectors, and place the Ag rectangle in the unit cell of the grating. More details on how unit cells of different shapes can be defined for the RCWA solver can be found here.\n\nx = 1000\n\nd_vectors = ((x, 0), (0, x))\narea_fill_factor = 0.4\nhw = np.sqrt(area_fill_factor) * 500\n\nback_materials = [\n        Layer(width=si(\"250nm\"), material=SU8,\n        geometry=[{\"type\": \"rectangle\", \"mat\": Ag, \"center\": (x / 2, x / 2),\n                   \"halfwidths\": (hw, hw), \"angle\": 0}])]\n\nNow, we define the Si bulk layer, and the III-V layers which go in the front interface. Finally, we put everything together into the ARMM Structure, also giving the incidence and transmission materials.\n\nbulk_Si = BulkLayer(280e-6, Si(), name=\"Si_bulk\")\n\nIII_V_layers = ARC + GaInP_junction + tunnel_1 + GaAs_junction + tunnel_2\n\nfront_surf_planar = Interface(\"TMM\", layers=III_V_layers, name=\"III_V_front\",\n                              coherent=True)\n\nback_surf_grating = Interface(\"RCWA\", layers=back_materials, name=\"crossed_grating_back\",\n    d_vectors=d_vectors, rcwa_orders=60)\n\ncell_grating = Structure([front_surf_planar, bulk_Si, back_surf_grating],\n    incidence=Air, transmission=Ag)\n\nBecause RCWA calculations are very slow compared to TMM, it makes sense to only carry out the RCWA calculation at wavelengths where the grating has any effect. Depending on the wavelength, all the incident light may be absorbed in the III-V layers or in its first pass through the Si, so it never reaches the grating. We check this by seeing which wavelengths have even a small amount of transmission into the silver back mirror, and only doing the new calculation at these wavelengths. At shorter wavelengths, the results previously calculated using TMM can be used.\n\n%%capture\n\nwl_rcwa = wl[tmm_result['T'] &gt; 1e-4] # check where transmission fraction is bigger\n# than 1E-4\n\noptions.wavelength = wl_rcwa\noptions.project_name = \"III_V_Si_cell\"\noptions.n_theta_bins = 30\noptions.c_azimuth = 0.25\noptions.RCWA_method = \"inkstone\"\n\nprocess_structure(cell_grating, options, save_location='current')\nresults_armm = calculate_RAT(cell_grating, options, save_location='current')\nRAT = results_armm[0]\n\nINFO: Making matrix for planar surface using TMM for element 0 in structure\nINFO: RCWA calculation for element 2 in structure\nINFO: RCWA calculation for wavelength = 940.0000000000001 nm\nINFO: RCWA calculation for wavelength = 990.0 nm\nINFO: RCWA calculation for wavelength = 960.0000000000001 nm\nINFO: RCWA calculation for wavelength = 1000.0000000000001 nm\nINFO: RCWA calculation for wavelength = 1010.0000000000001 nm\nINFO: RCWA calculation for wavelength = 950.0 nm\nINFO: RCWA calculation for wavelength = 1020.0 nm\nINFO: RCWA calculation for wavelength = 1030.0 nm\nINFO: RCWA calculation for wavelength = 970.0 nm\nINFO: RCWA calculation for wavelength = 980.0000000000001 nm\nINFO: RCWA calculation for wavelength = 1040.0 nm\nINFO: RCWA calculation for wavelength = 1050.0 nm\nINFO: RCWA calculation for wavelength = 1060.0 nm\nINFO: RCWA calculation for wavelength = 1070.0000000000002 nm\nINFO: RCWA calculation for wavelength = 1080.0 nm\nINFO: RCWA calculation for wavelength = 1090.0000000000002 nm\nINFO: RCWA calculation for wavelength = 1100.0 nm\nINFO: RCWA calculation for wavelength = 1110.0000000000002 nm\nINFO: RCWA calculation for wavelength = 1120.0 nm\nINFO: RCWA calculation for wavelength = 1130.0 nm\nINFO: RCWA calculation for wavelength = 1140.0 nm\nINFO: RCWA calculation for wavelength = 1150.0 nm\nINFO: RCWA calculation for wavelength = 1160.0000000000002 nm\nINFO: RCWA calculation for wavelength = 1170.0 nm\nINFO: RCWA calculation for wavelength = 1180.0000000000002 nm\nINFO: RCWA calculation for wavelength = 1190.0 nm\nINFO: RCWA calculation for wavelength = 1200.0000000000002 nm\nINFO: After iteration 1: maximum power fraction remaining = 0.6314182213481858\nINFO: After iteration 2: maximum power fraction remaining = 0.4894786243853588\nINFO: After iteration 3: maximum power fraction remaining = 0.37936409941254223\nINFO: After iteration 4: maximum power fraction remaining = 0.2923832297564508\nINFO: After iteration 5: maximum power fraction remaining = 0.22442973939149682\nINFO: After iteration 6: maximum power fraction remaining = 0.17246216581794507\nINFO: After iteration 7: maximum power fraction remaining = 0.13285217091457766\nINFO: After iteration 8: maximum power fraction remaining = 0.10234781936869419\nINFO: After iteration 9: maximum power fraction remaining = 0.07886820065679137\nINFO: After iteration 10: maximum power fraction remaining = 0.06079469712756424\nINFO: After iteration 11: maximum power fraction remaining = 0.046878313361311943\nINFO: After iteration 12: maximum power fraction remaining = 0.03615861519954806\nINFO: After iteration 13: maximum power fraction remaining = 0.027897938239687625\nINFO: After iteration 14: maximum power fraction remaining = 0.021529761625524578\nINFO: After iteration 15: maximum power fraction remaining = 0.01661882076260673\nINFO: After iteration 16: maximum power fraction remaining = 0.01283049650651593\nINFO: After iteration 17: maximum power fraction remaining = 0.009907380417311016\n\n\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.WARNING: The RCWA solver will not be available because an S4 installation has not been found.\n\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\nWARNING: The RCWA solver will not be available because an S4 installation has not been found."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/9a-GaInP_GaAs_Si_grating.html#comparison-of-planar-and-grating-cell",
    "href": "solcore-workshop-2/notebooks/9a-GaInP_GaAs_Si_grating.html#comparison-of-planar-and-grating-cell",
    "title": "Section 9a: Planar III-V on planar Si, with rear grating",
    "section": "Comparison of planar and grating cell",
    "text": "Comparison of planar and grating cell\nWe extract the relevant absorption per layer, and use it to calculate the new limiting current for the Si junction. The plot compares the absorption in the Si with and without the grating.\n\nSi_A_total = np.zeros(len(wl))\nSi_A_total[tmm_result['T'] &gt; 1e-4] = RAT['A_bulk'][0]\nSi_A_total[tmm_result['T'] &lt;= 1e-4] = Si_A[tmm_result['T'] &lt;= 1e-4]\n\nJmax_Si_grating = q*np.trapz(Si_A_total*AM15G.spectrum()[1], x=wl)/10\n\nplt.figure(figsize=(6,3))\nplt.plot(wl * 1e9, GaInP_A, \"-k\", label=\"GaInP\")\nplt.plot(wl * 1e9, GaAs_A, \"-b\", label=\"GaAs\")\nplt.plot(wl * 1e9, Si_A, \"--r\", label=\"Si (planar)\")\nplt.plot(wl * 1e9, Si_A_total, '-r', label=\"Si (with grating)\")\nplt.text(420, 0.55, r\"{:.1f} mA/cm$^2$\".format(Jmax_GaInP))\nplt.text(670, 0.50, r\"{:.1f} mA/cm$^2$\".format(Jmax_GaAs))\nplt.text(860, 0.45, r\"{:.1f} mA/cm$^2$\".format(Jmax_Si_grating))\nplt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"Absorptance\")\n\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/9a-GaInP_GaAs_Si_grating.html#questions",
    "href": "solcore-workshop-2/notebooks/9a-GaInP_GaAs_Si_grating.html#questions",
    "title": "Section 9a: Planar III-V on planar Si, with rear grating",
    "section": "Questions",
    "text": "Questions\n\nWhy does the grating only affect the absorption in Si at long wavelengths?\nWhat is the reason for using the angular redistribution matrix method, rather than defining an RCWA-only structure (rcwa_structure)?"
  },
  {
    "objectID": "solcore-workshop-2/workshop2023.html",
    "href": "solcore-workshop-2/workshop2023.html",
    "title": "Solcore Workshop 2023 (UNSW)",
    "section": "",
    "text": "If you are familiar with Python/have a working installation (Python &gt;= 3.7, &lt;= 3.11), you only need to install the following packages:\npip install solcore rayflare seaborn jupyter\nFor those who need to set up Python and a programming environment from scratch, there a detailed instructions for:\n\nWindows: text instructions and accompanying video instructions.\nMacOS: text instructions and accompanying video instructions.\n\nIf you have issues, please come to one of the pre-workshop installation help sessions (see below)! We can also try to help during the main workshop, but to ensure it runs as smoothly as possible, it’s best if everyone already has a working installation of Python and the required packages."
  },
  {
    "objectID": "solcore-workshop-2/workshop2023.html#installation-instructions",
    "href": "solcore-workshop-2/workshop2023.html#installation-instructions",
    "title": "Solcore Workshop 2023 (UNSW)",
    "section": "",
    "text": "If you are familiar with Python/have a working installation (Python &gt;= 3.7, &lt;= 3.11), you only need to install the following packages:\npip install solcore rayflare seaborn jupyter\nFor those who need to set up Python and a programming environment from scratch, there a detailed instructions for:\n\nWindows: text instructions and accompanying video instructions.\nMacOS: text instructions and accompanying video instructions.\n\nIf you have issues, please come to one of the pre-workshop installation help sessions (see below)! We can also try to help during the main workshop, but to ensure it runs as smoothly as possible, it’s best if everyone already has a working installation of Python and the required packages."
  },
  {
    "objectID": "solcore-workshop-2/workshop2023.html#times-locations",
    "href": "solcore-workshop-2/workshop2023.html#times-locations",
    "title": "Solcore Workshop 2023 (UNSW)",
    "section": "Times & locations",
    "text": "Times & locations\nPre-workshop help sessions (OPTIONAL):\n\nMonday 20 November, 3-4 pm\nTuesday 21 November, 3-4 pm\n\nIn TETB meeting room Gnd 22 (Ground Floor, across from the main entrance). If the installation described above works for you, no need to attend either of these!\nWorkshop:\nWednesday - Friday, 22 - 24 November\n1 - 5 pm. Click here for full schedule (subject to change).\nLocation: F10 June Griffith M10 (K-F10-M10), UNSW Sydney\n(June Griffith building is next to the Law faculty, diagonally across from Tyree on the University Mall. When you enter the building from the University Mall (coming from Tyree), you need to go up the set of stairs by the main entrance, go through the fire doors, and turn left. If you are coming from the other side, the room is directly on your right when you enter)."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/7a-optimization.html",
    "href": "solar-cell-simulation/notebooks/7a-optimization.html",
    "title": "Example 7a: Simple optimization",
    "section": "",
    "text": "In a few of the previous examples, we have used anti-reflection coatings. In Example 5a, we introduced a nanophotonic grating for light trapping. But how do you find out the right thickness for the anti-reflection coating layer(s), or the right dimensions for a light-trapping grating? This is where optimization comes in. Here, we will look at a very simple ‘brute-force’ optimization for a single or double-layer ARC, and a more complicated framework for running optimizations using Solcore/RayFlare and a differential evolution algorithm in Example 7b.\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\nfrom solcore import material, si\nfrom solcore.solar_cell import Layer\nfrom solcore.light_source import LightSource\nfrom solcore.absorption_calculator import search_db\n\nfrom rayflare.transfer_matrix_method import tmm_structure\nfrom rayflare.options import default_options\nimport seaborn as sns"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/7a-optimization.html#setting-up",
    "href": "solar-cell-simulation/notebooks/7a-optimization.html#setting-up",
    "title": "Example 7a: Simple optimization",
    "section": "Setting up",
    "text": "Setting up\n\nopts = default_options()\n\nwavelengths = np.linspace(300, 1200, 800)*1e-9\n\nAM15g = LightSource(source_type=\"standard\", version=\"AM1.5g\", output_units=\"photon_flux_per_m\")\nspectrum = AM15g.spectrum(wavelengths)[1]\nnormalised_spectrum = spectrum/np.max(spectrum)\n\nopts.wavelengths = wavelengths\nopts.coherent = False\nopts.coherency_list = ['c', 'i']\n\nSi = material(\"Si\")()\nSiN = material(\"Si3N4\")()\nAg = material(\"Ag\")()\nAir = material(\"Air\")()"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/7a-optimization.html#single-layer-arc",
    "href": "solar-cell-simulation/notebooks/7a-optimization.html#single-layer-arc",
    "title": "Example 7a: Simple optimization",
    "section": "Single-layer ARC",
    "text": "Single-layer ARC\nHere, we will calculate the behaviour of a single-layer SiN anti-reflection coating on Si while changing the ARC thickness between 0 and 200 nm. We will consider two values to optimize: the mean reflectance mean_R, and the reflectance weighted by the photon flux in an AM1.5G spectrum (weighted_R). The reason for considering the second value is that it is more useful to suppress reflection at wavelengths where there are more photons which could be absorbed.\nWe will loop through the different ARC thicknesses in d_range, build the structure for each case, and then calculate the reflectance. We then save the mean reflected and weighted mean reflectance in the corresponding arrays. We also plot the reflectance for each 15th loop (this is just so the plot does not get too crowded).\n\nd_range = np.linspace(0, 200, 200)\n\nmean_R = np.empty_like(d_range)\nweighted_R = np.empty_like(d_range)\n\ncols = sns.cubehelix_palette(np.ceil(len(d_range)/15))\n\nplt.figure()\njcol = 0\n\nfor i1, d in enumerate(d_range):\n\n    struct = tmm_structure([Layer(si(d, 'nm'), SiN), Layer(si('300um'), Si)], incidence=Air, transmission=Ag)\n    RAT = struct.calculate(opts)\n\n    if i1 % 15 == 0:\n        plt.plot(wavelengths*1e9, RAT['R'], label=str(np.round(d, 0)), color=cols[jcol])\n        jcol += 1\n\n    mean_R[i1] = np.mean(RAT['R'])\n    weighted_R[i1] = np.mean(RAT['R']*normalised_spectrum)\n\nplt.legend()\nplt.show()\n\n\n\n\nWe now find at which index mean_R and weighted_R are minimised using np.argmin, and use this to print the ARC thickness at which this occurs (rounded to 1 decimal place).\n\nprint('Minimum mean reflection occurs at d = ' + str(np.round(d_range[np.argmin(mean_R)], 1)) + ' nm')\nprint('Minimum weighted reflection occurs at d = ' + str(np.round(d_range[np.argmin(weighted_R)], 1)) + ' nm')\n\nMinimum mean reflection occurs at d = 70.4 nm\nMinimum weighted reflection occurs at d = 75.4 nm\n\n\nWe see that the values of \\(d\\) for the two different ways of optimizing are very similar, but not exactly the same, as we would expect. The minimum in both cases occurs around 70 nm. We can also plot the evolution of the mean and weighted \\(R\\) with ARC thickness \\(d\\):\n\nplt.figure()\nplt.plot(d_range, mean_R, label='Mean reflection')\nplt.plot(d_range[np.argmin(mean_R)], np.min(mean_R), 'ok')\nplt.plot(d_range, weighted_R, label='Weighted mean reflection')\nplt.plot(d_range[np.argmin(weighted_R)], np.min(weighted_R), 'ok')\nplt.xlabel('d$_{SiN}$')\nplt.ylabel('(Weighted) mean reflection 300-1200 nm')\nplt.show()\n\n\n\n\nAnd the actual reflectance with wavelength for the two different optimizations:\n\nstruct = tmm_structure([Layer(si(d_range[np.argmin(mean_R)], 'nm'), SiN), Layer(si('300um'), Si)], incidence=Air, transmission=Ag)\nRAT_1 = struct.calculate(opts)\n\nstruct = tmm_structure([Layer(si(d_range[np.argmin(weighted_R)], 'nm'), SiN), Layer(si('300um'), Si)], incidence=Air, transmission=Ag)\nRAT_2 = struct.calculate(opts)\n\nplt.figure()\nplt.plot(wavelengths*1e9, RAT_1['R'], label='Mean R minimum')\nplt.plot(wavelengths*1e9, RAT_2['R'], label='Weighted R minimum')\nplt.legend()\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"R\")\nplt.show()\n\n\n\n\nWe see that the two reflectance curves are very similar."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/7a-optimization.html#double-layer-arc",
    "href": "solar-cell-simulation/notebooks/7a-optimization.html#double-layer-arc",
    "title": "Example 7a: Simple optimization",
    "section": "Double-layer ARC",
    "text": "Double-layer ARC\nWe will now consider a similar situation, but for a double-layer MgF\\(_2\\)/Ta\\(_2\\)O\\(_5\\) ARC on GaAs. We search for materials in the refractiveindex.info database (see Example 2a), and use only the part of the solar spectrum relevant for absorption in GaAs (in this case, there is no benefit to reducing absorption above the GaAs bandgap around 900 nm). We will only consider the weighted mean \\(R\\) in this case.\n\npageid_MgF2 = search_db(os.path.join(\"MgF2\", \"Rodriguez-de Marcos\"))[0][0]\npageid_Ta2O5 = search_db(os.path.join(\"Ta2O5\", \"Rodriguez-de Marcos\"))[0][0]\n\nGaAs = material(\"GaAs\")()\nMgF2 = material(str(pageid_MgF2), nk_db=True)()\nTa2O5 = material(str(pageid_Ta2O5), nk_db=True)()\n\nMgF2_thickness = np.linspace(50, 100, 20)\nTa2O5_thickness = np.linspace(30, 80, 20)\n\nweighted_R_matrix = np.zeros((len(MgF2_thickness), len(Ta2O5_thickness)))\n\nwavelengths_GaAs = wavelengths[wavelengths &lt; 900e-9]\nnormalised_spectrum_GaAs = normalised_spectrum[wavelengths &lt; 900e-9]\n\nopts.coherent = True\nopts.wavelengths = wavelengths_GaAs\n\nWe now have two thicknesses to loop through; otherwise, the procedure is similar to the single-layer ARC example.\n\nfor i1, d_MgF2 in enumerate(MgF2_thickness):\n    for j1, d_Ta2O5 in enumerate(Ta2O5_thickness):\n        struct = tmm_structure([Layer(si(d_MgF2, 'nm'), MgF2), Layer(si(d_Ta2O5, 'nm'), Ta2O5),\n                                Layer(si('20um'), GaAs)],\n                               incidence=Air, transmission=Ag)\n        RAT = struct.calculate(opts)\n\n        weighted_R_matrix[i1, j1] = np.mean(RAT['R'] * normalised_spectrum_GaAs)\n\n# find the row and column indices of the minimum weighted R value\nri, ci = np.unravel_index(weighted_R_matrix.argmin(), weighted_R_matrix.shape)\n\nWe plot the total absorption (\\(1-R\\)) in the structure with the optimized ARC, and print the thicknesses of MgF\\(_2\\) and Ta\\(_2\\)O\\(_5\\) at which this occurs:\n\nplt.figure()\nplt.imshow(1-weighted_R_matrix, extent=[min(Ta2O5_thickness), max(Ta2O5_thickness),\n                                        min(MgF2_thickness), max(MgF2_thickness)],\n           origin='lower', aspect='equal')\nplt.plot(Ta2O5_thickness[ci], MgF2_thickness[ri], 'xk')\nplt.colorbar()\nplt.xlabel(\"Ta$_2$O$_5$ thickness (nm)\")\nplt.ylabel(\"MgF$_2$ thickness (nm)\")\nplt.show()\n\nprint(\"Minimum reflection occurs at MgF2 / Ta2O5 thicknesses of %.1f / %.1f nm \"\n     % (MgF2_thickness[ri], Ta2O5_thickness[ci]))\n\n\n\n\nMinimum reflection occurs at MgF2 / Ta2O5 thicknesses of 73.7 / 53.7 nm \n\n\nFor these two examples, where we are only trying to optimize one and two parameters respectively across a relatively small range, using a method (TMM) which executes quickly, brute force searching is possible. However, as we introduce more parameters, a wider parameter space, and slower simulation methods, it may no longer be computationally tractable."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1a-simple_cell.html",
    "href": "solar-cell-simulation/notebooks/1a-simple_cell.html",
    "title": "Example 1a: Simple Si solar cell",
    "section": "",
    "text": "In this first set of examples, we will look at simple planar solar cells (Si and GaAs).\nIn this script, we will look at the difference between Beer-Lambert absorption calculations, using the Fresnel equations for front-surface reflection, and using the transfer-matrix model.\nFirst, lets import some very commonly-used Python packages:\nimport numpy as np\nimport matplotlib.pyplot as plt\nNumpy is a Python library which adds supports for multi-dimensional data arrays and matrices, so it is very useful for storing and handling data. You will probably use it in every Solcore script you write. Here, it is imported under the alias ‘np’, which you will see used below. matplotlib is used for making plots, and is imported under the alias ‘plt’. Both the ‘np’ and ‘plt’ aliases are extremely commonly used in Python programming.\nNow, let’s import some things from Solcore (which will be explained as we use them):\nfrom solcore import material, si\nfrom solcore.solar_cell import SolarCell, Layer, Junction\nfrom solcore.solar_cell_solver import solar_cell_solver\nfrom solcore.interpolate import interp1d"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1a-simple_cell.html#defining-materials",
    "href": "solar-cell-simulation/notebooks/1a-simple_cell.html#defining-materials",
    "title": "Example 1a: Simple Si solar cell",
    "section": "Defining materials",
    "text": "Defining materials\nTo define our solar cell, we first want to define some materials. Then we want to organise those materials into Layers, organise those layers into a Junction, and then finally define a SolarCell with that Junction.\nFirst, let’s define a Si material. Silicon, along with many other semiconductors, dielectrics, and metals common in solar cells, is included in Solcore’s database:\n\nSi = material(\"Si\")\nGaAs = material(\"GaAs\")\n\nThis creates an instance of the Si and GaAs materials. However, to use this in a solar cell we need to do specify some more information, such as the doping level. The ‘si’ function comes in handy here to convert all quantities to based units e.g. m, m^(-3)…\n\nSi_n = Si(Nd=si(\"1e21cm-3\"), hole_diffusion_length=si(\"10um\"), relative_permittivity=11.7)\nSi_p = Si(Na=si(\"1e16cm-3\"), electron_diffusion_length=si(\"400um\"), relative_permittivity=11.7)"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1a-simple_cell.html#defining-layers",
    "href": "solar-cell-simulation/notebooks/1a-simple_cell.html#defining-layers",
    "title": "Example 1a: Simple Si solar cell",
    "section": "Defining layers",
    "text": "Defining layers\nNow we define the emitter and base layers we will have in the solar cell; we specify their thickness, the material they are made of and the role they play within the cell (emitter or base)\n\nemitter_layer = Layer(width=si(\"600nm\"), material=Si_n, role='emitter')\nbase_layer = Layer(width=si(\"200um\"), material=Si_p, role='base')\n\ncreate the p-n junction using the layers defined above. We set kind=“DA” to tell Solcore to use the Depletion Approximation in the calculation (we will discuss the different electrical solver options more later on):\n\nSi_junction = Junction([emitter_layer, base_layer], kind=\"DA\")"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1a-simple_cell.html#setting-user-options",
    "href": "solar-cell-simulation/notebooks/1a-simple_cell.html#setting-user-options",
    "title": "Example 1a: Simple Si solar cell",
    "section": "Setting user options",
    "text": "Setting user options\nWavelengths we want to use in the calculations; wavelengths between 300 and 1200 nm, at 200 evenly spaced intervals:\n\nwavelengths = si(np.linspace(300, 1200, 200), \"nm\")\n\nNote that here and above in defining the layers and materials we have used the “si()” function: you can use this to automatically convert quantities in other units to base SI units (e.g. nanometres to metres).\nNow we specify some options for running the calculation. Initially we want to use the Beer-Lambert absorption law to calculate the optics of the cell (“BL”). We set the wavelengths we want to use, and we set “recalculate_absorption” to True so that further down in the script when we try different optics methods, Solcore knows we want to re-calculate the optics of the cell. We specify the options in a Python format called a dictionary:\n\noptions = {\n    \"recalculate_absorption\": True,\n    \"optics_method\": \"BL\",\n    \"wavelength\": wavelengths\n           }"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1a-simple_cell.html#running-cell-simulations",
    "href": "solar-cell-simulation/notebooks/1a-simple_cell.html#running-cell-simulations",
    "title": "Example 1a: Simple Si solar cell",
    "section": "Running cell simulations",
    "text": "Running cell simulations\nDefine the solar cell; in this case it is very simple and we just have a single junction:\n\nsolar_cell = SolarCell([Si_junction])\n\nNow use solar_cell_solver to calculate the QE of the cell; we can ask solar_cell_solver to calculate ‘qe’, ‘optics’ or ‘iv’.\n\nsolar_cell_solver(solar_cell, 'qe', options)\n\nPLOT 1: plotting the QE in the Si junction, as well as the fraction of light absorbed in the junction and reflected:\n\nplt.figure()\nplt.plot(wavelengths*1e9, 100*solar_cell[0].eqe(wavelengths), 'k-', label=\"EQE\")\nplt.plot(wavelengths*1e9, 100*solar_cell[0].layer_absorption, label='Absorptance (A)')\nplt.plot(wavelengths*1e9, 100*solar_cell.reflected, label='Reflectance (R)')\nplt.legend()\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"QE/Absorptance (%)\")\nplt.title(\"(1) QE of Si cell - Beer-Lambert absorption\")\nplt.show()"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1a-simple_cell.html#adding-front-surface-reflection-fresnel",
    "href": "solar-cell-simulation/notebooks/1a-simple_cell.html#adding-front-surface-reflection-fresnel",
    "title": "Example 1a: Simple Si solar cell",
    "section": "Adding front-surface reflection: Fresnel",
    "text": "Adding front-surface reflection: Fresnel\nNow, to make this calculation a bit more realistic, there are a few things we could do. We could load some measured front surface reflectance from a file, or we could calculate the reflectance. To calculate the reflectance, there are many approaches we could take; we are going to explore two of them here.\nIf we assume the silicon is infinitely thick (or at least much thicker than the wavelengths we care about) then the reflectance will approach the reflectivity of a simple air/Si interface. We can calculate what this is using the Fresnel equation for reflectivity.\n\ndef calculate_R_Fresnel(incidence_n, transmission_n, wl):\n    # return a function that gives the value of R (at normal incidence) at the input wavelengths\n\n    Rs = np.abs((incidence_n - transmission_n)/(incidence_n + transmission_n))**2\n\n    return interp1d(wl, Rs)\n\ncomplex reflective index at our wavelengths for the transmission medium (Si). The incidence_n = 1 (air).\n\ntrns_n = Si_n.n(wavelengths) + 1j*Si_n.k(wavelengths)\nreflectivity_fn = calculate_R_Fresnel(1, trns_n, wavelengths)\n\nwe define the solar cell again, with the same layers but now supplying the function for the externally-calculated reflectivity, and calculate the optics (reflection, absorption, transmission):\n\nsolar_cell_fresnel = SolarCell([Si_junction], reflectivity=reflectivity_fn)\n\nsolar_cell_solver(solar_cell_fresnel, 'optics', options)"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1a-simple_cell.html#adding-front-surface-reflection-tmm",
    "href": "solar-cell-simulation/notebooks/1a-simple_cell.html#adding-front-surface-reflection-tmm",
    "title": "Example 1a: Simple Si solar cell",
    "section": "Adding front surface reflection: TMM",
    "text": "Adding front surface reflection: TMM\nFinally, we do the same again but now instead of supplying the external reflectivity we ask set the optics_method to “TMM” (Transfer Matrix Method), to correctly calculate reflection at the front surface:\n\nSi_junction = Junction([emitter_layer, base_layer], kind=\"DA\")\n\nsolar_cell_TMM = SolarCell([Si_junction])\n\nSet some more options:\n\noptions[\"optics_method\"] = \"TMM\"\nvoltages = np.linspace(0, 1.1, 100)\noptions[\"light_iv\"] = True\noptions[\"mpp\"] = True\noptions[\"voltages\"] = voltages\n\nwe calculate the QE and the IV (we set the light_iv option to True; if we don’t do this, Solcore just calculates the dark IV). We also ask Solcore to find the maximum power point (mpp) so we can get the efficiency.\n\nsolar_cell_solver(solar_cell_TMM, 'iv', options)\nsolar_cell_solver(solar_cell_TMM, 'qe', options)\n\nPLOT 2: here we plot the reflection, transmission, and absorption calculated with the Fresnel equation defined above, and with the TMM solver in Solcore, showing that for this simple situation (no anti-reflection coating, thick Si junction) they are exactly equivalent.\n\nplt.figure()\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.reflected, color='firebrick', label = \"R (TMM)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_fresnel.reflected, '--', color='orangered', label = \"R (Fresnel)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.absorbed, color='dimgrey', label = \"A (TMM)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_fresnel.absorbed, '--', color='lightgrey', label = \"A (Fresnel)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.transmitted, color='blue', label = \"T (TMM)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_fresnel.transmitted, '--', color='dodgerblue', label = \"T (Fresnel)\")\nplt.ylim(0, 100)\nplt.legend()\nplt.title(\"(2) Optics of Si cell - Fresnel/TMM\")\nplt.show()\n\nPLOT 3: As above for the TMM calculation, plotting the EQE as well, which will be slightly lower than the absorption because not all the carriers are collected. Comparing to plot (1), we can see we now have lower absorption due to the inclusion of front surface reflection.\n\nplt.figure()\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM[0].eqe(wavelengths), 'k-', label=\"EQE\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM[0].layer_absorption, label='A')\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.reflected, label=\"R\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.transmitted, label=\"T\")\nplt.title(\"(3) QE of Si cell (no ARC) - TMM\")\nplt.legend()\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"QE/Absorptance (%)\")\nplt.ylim(0, 100)\nplt.show()"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1a-simple_cell.html#adding-an-arc",
    "href": "solar-cell-simulation/notebooks/1a-simple_cell.html#adding-an-arc",
    "title": "Example 1a: Simple Si solar cell",
    "section": "Adding an ARC",
    "text": "Adding an ARC\nNow we will try adding a simple anti-reflection coating (ARC), a single layer of silicon nitride (Si3N4):\n\nSiN = material(\"Si3N4\")()\n\nSi_junction = Junction([emitter_layer, base_layer], kind=\"DA\")\n\nsolar_cell_TMM_ARC = SolarCell([Layer(width=si(75, \"nm\"), material=SiN), Si_junction])\n\nsolar_cell_solver(solar_cell_TMM_ARC, 'qe', options)\nsolar_cell_solver(solar_cell_TMM_ARC, 'iv', options)\n\nPLOT 4: Absorption, EQE, reflection and transmission for the cell with a simple one-layer ARC. We see the reflection is significantly reduced from the previous plot leading to higher absorption/EQE.\n\nplt.figure()\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM_ARC[1].eqe(wavelengths), 'k-', label=\"EQE\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM_ARC[1].layer_absorption, label='A')\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM_ARC.reflected, label=\"R\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM_ARC.transmitted, label=\"T\")\nplt.legend()\nplt.title(\"(4) QE of Si cell (ARC) - TMM\")\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"QE/Absorptance (%)\")\nplt.ylim(0, 100)\nplt.show()\n\nPLOT 5: Compare the IV curves of the cells with and without an ARC. The efficiency is also shown on the plot. Note that because we didn’t specify a light source, Solcore will assume we want to use AM1.5G; in later examples we will set the light source used for IV simulations explicitly.\n\nplt.figure()\nplt.plot(voltages, -solar_cell_TMM[0].iv(voltages)/10, label=\"No ARC\")\nplt.plot(voltages, -solar_cell_TMM_ARC[1].iv(voltages)/10, label=\"75 nm SiN\")\nplt.text(0.5, solar_cell_TMM.iv[\"Isc\"]/10, str(round(solar_cell_TMM.iv[\"Eta\"]*100, 1)) + ' %')\nplt.text(0.5, solar_cell_TMM_ARC.iv[\"Isc\"]/10, str(round(solar_cell_TMM_ARC.iv[\"Eta\"]*100, 1)) + ' %')\nplt.ylim(0, 38)\nplt.xlim(0, 0.8)\nplt.legend()\nplt.xlabel(\"V (V)\")\nplt.ylabel(r\"J (mA/cm$^2$)\")\nplt.title(\"(5) IV curve of Si cell with and without ARC\")\nplt.show()"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1a-simple_cell.html#conclusions",
    "href": "solar-cell-simulation/notebooks/1a-simple_cell.html#conclusions",
    "title": "Example 1a: Simple Si solar cell",
    "section": "Conclusions",
    "text": "Conclusions\nWe see that the cell with an ARC has a significantly higher Jsc, and a slightly higher Voc, than the bare Si cell. In reality, most Si cells have a textured surface rather than a planar surface with an ARC; this will be discussed later in the course.\nOverall, some things we can take away from the examples in this script: - The Beer-Lambert law is a very simple way to calculate absorption in a cell, but won’t take into account important effects such as front-surface reflection or the effects of anti-reflection coatings - Using the transfer-matrix method (TMM) we can account for front surface reflection and interference effects which make e.g. ARCs effective. In the simple situation of a thick cell without any front surface layers, it is equivalent to simply calculation the reflection with the Fresnel equations and assuming Beer-Lambert absorption in the cell. - Adding a simple, one-layer ARC can significantly reduce front-surface reflection for a single-junction cell, leading to improved short-circuit current."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/7b-optimization.html",
    "href": "solar-cell-simulation/notebooks/7b-optimization.html",
    "title": "Example 7b: More advanced optimization",
    "section": "",
    "text": "This example looks at optimizing a four-junction Ga\\(_{0.5}\\)In\\(_{0.5}\\)P/GaAs/SiGeSn/Ge cell, using a differential evolution (DE) algorithm.\nFirst, using a purely optical TMM simulation to calculate the photogenerated current in each sub-cell, we get an estimate of the overall thickness of each material we will need to achieve current-matching. The thing to optimize is then the current of the current-limiting cell in the structure; in other words we want to maximize the lowest sub-cell current, to achieve current-matching with the highest possible current. Since the differential evolution algorithm as implemented does a minimization, we are actually minimizing the negative of this value.\nOnce we have good initial values for the total layer thicknesses, we use full electrical simulation to determine the n and p type layer thicknesses to calculate a maximum possible efficiency for the 4J device.\nTo use yabox (used by Solcore’s the optimization module for the DE) we need to define a class which sets up the problem and has an ‘evaluate’ function, which will actually calculate the value we are trying to minimize for a set of parameters.\nNote: There is an issue in some versions of PyCharm with this example due to the parallel execution. To avoid this, make sure you “Run” the example as opposed to using “Run in Python Console”.\nimport numpy as np\nimport os\n\nfrom solcore import material, si\n\nimport matplotlib.pyplot as plt\n\nfrom solcore.optics.tmm import OptiStack\nfrom solcore.optics.tmm import calculate_rat\n\nfrom solcore.optimization import PDE, DE\nfrom solcore.light_source import LightSource\n\nfrom solcore.solar_cell import SolarCell\nfrom solcore.structure import Junction, Layer\nfrom solcore.solar_cell_solver import solar_cell_solver\nfrom solcore.constants import q, kb\nfrom solcore.absorption_calculator import search_db\nFirst add SiGeSn optical constants to the database:\nfrom solcore.material_system import create_new_material\n\ncreate_new_material(\"SiGeSn\", os.path.join(\"data\", \"SiGeSn_n.txt\"),\n                    os.path.join(\"data\", \"SiGeSn_k.txt\"), os.path.join(\"data\", \"SiGeSn_params.txt\"))\n# Note: comment out these lines after the material has been added to avoid being asked\n# each time if you want to overwrite it.\nn_iters_optics = 50\nn_iters_device = 20"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/7b-optimization.html#optical-simulation",
    "href": "solar-cell-simulation/notebooks/7b-optimization.html#optical-simulation",
    "title": "Example 7b: More advanced optimization",
    "section": "Optical simulation",
    "text": "Optical simulation\nThis example has a more complicated structure than the previous examples, and is based around the use of Python classes. For both steps of the optimization outlined above, we define a class which contains methods which generate all the information to run the simulations, and an evaluate method which actually returns the quantity to be optimized.\nThe methods defined in the calc_min_Jsc class below, which sets up the optical part of the optimization, are:\n\n__init__: This always has to be defined for a class, as it initializes a member of the class when we call the class as calc_min_Jsc(). In this case, it sets up variables we need in the simulation, such as the wavelength, light source, and optical constants of the materials.\ncalculate: This actually runs the core of the calculation by calling calculate_rat from Solcore to run a TMM calculation; the argument of the function is a list of the layer thicknesses. It returns the absorption in each layer of the cell, the transmission, and reflection.\nevaluate: This function will be used to evaluate the figure of merit for the optimization. It calls calculate and then calculates the maximum possible current in each sub-cell using the photon flux. It then finds the limiting (minimum) \\(J_{sc}\\) out of the four sub-cells, and returns the negative of this value. The way the DE algorithm is implemented means it will always try to minimize what the evaluate function returns, so although we want to maximize the limiting \\(J_{sc}\\), we must implement this as minimizing its negative.\nplot: Takes the results from calculate and plots them to visualize our results.\n\n\nclass calc_min_Jsc():\n\n    def __init__(self):\n        # Initialize an instance of the class; set some information which will be used in each iteration of the calculation:\n        # materials, wavelengths, the light source\n\n        wl = np.linspace(300, 1900, 800)\n\n        # Materials\n        SiGeSn = material('SiGeSn')()\n\n        GaAs = material('GaAs')()\n        InGaP = material('GaInP')(In=0.5)\n        Ge = material('Ge')()\n\n        Ta2O5_index = search_db(os.path.join(\"Ta2O5\", \"Rodriguez\"))[0][0]\n\n        # We make these attributes of 'self' so they can be accessed by the class object\n        # We are also creating lists of wavelengths and corresponding n and k data from\n        # the Solcore materials - the reason for this is that there is currently an issue with using the Solcore\n        # material class in parallel computations. Thus the information for the n and k data is saved here as a list\n        # rather than a material object (see the documentation of OptiStack for the different acceptable formats\n        # to pass optical constants for an OptiStack)\n\n        self.wl = wl\n        self.SiGeSn = [self.wl, SiGeSn.n(self.wl*1e-9), SiGeSn.k(self.wl*1e-9)]\n        self.Ge = [self.wl, Ge.n(self.wl*1e-9), Ge.k(self.wl*1e-9)]\n\n        self.InGaP = [self.wl, InGaP.n(self.wl*1e-9), InGaP.k(self.wl*1e-9)]\n        self.GaAs = [self.wl, GaAs.n(self.wl*1e-9), GaAs.k(self.wl*1e-9)]\n        self.MgF2 = [self.wl, material('MgF2')().n(self.wl*1e-9), material('MgF2')().k(self.wl*1e-9)]\n\n        self.Ta2O5 = [self.wl, material(str(Ta2O5_index),\n                                        nk_db=True)().n(self.wl*1e-9), material(str(Ta2O5_index),\n                                                                                nk_db=True)().k(self.wl*1e-9)]\n\n        # Assuming an AM1.5G spectrum\n        self.spectr = LightSource(source_type='standard', version='AM1.5g', x=self.wl,\n                           output_units='photon_flux_per_nm', concentration=1).spectrum(self.wl)[1]\n\n    def calculate(self, x):\n        # x[0] = MgF2 thickness (anti-reflection coating)\n        # x[1] = Ta2O5 thickness (anti-reflection coating)\n        # x[2] = InGaP (top junction) thickness\n        # x[3] = GaAs (second junction) thickness\n        # x[4] = SiGeSn (third junction) thickness\n\n        # Keep the thickness of the bottom cell constant; from a purely optical point of view, this should be infinitely thick,\n        # so there is no point in optimizing the thickness\n\n        SC = [[x[0]] + self.MgF2, [x[1]] + self.Ta2O5, [x[2]] + self.InGaP, [x[3]] + self.GaAs, [x[4]] + self.SiGeSn,\n              [300e3] + self.Ge]\n\n        # create the OptiStack\n        full_stack = OptiStack(SC, no_back_reflection=False)\n\n        # calculate reflection, transmission, and absorption in each layer. We are specifying that the last layer,\n        # a very thick Ge substrate, should be treated incoherently, otherwise we would see very narrow, unphysical oscillations\n        # in the R/A/T spectra.\n\n        c_list = ['c']*len(SC)\n        c_list[-1] = \"i\"\n\n        RAT = calculate_rat(full_stack, self.wl, no_back_reflection=False, coherent=False,\n                            coherency_list=c_list)\n\n        # extract absorption per layer\n        A_InGaP = RAT['A_per_layer'][3]\n        A_GaAs = RAT['A_per_layer'][4]\n        A_SiGeSn = RAT['A_per_layer'][5]\n        A_Ge = RAT['A_per_layer'][6]\n\n        return A_InGaP, A_GaAs, A_SiGeSn, A_Ge, RAT['T'], RAT['R']\n\n    def evaluate(self, x):\n\n        A_InGaP, A_GaAs, A_SiGeSn, A_Ge, _, _ =  self.calculate(x)\n\n        # Calculate photo-generated currents using the AM1.5 G spectrum for each layer -- this is the current with 100%\n        # internal quantum efficiency (i.e. every absorbed photon generates an electron-hole pair which is collected).\n        Jsc_InGaP = 0.1 * q * np.trapz(A_InGaP * self.spectr, self.wl)\n        Jsc_GaAs = 0.1 * q * np.trapz(A_GaAs * self.spectr, self.wl)\n        Jsc_SiGeSn = 0.1 * q * np.trapz(A_SiGeSn * self.spectr, self.wl)\n        Jsc_Ge = 0.1 * q * np.trapz(A_Ge * self.spectr, self.wl)\n\n        # Find the limiting current by checking which junction has the lowest current. Then take the negative since\n        # we need to minimize (not maximize)\n        limiting_Jsc = -min([Jsc_InGaP, Jsc_GaAs, Jsc_SiGeSn, Jsc_Ge])\n\n        return limiting_Jsc\n\n    def plot(self, x):\n\n        A_InGaP, A_GaAs, A_SiGeSn, A_Ge, T, R = self.calculate(x)\n\n        plt.figure()\n        plt.plot(self.wl, A_InGaP, label='InGaP')\n        plt.plot(self.wl, A_GaAs, label='A_GaAs')\n        plt.plot(self.wl, A_SiGeSn, label='SiGeSn')\n        plt.plot(self.wl, A_Ge, label = 'Ge')\n        plt.plot(self.wl, T, label='T')\n        plt.plot(self.wl, R, label='R')\n        plt.legend()\n        plt.xlabel('Wavelength (nm)')\n        plt.ylabel('R/A/T')\n        plt.show()\n\nNow that we have defined a class containing the relevant information and methods for the optimization process, we need to make an instance of that class for the DE algorithm to use.\n\nDE_class = calc_min_Jsc()\n\nWe also set the upper and lower bounds on thickness for each layer:\n\nMgF2 (ARC layer 1)\nTa2O5 (ARC layer 2)\nGaInP (top junction)\nGaAs (2nd junction)\nSiGeSn (3rd junction)\n\nWe will not optimize the thickness of the bottom Ge cell at this stage; from a purely optical point of view, this should be infinitely thick to maximize absorption, which is of course not the case for a device. We will set the thickness of the Ge at 300 \\(\\mu\\)m.\n\nbounds_optics = [[10,150], [10,105], [200, 1000], [500, 10000], [500, 10000]]\n\nNow, we pass the function which will be minimized to the DE (parallel differential evolution) solver. The bounds argument sets upper and lower bounds for each parameter. PDE_obj contains all the information to run the DE but does not actually start the calculation (like the calc_min_Jsc class defined above, DE is a class and not a function.\nTo actually run the DE, we use the .solve() method of the DE object class:\n\nPDE_obj = DE(DE_class.evaluate, bounds=bounds_optics, maxiters=n_iters_optics)\n\nres = PDE_obj.solve()\n\nNote: Due to issues with parallel computations depending on your operating system etc., we used the DE class here. There is also a parallelized version of this class, called PDE, which is already implemented above. If you are running this example on your own computer, you can run the example in parallel by simple changing DE to PDE.\nPDE_obj.solve() returns a list of five items: - res[0] is a list of the parameters which gave the overall minimized value at the end of the process - res[1] is that minimized value - res[2] is the evolution of the best population (the best population from each iteration) - res[3] is the evolution of the minimized value, i.e. the best fitness in iteration - res[4] is the evolution of the mean fitness over the iterations\nLet’s plot the absorption in each layer using the optimized thicknesses:\n\n# best population:\nbest_pop = res[0]\n\nprint('parameters for best result:', best_pop, '\\n', 'optimized Jsc value (mA/cm2):', -res[1])\n\n# plot the result at these best parameters\nDE_class.plot(best_pop)\n\nparameters for best result: [ 119.25428258   83.4922207   550.47007392 2040.13817627 1420.56539299] \n optimized Jsc value (mA/cm2): 14.031909365709433\n\n\n\n\n\nAnd the evolution of the best and mean fitness with each iteration of the DE algorithm:\n\nbest_fitn_evo = res[3]\nmean_fitn_evo = res[4]\n\n# plot evolution of the fitness of the best population per iteration\n\nplt.figure()\nplt.plot(-best_fitn_evo, '-k', label='Best fitness')\nplt.plot(-mean_fitn_evo, '-r', label='Mean fitness')\nplt.xlabel('Iteration')\nplt.ylabel('Fitness')\nplt.legend()\nplt.show()\n\n\n\n\nWe see that the fitness of the best population ‘jumps’ every few iterations as a new best population is found, while the mean fitness increases slowly as the whole population gradually improves. Ideally, we would like to see the fitness converging, but it may be necessary to increase the number of iterations to achieve this."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/7b-optimization.html#device-optimization",
    "href": "solar-cell-simulation/notebooks/7b-optimization.html#device-optimization",
    "title": "Example 7b: More advanced optimization",
    "section": "Device optimization",
    "text": "Device optimization\nAs discussed above, we approach this optimization in two phases: a faster optical simulation to get approximate total thicknesses for each junction, and then a device optimization. We take a very similar approach and define a class to contain the information and methods needed for the device optimization:\n\nclass optimize_device():\n\n    def __init__(self, ARC_thickness):\n        self.ARC = ARC_thickness\n        self.position = [1e-10] * 10 + [5e-8] # 0.1 nm spacing in all layers except the Ge\n\n\n    def make_cell(self, x):\n\n        #x[0]: total InGaP thickness\n        #x[1]: total InGaAs thickness\n        #x[2]: total SiGeSn thickness\n        #x[3]: total Ge thickness\n\n        #x[4]: InGaP n thickness\n        #x[5]: InGaAs n thickness\n        #x[6]: SiGeSn n thickness\n        #x[7]: Ge n thickness\n\n        e_charge = si('1eV')\n\n        # materials\n        Ta2O5_index = search_db(os.path.join(\"Ta2O5\", \"Rodriguez\"))[0][0]\n        SiGeSn = material('SiGeSn')\n\n        GaAs = material('GaAs')\n        InGaP = material('GaInP')\n        Ge = material('Ge')\n        MgF2 = material('MgF2')()\n        Ta2O5 = material(str(Ta2O5_index), nk_db=True)()\n        AlInP = material(\"AlInP\")\n\n        window_material = AlInP(Al=0.52)\n\n        GaInP_mobility_h = 0.03  #\n        GaInP_lifetime_h = 1e-8\n        GaInP_D_h = GaInP_mobility_h * kb * 300 / e_charge\n        GaInP_L_h = np.sqrt(GaInP_D_h * GaInP_lifetime_h)\n        GaInP_mobility_e = 0.015\n        GaInP_lifetime_e = 1e-8\n        GaInP_D_e = GaInP_mobility_e * kb * 300 / e_charge\n        GaInP_L_e = np.sqrt(GaInP_D_e * GaInP_lifetime_e)\n\n        top_cell_n_material = InGaP(In=0.5, Nd=si(\"2e18cm-3\"), hole_diffusion_length=GaInP_L_h,\n                                    hole_mobility=GaInP_mobility_h)\n        top_cell_p_material = InGaP(In=0.5, Na=si(\"2e17cm-3\"), electron_diffusion_length=GaInP_L_e,\n                                    electron_mobility=GaInP_mobility_e)\n\n        # MID CELL  - GaAs\n\n        GaAs_mobility_h = 0.85  #\n        GaAs_lifetime_h = 1e-8\n        GaAs_D_h = GaAs_mobility_h * kb * 300 / e_charge\n        GaAs_L_h = np.sqrt(GaAs_D_h * GaAs_lifetime_h)\n        GaAs_mobility_e = 0.08\n        GaAs_lifetime_e = 1e-8\n        GaAs_D_e = GaAs_mobility_e * kb * 300 / e_charge\n        GaAs_L_e = np.sqrt(GaAs_D_e * GaAs_lifetime_e)\n\n        mid_cell_n_material = GaAs(Nd=si(\"1e18cm-3\"), hole_diffusion_length=GaAs_L_h,\n                                   hole_mobility=GaAs_mobility_h)\n        mid_cell_p_material = GaAs(Na=si(\"1e17cm-3\"), electron_diffusion_length=GaAs_L_e,\n                                   electron_mobility=GaAs_mobility_e)\n\n\n        SiGeSn.band_gap = si('0.77eV') # from PL measurement\n        SiGeSn_L_h = si('0.35um')\n        SiGeSn_L_e = si('5um')\n        SiGeSn_lifetime_e = 1e-6\n        SiGeSn_lifetime_h = 1e-6\n        SiGeSn_mobility_h = SiGeSn_L_h ** 2 * e_charge / (SiGeSn_lifetime_h * kb * 300)\n        SiGeSn_mobility_e = SiGeSn_L_e ** 2 * e_charge / (SiGeSn_lifetime_e * kb * 300)\n\n        pen_cell_n_material = SiGeSn(Nd=si(\"1e18cm-3\"), hole_diffusion_length=SiGeSn_L_h,\n                                     relative_permittivity=16, hole_mobility=SiGeSn_mobility_h)\n        pen_cell_p_material = SiGeSn(Na=si(\"1e17cm-3\"), electron_diffusion_length=SiGeSn_L_e,\n                                     relative_permittivity=16, electron_mobility=SiGeSn_mobility_e)\n\n        Ge_lifetime_h = 1e-6\n        Ge_L_h = si('500nm')\n        Ge_mobility_h = Ge_L_h ** 2 * e_charge / (Ge_lifetime_h * kb * 300)\n        Ge_mobility_e = 0.18\n        Ge_lifetime_e = 1e-6\n        Ge_D_e = Ge_mobility_e * kb * 300 / e_charge\n        Ge_L_e = np.sqrt(Ge_D_e * Ge_lifetime_e)\n\n        bot_cell_n_material = Ge(Nd=si(\"2e18cm-3\"), hole_diffusion_length=Ge_L_h,\n                                 hole_mobility=Ge_mobility_h)\n        bot_cell_p_material = Ge(Na=si(\"1e17cm-3\"), electron_diffusion_length=Ge_L_e,\n                                 electron_mobility=Ge_mobility_e)\n\n\n\n        solar_cell = SolarCell([\n            Layer(si(self.ARC[0], 'nm'), material=MgF2), Layer(si(self.ARC[1], 'nm'), material=Ta2O5),\n            Junction([Layer(si(25, 'nm'), material=window_material, role='window'),\n                      Layer(si(x[4], 'nm'), material=top_cell_n_material, role='emitter'),\n                      Layer(si(x[0]-x[4], 'nm'), material=top_cell_p_material, role='base'),\n                      ], sn=1, sp=1, kind='DA'),\n            Junction([Layer(si(x[5], 'nm'), material=mid_cell_n_material, role='emitter'),\n                      Layer(si(x[1]-x[5], 'nm'), material=mid_cell_p_material, role='base'),\n                      ], sn=1, sp=1, kind='DA'),\n            Junction([Layer(si(x[6], 'nm'), material=pen_cell_n_material, role='emitter'),\n                      Layer(si(x[2]-x[6], 'nm'), material=pen_cell_p_material, role='base'),\n                      ], sn=1, sp=1, kind='DA'),\n            Junction([Layer(si(x[7], 'nm'), material=bot_cell_n_material, role='emitter'),\n                      Layer(si(x[3]-x[7], 'nm'), material=bot_cell_p_material, role='base'),\n                      ], sn=1, sp=1, kind='DA'),\n        ], shading=0.0, substrate=bot_cell_n_material)\n\n        return solar_cell\n\n    def calculate(self, x):\n\n        light_source = LightSource(source_type='standard', version='AM1.5g')\n\n        wl = np.linspace(300, 1850, 500) * 1e-9\n\n        solar_cell = self.make_cell(x)\n\n        V = np.linspace(0, 3.5, 300)\n        solar_cell_solver(solar_cell, 'iv',\n                          user_options={'voltages': V, 'light_iv': True, 'wavelength': wl, 'mpp': True,\n                                        'light_source': light_source,\n                                        'optics_method': 'TMM', 'BL_correction': True,\n                                        'position': self.position})\n\n        return wl, solar_cell\n\n    def evaluate(self, x):\n\n        _, solar_cell = self.calculate(x)\n        efficiency = solar_cell.iv[\"Eta\"]\n\n        return -efficiency\n\n    def plot(self, x):\n\n        wl, solar_cell = self.calculate(x)\n\n        V = solar_cell.iv['IV'][0]\n\n        efficiency = solar_cell.iv[\"Eta\"]\n        pmax = solar_cell.iv[\"Pmpp\"]\n        ff = solar_cell.iv[\"FF\"]\n        voc = solar_cell.iv[\"Voc\"]\n        isc = solar_cell.iv[\"Isc\"]\n\n        plt.figure()\n\n        plt.plot(V, solar_cell.iv['IV'][1] / 10, 'k', linewidth=3, label='Total')\n        plt.plot(V, -solar_cell[2].iv(V) / 10, 'b', label='GaInP')\n        plt.plot(V, -solar_cell[3].iv(V) / 10, 'g', label='GaAs')\n        plt.plot(V, -solar_cell[4].iv(V) / 10, 'r', label='SiGeSn')\n        plt.plot(V, -solar_cell[5].iv(V) / 10, 'y', label='Ge')\n        plt.text(2, 10, '$\\eta = $' + str(round(efficiency * 100, 1)) + '%')\n        plt.text(2, 8,'Pmax='+str(round(pmax,1))+'W/m$^2$')\n        plt.text(2, 9, 'FF = ' + str(round(ff * 100, 1)) + '%')\n        plt.text(2,7,'Voc='+str(round(voc,1))+'V')\n        plt.text(2,6, 'Jsc='+str(round(0.1*isc,1))+'mA/cm$^2$')\n\n        plt.legend()\n        plt.ylim(0, 18)\n        plt.xlim(0, 3.5)\n        plt.ylabel('Current (mA/cm$^2$)')\n        plt.xlabel('Voltage (V)')\n\n        plt.show()\n\n        solar_cell_solver(solar_cell, 'qe',\n                         user_options={'wavelength': wl, 'optics_method': 'TMM', 'BL_correction': True, 'position': self.position})\n\n        plt.figure()\n        plt.plot(wl * 1e9, solar_cell[2].eqe(wl) * 100, 'b', label='InGaP')\n        plt.plot(wl * 1e9, solar_cell[3].eqe(wl) * 100, 'g', label='InGaAs')\n        plt.plot(wl * 1e9, solar_cell[4].eqe(wl) * 100, 'r', label='SiGeSn')\n        plt.plot(wl * 1e9, solar_cell[5].eqe(wl) * 100, 'y', label='Ge')\n        plt.plot(wl * 1e9, solar_cell.absorbed * 100, 'k--', label='Absorption')\n        # plt.plot(wl * 1e9, solar_cell[5].eqe(wl)*100, 'y', label='Ge')\n\n        plt.legend(loc='upper right')\n        plt.xlim(290, 1850)\n        plt.ylim(0, 100)\n        plt.ylabel('EQE (%)')\n        plt.xlabel('Wavelength (nm)')\n        plt.show()\n\nNow that the layer thicknesses have been optimized from an optical point of view, we want to design the device (or at least a simplified version, by calculating a more realistic EQE. Obviously additional parameters like the doping of the layers could be varied too. The list of parameters x will be:\n\nx[0]: total InGaP thickness\nx[1]: total InGaAs thickness\nx[2]: total SiGeSn thickness\nx[3]: total Ge thickness\nx[4]: InGaP emitter thickness\nx[5]: InGaAs emitter thickness\nx[6]: SiGeSn emitter thickness\nx[7]: Ge emitter thickness\n\nWe will keep the ARC thicknesses fixed at the exact values obtained in the optical simulation. For the other layers, we generate upper and lower bounds: total layer thickness between 75% and 125% of values fitted in TMM calculation. For Ge, we set the starting value at 200 \\(\\mu\\)m.\n\nstarting_params = np.append(best_pop[2:], [200000])\n\nlower = 0.75*starting_params\nupper = 1.25*starting_params\n\n# upper and lower bounds for the n-type (highly doped) layers\nlower_ntype = [20, 20, 20, 20]\n\nupper_ntype = [200, 300, 300, 500]\n\nall_lower = np.append(lower, lower_ntype)\n\nall_upper = np.append(upper, upper_ntype)\n\n# full list of bounds\nall_bounds = np.stack((all_lower, all_upper)).T\n\nSimilar to the optical simulation above, we now create an object of this class (setting the ARC thickness when we create the class), then create an object of the DE class, and call the .solve method.\n\n# DE calculation for the electrical simulation\n\nDE_class_DA = optimize_device(best_pop[0:2])\n\n# default population size = 5*number of params\nPDE_obj_DA = DE(DE_class_DA.evaluate, bounds=all_bounds, maxiters=n_iters_device)\n\n# solve, i.e. minimize the problem\nres_DA = PDE_obj_DA.solve()\n\nWe plot the QE and IV for the best population:\n\nbest_pop_DA = res_DA[0]\n\nprint('parameters for best result:', best_pop_DA, 'optimized efficiency (%)', res_DA[1]*100)\n\n# plot the result at these best parameters\nDE_class_DA.plot(best_pop_DA)\n\nparameters for best result: [5.64211912e+02 1.67613064e+03 1.08983977e+03 1.99726177e+05\n 1.71208031e+02 1.18811297e+02 4.59410919e+01 1.07605130e+02] optimized efficiency (%) -35.688813260065366\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\n1 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n475 main    Ta2O5   Rodriguez-de_Marcos main/Ta2O5/Rodriguez-de Marcos.yml  1   1   0.0294938   1.51429 212\nSolving optics of the solar cell...\nTreating layer(s) 10 incoherently\nCalculating RAT...\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/Ta2O5/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/Ta2O5/Rodriguez-de Marcos.yml loaded.\nCalculating absorption profile...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\nSolving optics of the solar cell...\nAlready calculated reflection, transmission and absorption profile - not recalculating. Set recalculate_absorption to True in the options if you want absorption to be calculated again.\nSolving QE of the solar cell...\n\n\n\n\n\n/Users/phoebe/Documents/develop/solcore5/solcore/analytic_solar_cells/depletion_approximation.py:617: RuntimeWarning: invalid value encountered in true_divide\n  iqe =  j_sc / current_absorbed\n\n\n\n\n\n\nbest_pop_evo = res_DA[2]\nbest_fitn_evo = res_DA[3]\nmean_fitn_evo = res_DA[4]\nfinal_fitness = res_DA[1]\n\n# plot evolution of the fitness of the best population per iteration\n\nplt.figure()\nplt.plot(-best_fitn_evo, '-k', label='Best fitness')\nplt.plot(-mean_fitn_evo, '-r', label='Mean fitness')\nplt.xlabel('Iteration')\nplt.ylabel('Fitness')\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/7b-optimization.html#comparison",
    "href": "solar-cell-simulation/notebooks/7b-optimization.html#comparison",
    "title": "Example 7b: More advanced optimization",
    "section": "Comparison",
    "text": "Comparison\nCompare the total layer thicknesses obtained from the optical and electrical simulations:\n\nprint(\"Comparison of thicknesses from optical/electrical optimization:\")\nprint('GaInP total thickness: %.1f/%.1f nm' % (best_pop[2], best_pop_DA[0]))\nprint('GaAs total thickness: %.1f/%.1f nm' % (best_pop[3], best_pop_DA[1]))\nprint('SiGeSn total thickness: %.1f/%.1f nm' % (best_pop[4], best_pop_DA[2]))\n\nComparison of thicknesses from optical/electrical optimization:\nGaInP total thickness: 550.5/564.2 nm\nGaAs total thickness: 2040.1/1676.1 nm\nSiGeSn total thickness: 1420.6/1089.8 nm\n\n\nNOTE: You may have an issue running the parallel version of this example (change DE to PDE) if you are using Windows. To get around this, you need to use the if __name__ == \"__main__\" construction. The issue arises because the multiprocessing module uses a different process on Windows than on UNIX systems which will throw errors if this construction is not used. You need to put everything apart from the module imports at the top of the script and the class definitions inside a function called main, and execute this with:\n\n# if __name__ == '__main__':\n#     main()"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1c-simple_cell.html",
    "href": "solar-cell-simulation/notebooks/1c-simple_cell.html",
    "title": "Example 1c: Electrical models",
    "section": "",
    "text": "In the first two examples, we mostly focused on different optical models and how they can be applied to an Si cell. Here we will look at different electrical models, roughly in increasing order of how ‘realistic’ they are expected to be:\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom solcore.solar_cell import SolarCell, Layer, Junction\nfrom solcore.solar_cell_solver import solar_cell_solver\nfrom solcore.absorption_calculator import OptiStack, calculate_rat\n\nfrom solcore import material, si\n\nfrom solcore.interpolate import interp1d"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1c-simple_cell.html#setting-up",
    "href": "solar-cell-simulation/notebooks/1c-simple_cell.html#setting-up",
    "title": "Example 1c: Electrical models",
    "section": "Setting up",
    "text": "Setting up\nDefine some materials:\n\nGaAs = material(\"GaAs\")()\nAl2O3 = material(\"Al2O3\")()\nAg = material(\"Ag\")()\n\nwavelengths = si(np.linspace(300, 950, 200), \"nm\")\n\nWe are going to do an optical calculation first to get absorption for a GaAs layer; we will use this as an estimate for the EQE as input for the two-diode model.\n\nOS = OptiStack([Layer(si(\"3um\"), GaAs)], substrate=Ag)\n\nCalculate reflection/absorption/transmission (note that we have to give the wavelength to this function in nm rather than m!)\n\nRAT = calculate_rat(OS, wavelength=wavelengths*1e9, no_back_reflection=False)\n\nCreate a function which interpolates the absorption - note that we pass a function which returns the absorption when given a wavelength to the Junction, rather than a table of values!\n\neqe_func = interp1d(wavelengths, RAT[\"A\"])"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1c-simple_cell.html#d-and-db-junctions",
    "href": "solar-cell-simulation/notebooks/1c-simple_cell.html#d-and-db-junctions",
    "title": "Example 1c: Electrical models",
    "section": "2D and DB junctions",
    "text": "2D and DB junctions\nDefine the 2D junction with reasonable parameters for GaAs. The units of j01 and j01 are A/m^2. The units for the resistances are (Ohm m)^2. We use the standard ideality factors (1 and 2 respectively) for the two diodes:\n\ntwod_junction = Junction(kind='2D', n1=1, n2=2, j01=3e-17, j02=1e-7,\n                         R_series=6e-4, R_shunt=5e4, eqe=eqe_func)\n\nDefine two instances of a detailed-balance type junction. In both cases, there will be a sharp absorption onset at the bandgap (1.42 eV for GaAs). By specifying A, we set the fraction of light above the bandgap that is absorbed (A = 1 means 100% absorption above the gap).\n\ndb_junction_A1 = Junction(kind='DB', Eg=1.42, A=1, R_shunt=1e4, n=1)\ndb_junction = Junction(kind='DB', Eg=1.42, A=0.8, R_shunt=1e4, n=1)\n\nV = np.linspace(0, 1.5, 200)\n\nSet some options and define solar cells based on these junctions:\n\nopts = {'voltages': V, 'light_iv': True, 'wavelength': wavelengths, 'mpp': True}\n\nsolar_cell_db_A1 = SolarCell([db_junction_A1])\nsolar_cell_db = SolarCell([db_junction])\nsolar_cell_2d = SolarCell([twod_junction])\n\nCalculate and plot the IV curves:\n\nsolar_cell_solver(solar_cell_db_A1, 'iv', user_options=opts)\nsolar_cell_solver(solar_cell_db, 'iv', user_options=opts)\nsolar_cell_solver(solar_cell_2d, 'iv', user_options=opts)\n\nSolving optics of the solar cell...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\nSolving optics of the solar cell...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\nSolving optics of the solar cell...\nWarning: A junction of kind \"2D\" found. Junction ignored in the optics calculation!\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\n\n\nPLOT 1: IV curves for the DB and 2D models.\n\nplt.figure()\nplt.plot(*solar_cell_db_A1.iv[\"IV\"], label='Detailed balance (Eg = 1.44 eV, A = 1)')\nplt.plot(*solar_cell_db.iv[\"IV\"], label='Detailed balance (Eg = 1.44 eV, A = 0.8)')\nplt.plot(*solar_cell_2d.iv[\"IV\"], '--', label='Two-diode')\nplt.xlim(0, 1.5)\nplt.ylim(0, 500)\nplt.xlabel(\"V (V)\")\nplt.ylabel(\"J (A/m$^2$)\")\nplt.legend()\nplt.title('(1) IV curves calculated through detailed balance and two-diode models')\nplt.show()\n\n\n\n\nAs we expect, the two DB solar cells have a very similar shape, but the A = 1 case has a higher Jsc. The two-diode model has a lower current, which makes sense as it’s EQE is specified based on a more realistic absorption calculation which includes front-surface reflection and an absorption edge which is not infinitely sharp at the bandgap, as is assumed by the detailed balance model."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1c-simple_cell.html#da-and-pdd-junctions",
    "href": "solar-cell-simulation/notebooks/1c-simple_cell.html#da-and-pdd-junctions",
    "title": "Example 1c: Electrical models",
    "section": "DA and PDD junctions",
    "text": "DA and PDD junctions\nNow let’s consider the two slightly more complex models, which will actually take into account the absorption profile of light in the cell and the distribution of charge carriers; the depletion approximation and the Poisson drift-diffusion solver.\nNote: for the PDD example to work, the PDD solver must be installed correctly; see the Solcore documentation for more information.\n\nT = 293 # ambient temperature\n\nwindow = material('AlGaAs')(T=T, Na=si(\"5e18cm-3\"), Al=0.8)\np_GaAs = material('GaAs')(T=T, Na=si(\"1e18cm-3\"), electron_diffusion_length=si(\"400nm\"))\nn_GaAs = material('GaAs')(T=T, Nd=si(\"8e16cm-3\"), hole_diffusion_length=si(\"8um\"))\nbsf = material('GaAs')(T=T, Nd=si(\"2e18cm-3\"))\n\nSC_layers = [Layer(width=si('150nm'), material=p_GaAs, role=\"Emitter\"),\n                   Layer(width=si('2850nm'), material=n_GaAs, role=\"Base\"),\n                   Layer(width=si('200nm'), material=bsf, role=\"BSF\")]\n\nsn and sp are the surface recombination velocities (in m/sec). sn is the SRV for the n-doped junction, sp for the p-doped junction.\n\n# Depletion approximation:\nsolar_cell_da = SolarCell(\n    [Layer(width=si(\"90nm\"), material=Al2O3), Layer(width=si('20nm'),\n                                                    material=window, role=\"Window\"),\n     Junction(SC_layers, sn=5e4, sp=5e4, kind='DA')],\n    R_series=0, substrate=Ag\n)\n\n\n# Drift-diffusion solver:\nsolar_cell_pdd = SolarCell(\n    [Layer(width=si(\"90nm\"), material=Al2O3), Layer(width=si('20nm'),\n                                                    material=window, role=\"Window\"),\n     Junction(SC_layers, sn=5e4, sp=5e4, kind='PDD')],\n    R_series=0, substrate=Ag\n)\n\nIn both cases, we set the series resistance to 0. Other loss factors, such as shading, are also assumed to be zero by default.\n\nopts[\"optics_method\"] = \"TMM\" # Use the transfer-matrix method to calculate the cell's optics\nopts[\"position\"] = 1e-10 # This is the spacing used when calculating the depth-dependent absorption (0.1 nm)\nopts[\"no_back_reflection\"] = False\n\nsolar_cell_solver(solar_cell_da, \"iv\", user_options=opts);\nsolar_cell_solver(solar_cell_da, \"qe\", user_options=opts);\n\nsolar_cell_solver(solar_cell_pdd, \"iv\", user_options=opts);\nsolar_cell_solver(solar_cell_pdd, \"qe\", user_options=opts);\n\nPLOT 2: IV curves for the DA and PDD models\n\nplt.figure()\nplt.plot(*solar_cell_da.iv[\"IV\"], label=\"Depletion approximation\")\nplt.plot(*solar_cell_pdd.iv[\"IV\"], '--', label=\"Poisson Drift Diffusion\")\nplt.xlim(0, 1.2)\nplt.ylim(0, 330)\nplt.legend()\nplt.xlabel(\"V (V)\")\nplt.ylabel(\"J (A/m$^2$)\")\nplt.title('(2) IV curves from depletion approximation and drift-diffusion models')\nplt.show()\n\n\n\n\n\n\n\nPLOT 3: EQE and absorption calculated for the PDD and DA models.\n\nplt.figure()\nplt.plot(wavelengths*1e9, 100*solar_cell_da[2].eqe(wavelengths), 'k-', label=\"EQE (DA)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_pdd[2].eqe(wavelengths), 'k--', label=\"EQE (PDD)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_da[2].layer_absorption, 'r-', label=\"A (DA)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_pdd[2].layer_absorption, 'b--', label=\"A (PDD)\")\nplt.legend()\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"EQE/A (%)\")\nplt.title('(3) EQE and absorption from depletion approximation and drift-diffusion models')\nplt.show()"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/4a-textured_Si_cell.html",
    "href": "solar-cell-simulation/notebooks/4a-textured_Si_cell.html",
    "title": "Example 4a: Textured Si cell",
    "section": "",
    "text": "In this example, we will introduce RayFlare, which is a package which is closely interlinked with Solcore and extends its optical capabilities. One of the features it has is a ray-tracer, which is useful when modelling e.g. Si solar cells with textured surfaces. We will compare the result with PVLighthouse’s wafer ray tracer.\nFor more information on how ray-tracing works, see RayFlare’s documentation.\nimport numpy as np\nimport os\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfrom rayflare.ray_tracing import rt_structure\nfrom rayflare.textures import regular_pyramids, planar_surface\nfrom rayflare.options import default_options\nfrom rayflare.utilities import make_absorption_function\n\nfrom solcore.absorption_calculator import search_db\nfrom solcore import material, si\nfrom solcore.solar_cell import SolarCell, Layer, Junction\nfrom solcore.solar_cell_solver import solar_cell_solver\nfrom solcore.solar_cell_solver import default_options as defaults_solcore"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/4a-textured_Si_cell.html#setting-up",
    "href": "solar-cell-simulation/notebooks/4a-textured_Si_cell.html#setting-up",
    "title": "Example 4a: Textured Si cell",
    "section": "Setting up",
    "text": "Setting up\nFirst, setting up Solcore materials. We use a specific set of Si optical constants from this paper. These are included in the refractiveindex.info database, so we take them from there. This is the same data we used for the PVLighthouse calculation which we are going to compare to.\n\nAir = material('Air')()\nSi_Green = search_db(os.path.join(\"Si\", \"Green-2008\"))[0][0]\nSi_RT = material(str(Si_Green), nk_db=True)()\n\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\n1 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n687 main    Si  Green-2008  main/Si/Green-2008.yml  1   1   0.25    1.45    121\n\n\nThe calc variable is a switch: if True, run the calculation; if False, load the result of the previous calculation. Will need to run at least once to generate the results!\nWe use this ‘switch’ to avoid re-running the whole ray-tracing calculation (which can be time-consuming) each time we want to look at the results.\n\ncalc = True\n\nSetting options:\n\nwl = np.linspace(300, 1201, 50) * 1e-9\noptions = default_options()\noptions.wavelengths = wl\n\n# setting up some colours for plotting\npal = sns.color_palette(\"husl\", 4)\n\nnx and ny are the number of point to scan across in the x & y directions in the unit cell. Decrease this to speed up the calculation (but increase noise in results). We also set the total number of rays traced, and depth spacing for the absorption profile calculation.\n\nnxy = 25\noptions.nx = nxy\noptions.ny = nxy\noptions.n_rays = 4 * nxy ** 2 # Number of rays to be traced at each wavelength:\noptions.depth_spacing = si('50nm') # depth spacing for the absorption profile\noptions.parallel = True  # this is the default - if you do not want the code to run in parallel, change to False\n\nLoad the result of the PVLighthouse calculation for comparison:\n\nPVlighthouse = np.loadtxt(os.path.join(\"data\", \"RAT_data_300um_2um_55.csv\"), delimiter=',', skiprows=1)\n\nDefine surface for the ray-tracing: a planar surface, and a surface with regular pyramids.\n\nflat_surf = planar_surface(size=2) # pyramid size in microns\ntriangle_surf = regular_pyramids(55, upright=False, size=2)\n\nSet up the ray-tracing structure: this is a list of textures of length n, and then a list of materials of length n-1. So far a single layer, we define a front surface and a back surface (n = 2), and specify the material in between those two surfaces (n-1 = 1). We also specify the width of each material, and the incidence medium (above the first interface) and the transmission medium (below the last interface.\n\nrtstr = rt_structure(textures=[triangle_surf, flat_surf],\n                    materials = [Si_RT],\n                    widths=[si('300um')], incidence=Air, transmission=Air)"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/4a-textured_Si_cell.html#running-ray-tracing-calculation",
    "href": "solar-cell-simulation/notebooks/4a-textured_Si_cell.html#running-ray-tracing-calculation",
    "title": "Example 4a: Textured Si cell",
    "section": "Running ray-tracing calculation",
    "text": "Running ray-tracing calculation\nRun the calculation, if calc was set to True, otherwise load the results. We save the reflection, transmission, and total absorption in an array called result_RAT and the absorption profile as profile_rt.\n\nif calc:\n    # This executes if calc = True (set at the top of the script): actually run the ray-tracing:\n    result = rtstr.calculate_profile(options)\n\n    # Put the results (Reflection, front surface reflection, transmission, absorption in the Si) in an array:\n    result_RAT = np.vstack((options['wavelengths']*1e9,\n                        result['R'], result['R0'], result['T'], result['A_per_layer'][:,0])).T\n\n    # absorption profile:\n    profile_rt = result['profile']\n\n    # save the results:\n    np.savetxt(os.path.join(\"results\", \"rayflare_fullrt_300um_2umpyramids_300_1200nm.txt\"), result_RAT)\n    np.savetxt(os.path.join(\"results\", \"rayflare_fullrt_300um_2umpyramids_300_1200nm_profile.txt\"), result['profile'])\n\nelse:\n    # If calc = False, load results from previous run.\n    result_RAT = np.loadtxt(os.path.join(\"results\", \"rayflare_fullrt_300um_2umpyramids_300_1200nm.txt\"))\n    profile_rt = np.loadtxt(os.path.join(\"results\", \"rayflare_fullrt_300um_2umpyramids_300_1200nm_profile.txt\"))\n\nPLOT 1: results of ray-tracing from RayFlare and PVLighthouse, showing the reflection, absorption and transmission.\n\nplt.figure()\nplt.plot(result_RAT[:,0], result_RAT[:,1], '-o', color=pal[0], label=r'R$_{total}$', fillstyle='none')\nplt.plot(result_RAT[:,0], result_RAT[:,2], '-o', color=pal[1], label=r'R$_0$', fillstyle='none')\nplt.plot(result_RAT[:,0], result_RAT[:,3], '-o', color=pal[2], label=r'T', fillstyle='none')\nplt.plot(result_RAT[:,0], result_RAT[:,4], '-o', color=pal[3], label=r'A', fillstyle='none')\nplt.plot(PVlighthouse[:, 0], PVlighthouse[:, 2], '--', color=pal[0])\nplt.plot(PVlighthouse[:, 0], PVlighthouse[:, 9], '--', color=pal[2])\nplt.plot(PVlighthouse[:, 0], PVlighthouse[:, 3], '--', color=pal[1])\nplt.plot(PVlighthouse[:, 0], PVlighthouse[:, 5], '--', color=pal[3])\nplt.plot(-1, -1, '-ok', label='RayFlare')\nplt.plot(-1, -1, '--k', label='PVLighthouse')\nplt.xlabel('Wavelength (nm)')\nplt.ylabel('R / A / T')\nplt.ylim(0, 1)\nplt.xlim(300, 1200)\nplt.legend()\nplt.title(\"(1) R/A/T for pyramid-textured Si, calculated with RayFlare and PVLighthouse\")\nplt.show()"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/4a-textured_Si_cell.html#using-optical-results-in-solcore",
    "href": "solar-cell-simulation/notebooks/4a-textured_Si_cell.html#using-optical-results-in-solcore",
    "title": "Example 4a: Textured Si cell",
    "section": "Using optical results in Solcore",
    "text": "Using optical results in Solcore\nSo far, we have done a purely optical calculation; however, if we want to use this information to do an EQE or IV calculation, we can, by using the ability of Solcore to accept external optics data (we used this in Example 1a already). To use Solcore’s device simulation capabilities (QE/IV), we need to create a function which gives the depth-dependent absorption profile. The argument of the function is the position (in m) in the cell, which can be an array, and the function returns an array with the absorption at these depths at every wavelength with dimensions (n_wavelengths, n_positions).\nRayFlare has the make_absorption_function to automatically make this function, as required by Solcore, from RayFlare’s output data. diff_absorb_fn here is the function we need to pass to Solcore (so it is not an array of values!). We need to provide the profile data, the structure that was being simulated, user options and specify whether we used the angular redistribution matrix method (which in this case we did not, so we set matrix_method=False; see [Example 6a]](6a-multiscale_models.ipynb) for a similar example which does use this method).\n\nposition, diff_absorb_fn = make_absorption_function(profile_rt, rtstr, options, matrix_method=False)\n\nNow we feed this into Solcore; we will define a solar cell model using the depletion approximation (see Example 1c).\nWe need a p-n junction; we make sure the total width of the p-n junction is equal to the width of the Si used above in the ray-tracing calculation (rtrst.widths[0]).\n\nSi_base = material(\"Si\")\n\nn_material_Si_width = si(\"500nm\")\np_material_Si_width = rtstr.widths[0] - n_material_Si_width\n\nn_material_Si = Si_base(Nd=si(1e21, \"cm-3\"), hole_diffusion_length=si(\"10um\"),\n                electron_mobility=50e-4, relative_permittivity=11.68)\np_material_Si = Si_base(Na=si(1e16, \"cm-3\"), electron_diffusion_length=si(\"290um\"),\n                hole_mobility=400e-4, relative_permittivity=11.68)\n\nOptions for Solcore (note that these are separate from the RayFlare options we set above!):\n\noptions_sc = defaults_solcore\noptions_sc.optics_method = \"external\"\noptions_sc.position = np.arange(0, rtstr.width, options.depth_spacing)\noptions_sc.light_iv = True\noptions_sc.wavelength = wl\noptions_sc.theta = options.theta_in*180/np.pi\nV = np.linspace(0, 1, 200)\noptions_sc.voltages = V\n\nMake the solar cell, passing the absorption function we made above, and the reflection (an array with the R value at each wavelength), and calculate the QE and I-V characteristics.\n\nsolar_cell = SolarCell(\n    [\n        Junction([Layer(width=n_material_Si_width, material=n_material_Si, role='emitter'),\n                  Layer(width=p_material_Si_width, material=p_material_Si, role='base')],\n                 sn=1, sp=1, kind='DA')\n    ],\n    external_reflected=result_RAT[:,1],\n    external_absorbed=diff_absorb_fn)\n\nsolar_cell_solver(solar_cell, 'qe', options_sc)\nsolar_cell_solver(solar_cell, 'iv', options_sc)\n\nSolving optics of the solar cell...\nSolving QE of the solar cell...\nSolving optics of the solar cell...\nAlready calculated reflection, transmission and absorption profile - not recalculating. Set recalculate_absorption to True in the options if you want absorption to be calculated again.\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\n\n\nPLOT 2: EQE and absorption of Si cell with optics calculated through ray-tracing\n\nplt.figure()\nplt.plot(wl*1e9, solar_cell.absorbed, 'k-', label='Absorbed (integrated)')\nplt.plot(wl*1e9, solar_cell[0].eqe(wl), 'r-', label='EQE')\nplt.plot(wl*1e9, result_RAT[:,4], 'r--', label='Absorbed - RT')\nplt.ylim(0,1)\nplt.legend()\nplt.xlabel('Wavelength (nm)')\nplt.ylabel('R/A')\nplt.title(\"(2) EQE/absorption from electrical model\")\nplt.show()\n\n\n\n\nPLOT 3: Light IV of Si cell with optics calculated through ray-tracing\n\nplt.figure()\nplt.plot(V, -solar_cell[0].iv(V), 'r')\nplt.ylim(-20, 400)\nplt.xlim(0, 0.8)\nplt.legend()\nplt.ylabel('Current (A/m$^2$)')\nplt.xlabel('Voltage (V)')\nplt.title(\"(3) IV characteristics\")\nplt.show()\n\nNo artists with labels found to put in legend.  Note that artists whose label start with an underscore are ignored when legend() is called with no argument."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/6a-multiscale_models.html",
    "href": "solar-cell-simulation/notebooks/6a-multiscale_models.html",
    "title": "Example 6a: Silicon HIT cell",
    "section": "",
    "text": "In Example 4a, we looked at a solar cell made of a single layer of Si with pyramidal texturing. In reality, a solar cell will have a more complicated structure with thin layers deposited on the front side to act as e.g. selective transport layers for carriers. This adds a layer of complication to the ray-tracing process, because we can no longer rely on the Fresnel equations to calculate the angle and wavelength-dependent reflection and transmission probabilities; we might get absorption in the surface layers, and we need to take into account interference in the surface layers. To do this, we can combine ray-tracing and the transfer-matrix method; we can calculate the reflection, absorption and transmission probabilities using TMM, and use those probabilities in our ray-tracing calculations. In RayFlare, this functionality is implemented as part of the angular redistribution matrix functionality.\nThis example is (loosely) based on the simulations done for this paper which looks at the absorptivity/emissivity of silicon heterojunction (HJT or HIT) cells, although here we will only look at the usual wavelengths for the photovoltaic operation of silicon solar cells rather than the infrared.\nfrom solcore import material, si\nfrom solcore.light_source import LightSource\nfrom solcore.constants import q\nfrom solcore.solar_cell import SolarCell, Layer, Junction\nfrom solcore.solar_cell_solver import default_options as defaults_solcore, solar_cell_solver\n\nfrom rayflare.textures import regular_pyramids\nfrom rayflare.structure import Interface, BulkLayer, Structure\nfrom rayflare.matrix_formalism import calculate_RAT, process_structure\nfrom rayflare.options import default_options\nfrom rayflare.utilities import make_absorption_function\n\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy.ndimage.filters import gaussian_filter1d\n\nfrom cycler import cycler"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/6a-multiscale_models.html#setting-up",
    "href": "solar-cell-simulation/notebooks/6a-multiscale_models.html#setting-up",
    "title": "Example 6a: Silicon HIT cell",
    "section": "Setting up",
    "text": "Setting up\nWe add some new materials to Solcore’s database from data files - you only need to add these once, after that you can comment these lines out.\n\nfrom solcore.material_system import create_new_material\n\ncreate_new_material('aSi_i', os.path.join(\"data\", \"model_i_a_silicon_n.txt\"),\n                    os.path.join(\"data\", \"model_i_a_silicon_k.txt\"))\ncreate_new_material('ITO_measured', os.path.join(\"data\", \"front_ITO_n.txt\"),\n                    os.path.join(\"data\", \"front_ITO_k.txt\"))\n\nSyntaxError: invalid syntax (2638323969.py, line 3)\n\n\nSetting user options. Several of these (wavelength, number of rays, nx, ny) have been encountered in previous examples. However, because we are using the angular redistribution matrix method for the first time, there are some new ones. Please see RayFlare’s documentation for more detailed information.\n\nproject_name: When we run the simulation, we will generate large matrices which will eventually be multiplied together. These have to be stored somewhere. This is the name of the folder where they will be stored.\nn_theta_bins: The number of polar angle bins to divide the hemisphere into when calculating the redistribution matrices.\nI_thresh: Threshold intensity at which to stop matrix multiplication (i.e. when almost all the light has been reflected, transmitted or absorbed)\nbulk_profile: True or False; whether to calculate the absorption profile in the bulk material (Si in this case).\n\n\nwavelengths = np.linspace(300, 1200, 80)*1e-9\n\noptions = default_options()\noptions.wavelengths = wavelengths\noptions.project_name = 'HIT_example'\noptions.n_rays = 10000 # Reduce this (or the number of wavelengths) to speed up the example! Note that this is the TOTAL number of rays (all angle bins) per wavelength\noptions.n_theta_bins = 20\noptions.nx = 5\noptions.ny = 5\noptions.I_thresh = 0.005\noptions.bulk_profile = True\n\nWe now define the materials and layer structures for the front and rear surfaces. In this case, the front and rear layers are the materials which will be deposited on top of the pyramids (amorphous silicon and ITO); the crystalline silicon itself will be the bulk material which connects the two interfaces.\n\nSi = material('Si')()\nAir = material('Air')()\nITO = material('ITO_measured')()\n\nAg = material('Ag')()\naSi = material('aSi_i')()\n\nfront_materials = [Layer(80e-9, ITO), Layer(13e-9, aSi)]\nback_materials = [Layer(13e-9, aSi), Layer(240e-9, ITO)]\n\nNow we define the front and rear surfaces using the Interface class. Whether pyramids are upright or inverted is relative to front incidence, so if the same etch is applied to both sides of a slab of silicon, one surface will have ‘upright’ pyramids and the other side will have ‘not upright’ (inverted) pyramids in the model. The arguments required for Interface depend on the optical method which is being used; in this case, we must provide the surface texture, layer stack, and whether the layers are to be treated coherently (i.e. affected by thin-film interference). We also have to give the surfaces a name; as with the project name, this is to store the matrices which will be calculated.\n\nsurf = regular_pyramids(elevation_angle=55, upright=True) # elevation angle is relative to horizontal plane\nsurf_back = regular_pyramids(elevation_angle=55, upright=False)\n\nfront_surf = Interface('RT_TMM', texture=surf, layers=front_materials, name='HIT_front', coherent=True)\nback_surf = Interface('RT_TMM', texture=surf_back, layers=back_materials, name='HIT_back', coherent=True)\n\nbulk_Si = BulkLayer(170e-6, Si, name='Si_bulk') # bulk thickness in m\n\nFinally, we build the whole structure inside RayFlare’s Structure class, also specifying the incidence medium (above the cell) and the transmission medium (below the cell).\n\nSC = Structure([front_surf, bulk_Si, back_surf], incidence=Air, transmission=Ag)"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/6a-multiscale_models.html#generating-results",
    "href": "solar-cell-simulation/notebooks/6a-multiscale_models.html#generating-results",
    "title": "Example 6a: Silicon HIT cell",
    "section": "Generating results",
    "text": "Generating results\nNow we are ready to start running calculations. This happens in two phases:\n\nCall process_structure to check each surface in the structure, and generate angular redistribution matrices (if it does not find existing ones)\nCall calculate_rat to run the matrix multiplication and generate reflection, transmission and absorption results\n\n\nprocess_structure(SC, options, save_location=\"current\")\n# save_location = current means that the folder with the redistribution matrix will be created in the current working directory. By default, it is saved in a folder called\n# RayFlare_results in your home directory (~).\nresults = calculate_RAT(SC, options, save_location=\"current\")\n\nMaking lookuptable for element 0 in structure\nMaking lookuptable for element 2 in structure\nRay tracing with TMM lookup table for element 0 in structure\nCalculating matrix only for incidence theta/phi\nRay tracing with TMM lookup table for element 2 in structure\nAfter iteration 1 : maximum power fraction remaining = 0.5629448135186488\nAfter iteration 2 : maximum power fraction remaining = 0.3425270607560974\nAfter iteration 3 : maximum power fraction remaining = 0.20990358983841642\nAfter iteration 4 : maximum power fraction remaining = 0.12862942930538473\nAfter iteration 5 : maximum power fraction remaining = 0.0788271578176077\nAfter iteration 6 : maximum power fraction remaining = 0.04832164906096151\nAfter iteration 7 : maximum power fraction remaining = 0.029625034965812196\nAfter iteration 8 : maximum power fraction remaining = 0.018162348111822744\nAfter iteration 9 : maximum power fraction remaining = 0.011134523091393584\nAfter iteration 10 : maximum power fraction remaining = 0.006826006659534447\nAfter iteration 11 : maximum power fraction remaining = 0.004184675817775243\n\n\nThe structure of the results returned by calculate_RAT is quite complicated; it is explained on this page.\n\nRAT = results[0]\nresults_per_pass = results[1]\n\nR_per_pass = np.sum(results_per_pass['r'][0], axis=2)\nR_0 = R_per_pass[0]\nR_escape = np.sum(R_per_pass[1:, :], axis=0)\n\n# results_per_pass: sum over passes to get overall absorption in each layer.\nresults_per_layer_front = np.sum(results_per_pass['a'][0], axis=0)\n\nresults_per_layer_back = np.sum(results_per_pass['a'][1], axis=0)\n\nTo get the maximum current we could achieve based on these optical results, we calculate the photogenerated current using the AM1.5G spectrum.\n\nspectr_flux = LightSource(source_type='standard', version='AM1.5g', x=wavelengths,\n                           output_units='photon_flux_per_m', concentration=1).spectrum(wavelengths)[1]\n\nJph_Si = q * np.trapz(RAT['A_bulk'][0] * spectr_flux, wavelengths)/10 # mA/cm2\n\nprint(\"Photogenerated current in Si = %.1f mA/cm2\" % Jph_Si)\n\nPhotogenerated current in Si = 37.5 mA/cm2"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/6a-multiscale_models.html#plotting",
    "href": "solar-cell-simulation/notebooks/6a-multiscale_models.html#plotting",
    "title": "Example 6a: Silicon HIT cell",
    "section": "Plotting",
    "text": "Plotting\nNow, we plot where all incident light goes: reflection, absorption in each layer, and transmission into the substrate in the simulation. Note that we set the substrate as Ag for the simulation; although in the actual device the Ag is not infinitely thick, in practice it is thick enough that all light which enters the Ag will be absorbed there so we can treat is as the final material.\nPLOT 1: Reflection and absorption in the Si HIT cell\n\n# Stack results for plotting\nallres = np.hstack((RAT['T'].T, results_per_layer_back,\n                    RAT['A_bulk'].T, results_per_layer_front)).T\n\n# Create colors for plotting\npal = sns.cubehelix_palette(allres.shape[0] + 1, start=.5, rot=-.9)\npal.reverse()\n\n# Update default colours used by matplotlib\ncols = cycler('color', pal)\nparams = {'axes.prop_cycle': cols}\nplt.rcParams.update(params)\n\n# plot total R, A, T\nfig = plt.figure(figsize=(6,4))\nax = plt.subplot(111)\nax.plot(options['wavelengths']*1e9, R_escape + R_0, '-k', label=r'$R_{total}$')\nax.plot(options['wavelengths']*1e9, R_0, '--k', label=r'$R_0$')\nax.stackplot(options['wavelengths']*1e9, allres,\n             labels=['Ag (transmitted)', 'Back ITO', 'a-Si (back)', 'Bulk Si',\n                     'a-Si (front)', 'Front ITO'\n                     ])\nax.set_xlabel(r'Wavelength ($\\mu$m)')\nax.set_ylabel('Absorption/Emissivity')\nax.set_xlim(min(options['wavelengths']*1e9), max(options['wavelengths']*1e9))\nax.set_ylim(0, 1)\nplt.legend(loc='center left', bbox_to_anchor=(1, 0.5))\nplt.tight_layout()\nplt.show()\n\n\n\n\nWe see that over this wavelength range, most of the absorption happens in the bulk Si, as expected. However, at short wavelengths we see significant absorption in the front surface layers, and at long wavelengths we see absorption in the back layers and Ag. We have plotted both the total reflection \\(R_{total}\\) and \\(R_0\\), which is the light which is lost due to initial reflection at the front surface. Up to around 1000 nm, these lines coincide (total reflection is entirely due to initial front surface reflection). At longer wavelengths, we see that \\(R_0\\) is lower than \\(R_{total}\\), as now a significant fraction of the total reflection is from light which enters the cell, makes at least one full forward and backward pass, and then leaves the cell through the front surface. This becomes significant close to the bandgap as the Si becomes transparent.\nIn the plot above we see stochastic noise due to the ray-tracing simulation; we could increase the number of rays to reduce this, which also increases the computation time. Below, we re-plot the same data with some smoothing.\nPLOT 2: Reflection and absorption in the Si HIT cell, with smoothed data\n\nysmoothed = gaussian_filter1d(np.vstack((allres, RAT[\"R\"])), sigma=2, axis=1)\n\n# plot total R, A, T - smoothed\nfig = plt.figure(figsize=(6,4))\nax = plt.subplot(111)\nax.stackplot(options['wavelengths']*1e9, ysmoothed,\n             labels=['Ag (transmitted)', 'Back ITO', 'a-Si (back)', 'Bulk Si',\n                     'a-Si (front)', 'Front ITO', 'R'\n                     ])\nax.set_xlabel(r'Wavelength ($\\mu$m)')\nax.set_ylabel('Absorption/Emissivity')\nax.set_xlim(min(options['wavelengths']*1e9), max(options['wavelengths']*1e9))\nax.set_ylim(0, 1)\nplt.legend(loc='center left', bbox_to_anchor=(1, 0.5))\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/6a-multiscale_models.html#device-simulations",
    "href": "solar-cell-simulation/notebooks/6a-multiscale_models.html#device-simulations",
    "title": "Example 6a: Silicon HIT cell",
    "section": "Device simulations",
    "text": "Device simulations\nAs we did in Example 4a, we can now feed the results from RayFlare’s optical calculation into Solcore to run electrical simulations. We generate the absorption profile function, then specify materials and layers for the solar cell structure.\n\nprofile_Si = results[3][0]\nexternal_R = RAT['R'][0, :]\n\npositions, absorb_fn = make_absorption_function([None, profile_Si, None], SC, options, matrix_method=True)\n\nSi_SC = material(\"Si\")\nGaAs_SC = material(\"GaAs\")\nT = 300\n\np_material_Si = Si_SC(T=T, Na=si(1e21, \"cm-3\"), electron_diffusion_length=si(\"10um\"), hole_mobility=50e-4)\nn_material_Si = Si_SC(T=T, Nd=si(1e16, \"cm-3\"), hole_diffusion_length=si(\"290um\"), electron_mobility=400e-4)\n\nAs we noted in Example 4a, we need to specify the user options for Solcore separately (though they should of course be consistent with the options we gave RayFlare above, where relevant!). We set options, create the solar cell structure, and run QE and IV calculations:\n\noptions_sc = defaults_solcore\noptions_sc.optics_method = \"external\"\noptions_sc.position = positions\noptions_sc.light_iv = True\noptions_sc.wavelength = wavelengths\noptions_sc.mpp = True\noptions_sc.theta = options.theta_in*180/np.pi\nV = np.linspace(0, 2.5, 250)\noptions_sc.voltages = V\n\nsolar_cell = SolarCell([Layer(80e-9, ITO),\n                   Layer(13e-9, aSi),\n                   Junction([Layer(500e-9, p_material_Si, role=\"emitter\"),\n                             Layer(bulk_Si.width-500e-9, n_material_Si, role=\"base\")], kind=\"DA\"),\n                   Layer(13e-9, aSi),\n                   Layer(240e-9, ITO)],\n                  external_reflected = external_R,\n                                       external_absorbed = absorb_fn)\n\n\n\nsolar_cell_solver(solar_cell, 'qe', options_sc)\nsolar_cell_solver(solar_cell, 'iv', options_sc)\n\nNow we can plot the results. To check things are consistent, we will plot the total absorption in Si calculated above with RayFlare, and solar_cell.absorbed, which is the result Solcore gives for total absorption. We also plot the EQE, which should be the same as or lower than the absorption.\nPLOT 3: Absorption in the Si and EQE.\n\nplt.figure()\nplt.plot(options['wavelengths']*1e9, RAT[\"A_bulk\"][0], 'r-')\nplt.plot(wavelengths*1e9, solar_cell.absorbed, 'k--', label='Absorbed (integrated)')\nplt.plot(wavelengths*1e9, solar_cell[2].eqe(wavelengths), 'b-', label='Si EQE')\nplt.ylim(0,1)\nplt.legend()\nplt.xlabel('Wavelength (nm)')\nplt.ylabel('R/A')\nplt.show()\n\n\n\n\nPLOT 4: Current-voltage behaviour of the Si cell under illumination\n\nplt.figure()\nplt.plot(V, solar_cell.iv['IV'][1], '-k')\nplt.ylim(-20, 380)\nplt.xlim(0, 0.85)\nplt.ylabel('Current (A/m$^2$)')\nplt.xlabel('Voltage (V)')\nplt.show()"
  },
  {
    "objectID": "solar-cell-simulation/tutorials.html",
    "href": "solar-cell-simulation/tutorials.html",
    "title": "Tutorials",
    "section": "",
    "text": "This is the website for the solcore-education GitHub, where we host readable versions of Solcore and RayFlare examples (see the sidebar on the left). Note that this is not an introductory Python course, or a course about the fundamentals of solar cells.\nThe examples on this website are hosted in Jupyter Notebook (.ipynb) format for readability. To run the examples yourself, you can find standard .py versions on the GitHub here. We recommend using these rather than the Notebook versions.\nPackage requirements\nTo use the examples on this website, you will need to install Solcore and RayFlare (the links take you to installation instructions for each package). In the simplest case, you can install them with:\npip install solcore rayflare\nBut this will not install all functionality, as detailed in the documentation for both packages.\nThe only other dependency, which is used for plotting, is seaborn, which you can install simply with:\npip install seaborn"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/6b-multiscale_models.html",
    "href": "solar-cell-simulation/notebooks/6b-multiscale_models.html",
    "title": "Example 6b: Angular redistribution matrix method",
    "section": "",
    "text": "In Example 6a, we looked at a silicon heterojunction cell using integrated ray-tracing and TMM to calculate the optical behaviour of each surface, and using the angular redistribution matrix method (ARMM) to combine the surfaces and calculate overall reflection, transmission, absorption per layer and absorption profiles. However, ARMM is not limited to treating surfaces with ray-tracing; it is also possible to use the TMM by itself (for planar layers), RCWA (for gratings/periodic structutes) or ideal analytic cases (perfect mirrors and Lambertian reflectors are currently implemented) to generate the angular redistribution matrices. In this example we will replicate simulation results shown in the paper on OPTOS, looking at the effect of planar surfaces, regular pyramids, and a diffraction grating on absorption in a silicon wafer.\nimport numpy as np\nimport os\n\nfrom solcore.structure import Layer\nfrom solcore import material, si\n\nfrom rayflare.structure import Interface, BulkLayer, Structure\nfrom rayflare.matrix_formalism import process_structure, calculate_RAT, get_savepath\nfrom rayflare.transfer_matrix_method import tmm_structure\nfrom rayflare.angles import theta_summary, make_angle_vector\nfrom rayflare.textures import regular_pyramids\nfrom rayflare.options import default_options\n\nimport matplotlib.pyplot as plt\nfrom sparse import load_npz\nimport seaborn as sns\nimport matplotlib as mpl"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/6b-multiscale_models.html#setting-up",
    "href": "solar-cell-simulation/notebooks/6b-multiscale_models.html#setting-up",
    "title": "Example 6b: Angular redistribution matrix method",
    "section": "Setting up",
    "text": "Setting up\nWe have encountered most of these options in the previous examples. Previously, we have mostly simulated optical behaviour for light at normal incidence but in this case, to match the results from the OPTOS paper, we will look at an incidence angle of 8\\(^\\circ\\). Other relevant options are c_azimuth, which controls how fine the spacing of the angular bins in the azimuthal directions is, and pol, the polarization of the incident light.\n\nangle_degrees_in = 8\n\nwavelengths = np.linspace(900, 1180, 30)*1e-9\n\nSi = material('Si')()\nAir = material('Air')()\n\noptions = default_options()\noptions.wavelengths = wavelengths\noptions.theta_in = angle_degrees_in*np.pi/180\noptions.n_theta_bins = 50\noptions.c_azimuth = 0.25\noptions.n_rays = 200000 # increase to reduce noise, decrease for faster execution\noptions.project_name = 'compare_surfaces'\noptions.phi_symmetry = np.pi/2\noptions.I_thresh = 0.005\noptions.nx = 5\noptions.ny = 5\noptions.bulk_profile = False"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/6b-multiscale_models.html#structures-and-interfaces",
    "href": "solar-cell-simulation/notebooks/6b-multiscale_models.html#structures-and-interfaces",
    "title": "Example 6b: Angular redistribution matrix method",
    "section": "Structures and Interfaces",
    "text": "Structures and Interfaces\nWe will consider three structures:\n\nPlanar front, crossed grating (Si/air) at rear\nRegular pyramids on the front, planar rear\nRegular pyramids on the front, crossed grating at rear.\n\nThis means we have four different surfaces to consider across all structures: a. Planar front b. Pyramidal front c. Planar rear d. Grating rear\nFor structure 1 (a + d), we define the grating (surface d) in the same we would if using rcwa_structure (Example 5a). The grating period in this case is 1000 nm with a feature height of 120 nm.\n\nx = 1000\n\nd_vectors = ((x, 0),(0,x))\narea_fill_factor = 0.36\nhw = np.sqrt(area_fill_factor)*500\n\nfront_materials = []\nback_materials = [Layer(si('120nm'), Si, geometry=[{'type': 'rectangle', 'mat': Air, 'center': (x/2, x/2),\n                                                     'halfwidths': (hw, hw), 'angle': 45}])]\n\nCreate the texture for the pyramidal front surface (b):\n\nsurf = regular_pyramids(elevation_angle=55, upright=False)\n\nNow we define the four Interfaces we need for the three Structures; using the numbering above, that is:\n\nStructure 1 = a + d\nStructure 2 = b + c\nStructure 3 = b + d\n\nFor each Interface, we have to specify the method we want to use, a name, the surface layers (or lack therof). For the RT (ray-tracing) surfaces, we need to specify the texture and for the RCWA surfaces we need to specify the unit cell lattice vectors d_vectors and the number of rcwa_orders to use. We also define the bulk, 200 \\(\\mu\\)m of Si.\n\nfront_surf_pyramids = Interface('RT_Fresnel', texture=surf, layers=[],\n                                name = 'inv_pyramids_front_' + str(options['n_rays']))\nfront_surf_planar = Interface('TMM', layers=[], name='planar_front')\nback_surf_grating = Interface('RCWA', layers=back_materials, name='crossed_grating_back',\n                              d_vectors=d_vectors, rcwa_orders=15) # increase orders for betting convergence (calculation takes longer!)\nback_surf_planar = Interface('TMM', layers=[], name = 'planar_back')\n\nbulk_Si = BulkLayer(200e-6, Si, name = 'Si_bulk') # bulk thickness in m\n\nNow we define the three structures listed above. For reference, we also define a fully planar structure (a + c).\n\nSC_fig6 = Structure([front_surf_planar, bulk_Si, back_surf_grating], incidence=Air, transmission=Air)\nSC_fig7 = Structure([front_surf_pyramids, bulk_Si, back_surf_planar], incidence=Air, transmission=Air)\nSC_fig8 = Structure([front_surf_pyramids, bulk_Si, back_surf_grating], incidence=Air, transmission=Air)\nplanar = Structure([front_surf_planar, bulk_Si, back_surf_planar], incidence=Air, transmission=Air)\n\nNow, as in Example 6a, we process the structures (to generate the matrices) and then use calculate_rat to obtain the final results. Note that it is not necessary to call process_structure for the planar structure, because the redistribution matrices for both of its interfaces will have already been calculated when considering structures 1 and 2.\n\n# Process structures (step 1)\n\nprocess_structure(SC_fig6, options, save_location=\"current\")\nprocess_structure(SC_fig7, options, save_location=\"current\")\nprocess_structure(SC_fig8, options, save_location=\"current\")\n\n# Calculate RAT (step 2)\n\nresults_fig6= calculate_RAT(SC_fig6, options, save_location=\"current\")\nresults_fig7 = calculate_RAT(SC_fig7, options, save_location=\"current\")\nresults_fig8 = calculate_RAT(SC_fig8, options, save_location=\"current\")\nresults_planar = calculate_RAT(planar, options, save_location=\"current\")\n\n# Get RAT results\nRAT_fig6 = results_fig6[0]\nRAT_fig7 = results_fig7[0]\nRAT_fig8 = results_fig8[0]\n\nRAT_planar = results_planar[0]\n\nOf course, it is not necessary to use the ARMM to calculate the optics of a simple planar slab of Si; we could have done this simply with an (incoherent) TMM calculation. We will do this to compare the results:\n\nstruc = tmm_structure([Layer(si('200um'), Si)], Air, Air)\noptions.coherent = False\noptions.coherency_list = ['i']\nRAT = tmm_structure.calculate(struc, options)"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/6b-multiscale_models.html#results",
    "href": "solar-cell-simulation/notebooks/6b-multiscale_models.html#results",
    "title": "Example 6b: Angular redistribution matrix method",
    "section": "Results",
    "text": "Results\nPLOT 1: Absorption in Si for the four different structures.\n\npalhf = sns.color_palette(\"hls\", 4)\n\nfig = plt.figure()\nplt.plot(wavelengths*1e9, RAT_fig6['A_bulk'][0], '-o', color=palhf[0], label='Rear grating', fillstyle='none')\nplt.plot(wavelengths*1e9, RAT_fig7['A_bulk'][0], '-o', color=palhf[1],  label= 'Front pyramids', fillstyle='none')\nplt.plot(wavelengths*1e9, RAT_fig8['A_bulk'][0], '-o', color=palhf[2],  label= 'Grating + pyramids', fillstyle='none')\nplt.plot(wavelengths*1e9, RAT['A_per_layer'][:,0], '-k', label='Planar')\nplt.plot(wavelengths*1e9, RAT_planar['A_bulk'][0], '--r')\nplt.legend(loc='lower left')\nplt.xlabel('Wavelength (nm)')\nplt.ylabel('Absorption in Si')\nplt.xlim([900, 1200])\nplt.ylim([0, 1])\nplt.show()\n\n\n\n\nWe can see that both the rear grating and front surface pyramid texture increase absorption in the Si. The rear grating does not affect the front surface reflection, while the pyramid texture does, which increases absorption over the whole wavelength range. The two methods for calculating absorption in the planar structure are in agreement as expected."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/6b-multiscale_models.html#visualizing-the-redistribution-matrices",
    "href": "solar-cell-simulation/notebooks/6b-multiscale_models.html#visualizing-the-redistribution-matrices",
    "title": "Example 6b: Angular redistribution matrix method",
    "section": "Visualizing the redistribution matrices",
    "text": "Visualizing the redistribution matrices\nRayFlare has built-in functions to make it easier to load and plot the redistribution matrices you have generated. First, based on the options we set, we generate the angle_vector which lists the \\(\\theta\\) (polar angle) and \\(\\phi\\) (azimuthal angle) values in each bin of the angular redistribution matrices.\n\ntheta_intv, phi_intv, angle_vector = make_angle_vector(options['n_theta_bins'], options['phi_symmetry'],\n                                       options['c_azimuth'])\n\npalhf = sns.cubehelix_palette(256, start=.5, rot=-.9)\npalhf.reverse()\nseamap = mpl.colors.ListedColormap(palhf)\n\nNow we find the path where the matrices are stored. We calculated the redistribution matrices at different wavelengths, but we are just going to plot them at a single wavelength, so we find which index in the matrix that wavelength corresponds to.\n\npath = get_savepath('current', options.project_name)\n\nwl_to_plot = 1100e-9\n\nwl_index = np.argmin(np.abs(wavelengths-wl_to_plot))\n\nThe redistribution matrices are stored in a sparse matrix format (this is much more efficient, since usually many matrix entries will be zero. A sparse matrix format lists only the non-zero entries). Using the path we found above and the name of the surface, we load the sparse matrix, select only the wavelength we are interested in, and convert it to a normal NumPy array (a “dense” matrix):\n\nsprs = load_npz(os.path.join(path, SC_fig8[2].name + 'frontRT.npz'))\n# Load the redistribution matrices for the bottom surface in SC_fig8 (this is the grating)\n\nfull = sprs[wl_index].todense()\n# Convert from sparse format to normal numpy array\n\nThe indexing of the sparse array is (wavelength, angular bin out, angular bin in). To make the information easier to interpret, RayFlare has the theta_summary function which will sum over all the azimuthal bins at a certain \\(\\theta\\), and returns the results in xarray format. We then select only the first half of the matrix; the data for reflection and transmission are stored in the same array (0 to \\(2 \\pi\\) radians), but we pick out only the reflection part.\n\nsummat = theta_summary(full, angle_vector, options['n_theta_bins'], front_or_rear='front')\n# Front or rear refers to front or rear incidence on the surface, rather than the front or rear surface of the\n# whole structure\n\nsummat_g = summat[:options['n_theta_bins'], :]\n# We select the FIRST half of the matrix: this is redistribution into the upper half plane, so because we are\n# looking at incident light coming from this half-plane, this corresponds to reflection\n\nWe can use xarray’s functionality to transform the coordinates from \\(\\theta\\) to \\(\\sin\\theta\\), and then rename the coordinates (this will automatically label the plots below).\n\nsummat_g = summat_g.assign_coords({r'$\\theta_{in}$': np.sin(summat_g.coords[r'$\\theta_{in}$']).data,\n                                    r'$\\theta_{out}$': np.sin(summat_g.coords[r'$\\theta_{out}$']).data})\n\nsummat_g = summat_g.rename({r'$\\theta_{in}$': r'$\\sin(\\theta_{in})$', r'$\\theta_{out}$': r'$\\sin(\\theta_{out})$'})\n\nNow repeat this for another surface (the pyramidal surface):\n\nsprs = load_npz(os.path.join(path, SC_fig8[0].name + 'rearRT.npz'))\n# Load the redistribution matrices for the top surface in SC_fig8 (this is the pyramids)\n\nfull = sprs[wl_index].todense()\n\nsummat = theta_summary(full, angle_vector, options['n_theta_bins'], front_or_rear='rear')\n# Front or rear refers to front or rear incidence on the surface, rather than the front or rear surface of the\n# whole structure\n\nsummat_r = summat[options['n_theta_bins']:, :]\n# We select the SECOND half of the matrix: this is redistribution into the lower half plane, so because we are\n# looking at incident light coming from this half-plane, this corresponds to reflection\n\nsummat_r = summat_r.assign_coords({r'$\\theta_{in}$': np.sin(summat_r.coords[r'$\\theta_{in}$']).data,\n                                    r'$\\theta_{out}$': np.sin(summat_r.coords[r'$\\theta_{out}$']).data})\n\nsummat_r = summat_r.rename({r'$\\theta_{in}$': r'$\\sin(\\theta_{in})$', r'$\\theta_{out}$': r'$\\sin(\\theta_{out})$'})\n\nPlot the redistribution matrices:\nPLOT 2: Redistribution matrices for reflection into Silicon from the diffraction grating (left) and pyramid surface (right).\n\nfig = plt.figure(figsize=(10,4))\nax = plt.subplot(121)\nax = summat_g.plot.imshow(ax=ax, cmap=seamap, vmax=0.3)\nax = plt.subplot(122)\nax = summat_r.plot.imshow(ax=ax, cmap=seamap)\nplt.show()\n\n\n\n\nThe left plot shows redistribution of light upon reflection from the rear grating. The right plot shows redistribution of light which hits the pyramidal front surface from the inside and is reflected back into the cell. We could plot equivalent matrices for e.g. transmission through the rear grating or light escaping when incident on the pyramid surface from the inside of the structure."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/2b-optical_constants.html",
    "href": "solar-cell-simulation/notebooks/2b-optical_constants.html",
    "title": "Example 2b: Optical constant models",
    "section": "",
    "text": "We may want to model the optical constants of a material using analytic expressions, rather than just take data from a table; this can be useful when e.g. fitting ellipsometry data for a material with unknown optical constants, or if you do not have refractive index data for a material but have some information about where critical points in the band structure occur. In this example we will consider a simple model for a dielectric material, and a more complex model for GaAs, a semiconductor.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom solcore.absorption_calculator import search_db\nfrom solcore.absorption_calculator.cppm import Custom_CPPB\nfrom solcore.absorption_calculator.dielectric_constant_models import Oscillator\nfrom solcore.absorption_calculator.dielectric_constant_models import DielectricConstantModel, Cauchy\nfrom solcore.structure import Structure\nfrom solcore import material\n\nwl = np.linspace(300, 950, 200)*1e-9\n\nWe search the database for BK7 (borosilicate crown glass) and select the second entry, “Ohara” (index 1). We then select the first item in that list, which is the pageid of the entry - this is what we need to tell Solcore what item to access in the database.\n\npageid = search_db(\"BK7\")[1][0];\nBK7 = material(str(pageid), nk_db=True)()\n\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\n18 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n963 glass   BK7 SCHOTT  glass/schott/N-BK7.yml  1   1   0.3 2.5 25\n964 glass   BK7 OHARA   glass/ohara/S-BSL7.yml  1   1   0.29    2.4 31\n965 glass   BK7 HIKARI  glass/hikari/J-BK7A.yml 1   1   0.365015    2.05809 33\n966 glass   BK7 CDGM    glass/cdgm/H-K9L.yml    1   1   0.365   1.711   34\n967 glass   BK7 HOYA    glass/hoya/BSC7.yml 1   1   0.36501 1.01398 38\n968 glass   BK7 SUMITA  glass/sumita/K-BK7.yml  1   1   0.36    1.55    25\n969 glass   BK7 LZOS    glass/lzos/K8.yml   1   0   0.365   2.3254  31\n1090    glass   SCHOTT-BK   BK7G18  glass/schott/BK7G18.yml 1   1   0.38    2.5 18\n1091    glass   SCHOTT-BK   N-BK7   glass/schott/N-BK7.yml  1   1   0.3 2.5 25\n1092    glass   SCHOTT-BK   N-BK7HT glass/schott/N-BK7HT.yml    1   1   0.3 2.5 25\n1093    glass   SCHOTT-BK   N-BK7HTi    glass/schott/N-BK7HTi.yml   1   1   0.3 2.5 25\n1095    glass   SCHOTT-BK   P-BK7   glass/schott/P-BK7.yml  1   1   0.31    2.5 24\n1683    glass   HIKARI-BK   E-BK7   glass/hikari/E-BK7.yml  1   1   0.4 0.7 32\n1684    glass   HIKARI-BK   J-BK7   glass/hikari/J-BK7.yml  1   1   0.365015    2.05809 33\n1685    glass   HIKARI-BK   J-BK7A  glass/hikari/J-BK7A.yml 1   1   0.365015    2.05809 33\n2452    glass   SUMITA-BK   K-BK7   glass/sumita/K-BK7.yml  1   1   0.36    1.55    25\n2819    other   BK7_matching_liquid Cargille    index-matching liquids/cargille/BK7_matching_liquid.yml 1   0   0.31    1.55    200\n2904    3d  glass   BK7 glass/schott/N-BK7.yml  1   1   0.3 2.5 25\n\n\nNext, we define a Cauchy oscillator model. We put this into the DielectricConstantModel class; in theory, we could add as many oscillators as we want here.\nThe parameters for the Cauchy model for BK7 are from Wikipedia: https://en.wikipedia.org/wiki/Cauchy%27s_equation\n\ncauchy = Cauchy(An=1.5046, Bn=0.00420, Cn=0, Ak=0, Bk=0, Ck=0)\nmodel = DielectricConstantModel(e_inf=0, oscillators=[cauchy])\n\nCalculate the dielectric function which result from the Cauchy model, then get the \\(n\\) and \\(\\kappa\\) data from the database BK7 material for the complex refractive index:\n\neps = model.dielectric_constants(wl*1e9)\nnk = BK7.n(wl) + 1j*BK7.k(wl)\n\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial glass/ohara/S-BSL7.yml loaded.\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial glass/ohara/S-BSL7.yml loaded.\n\n\nCalculate the dielectric function by squaring the refractive index:\n\neps_db = nk**2\n\nPLOT 1: Plot the database values of e_1 (real part of the dielectric function) against the Cauchy model values:\n\nplt.figure()\nplt.plot(wl*1e9, np.real(eps), label='Cauchy model')\nplt.plot(wl*1e9, np.real(eps_db), '--', label='Database values')\nplt.legend()\nplt.ylabel(r'$\\epsilon_1$')\nplt.xlabel('Wavelength (nm)')\nplt.title(\"(1) Dielectric function for BK7 glass\")\nplt.show()\n\n\n\n\nHere, we have just looked at the real part of the dielectric function, but you can include absorption (non-zero e_2) in the dielectric constant models too.\nNow let’s look at a more complicated CPPB (Critical Point Parabolic Band) model for GaAs. First, read in experimental data for GaAs dielectric function (from Palik)…\n\nPalik_Eps1 = np.loadtxt(\"data/Palik_GaAs_Eps1.csv\", delimiter=',', unpack=False)\nPalik_Eps2 = np.loadtxt(\"data/Palik_GaAs_Eps2.csv\", delimiter=',', unpack=False)\n\nGenerate a list of energies over which to calculate the model dielectric function and create the CPPB_model Class object:\n\nE = np.linspace(0.2, 5, 1000)\nCPPB_Model = Custom_CPPB()\n\nThe Material_Params method loads in the desired material parameters as a dictionary (for some common materials):\n\nMatParams = CPPB_Model.Material_Params(\"GaAs\")\n\nParameters can be customised by assigning to the correct dictionary key:\n\nMatParams[\"B1\"] = 5.8\nMatParams[\"B1s\"] = 1.0\nMatParams[\"Gamma_Eg_ID\"] = 0.3\nMatParams[\"Alpha_Eg_ID\"] = 0.0\nMatParams[\"E1\"] = 2.8\nMatParams[\"E1_d1\"] = 2.9\nMatParams[\"Gamma_E1\"] = 0.1\nMatParams[\"E2\"] = 4.72\nMatParams[\"C\"] = 3.0\nMatParams[\"Alpha_E2\"] = 0.04\nMatParams[\"Gamma_E2\"] = 0.19\n\nMust define a structure object containing the required oscillator functions. The oscillator type and material parameters are both passed to individual ‘Oscillators’ in the structure:\n\nAdachi_GaAs = Structure([\n    Oscillator(oscillator_type=\"E0andE0_d0\", material_parameters=MatParams),\n    Oscillator(oscillator_type=\"E1andE1_d1\", material_parameters=MatParams),\n    Oscillator(oscillator_type=\"E_ID\", material_parameters=MatParams),\n    Oscillator(oscillator_type=\"E2\", material_parameters=MatParams)\n])\n\nOutput = CPPB_Model.eps_calc(Adachi_GaAs, E)\n\nPLOT 2: real and imaginary part of the dielectric constant, showing the individual contributions of the critical points.\n\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(9, 4.5))\n\n# Subplot I :: Real part of the dielectric function.\nax1.set_xlim(0, 5.3)\nax1.set_ylim(-14, 27)\n\nax1.plot(Palik_Eps1[:, 0], Palik_Eps1[:, 1], label=\"Exp. Data (Palik)\",\n         marker='o', ls='none', markerfacecolor='none', markeredgecolor=\"red\")\n\nax1.plot(E, Output[\"eps\"].real, color=\"navy\", label=\"Total\")\nax1.plot(E, Output[\"components\"][0].real, color=\"orangered\", ls='--', label=\"$E_0$ and $E_0+\\Delta_0$\")\nax1.plot(E, Output[\"components\"][1].real, color=\"dodgerblue\", ls='--', label=\"$E_1$ and $E_1+\\Delta_1$\")\nax1.plot(E, Output[\"components\"][2].real, color=\"limegreen\", ls='--', label=\"$E_{ID}$ (Indirect)\")\nax1.plot(E, Output[\"components\"][3].real, color=\"gold\", ls='--', label=\"$E_2$\")\n\nax1.set_xlabel(\"Energy (eV)\")\nax1.set_ylabel(\"$\\epsilon_1 (\\omega)$\")\nax1.set_title(\"(2) CPPB model for GaAs compared with experimental data\")\nax1.text(0.05, 0.05, '(a)', transform=ax1.transAxes, fontsize=12)\n\n# Subplot II :: Imaginary part of the dielectric function.\n\nax2.plot(Palik_Eps2[:, 0], Palik_Eps2[:, 1], label=\"Exp. Data (Palik)\",\n         marker='o', ls='none', markerfacecolor='none', markeredgecolor=\"red\")\n\nax2.plot(E, Output[\"eps\"].imag, color=\"Navy\", label=\"Total\")\nax2.plot(E, Output[\"components\"][0].imag, color=\"orangered\", ls='--', label=\"$E_0$ and $E_0+\\Delta_0$\")\nax2.plot(E, Output[\"components\"][1].imag, color=\"dodgerblue\", ls='--', label=\"$E_1$ and $E_1+\\Delta_1$\")\nax2.plot(E, Output[\"components\"][2].imag, color=\"limegreen\", ls='--', label=\"$E_{ID}$ (Indirect)\")\nax2.plot(E, Output[\"components\"][3].imag, color=\"gold\", ls='--', label=\"$E_2$\")\nax2.set_xlim(0, 5.3)\nax2.set_ylim(0, 27)\n\nax2.set_xlabel(\"Energy (eV)\")\nax2.set_ylabel(\"$\\epsilon_2 (\\omega)$\")\nax2.text(0.05, 0.05, '(b)', transform=ax2.transAxes, fontsize=12)\nax2.legend(loc=\"upper left\", frameon=False)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1b-simple_cell.html",
    "href": "solar-cell-simulation/notebooks/1b-simple_cell.html",
    "title": "Example 1b: Basic cell optics",
    "section": "",
    "text": "In this script, we will build on the TMM model from example 1(a) and look at the effects of interference.\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom solcore import material, si\nfrom solcore.solar_cell import Layer\nfrom solcore.absorption_calculator import calculate_rat, OptiStack\nimport seaborn as sns"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1b-simple_cell.html#setting-up",
    "href": "solar-cell-simulation/notebooks/1b-simple_cell.html#setting-up",
    "title": "Example 1b: Basic cell optics",
    "section": "Setting up",
    "text": "Setting up\nFirst, let’s define some materials:\n\nSi = material(\"Si\")\nSiN = material(\"Si3N4\")()\nAg = material(\"Ag\")()\n\nNote the second set of brackets (or lack thereof). The Solcore material system essentially operates in two stages; we first call the material function with the name of the material we want to use, for example Si = material(“Si”), which creates a general Python class corresponding to that material. We then call this class to specify further details, such as the temperature, doping level, or alloy composition (where relavant). This happens below when defining Si_n and Si_p; both are use the Si class defined above, and adding further details to the material. For the definitions of SiN and Ag above, we do both steps in a single line, hence the two sets of brackets.\n\nSi_n = Si(Nd=si(\"1e21cm-3\"), hole_diffusion_length=si(\"10um\"))\nSi_p = Si(Na=si(\"1e16cm-3\"), electron_diffusion_length=si(\"400um\"))\n\nTo look at the effect of interference in the Si layer at different thicknesses, we make a list of thicknesses to test (evenly spaced on a log scale from 400 nm to 300 um):\n\nSi_thicknesses = np.linspace(np.log(0.4e-6), np.log(300e-6), 8)\nSi_thicknesses = np.exp(Si_thicknesses)\n\nwavelengths = si(np.linspace(300, 1200, 400), \"nm\")\n\noptions = {\n    \"recalculate_absorption\": True,\n    \"optics_method\": \"TMM\",\n    \"wavelength\": wavelengths\n           }\n\nMake a color palette using the seaborn package to make the plots look nicer\n\ncolors = sns.color_palette('rocket', n_colors=len(Si_thicknesses))\ncolors.reverse()\n\ncreate an ARC layer:\n\nARC_layer = Layer(width=si('75nm'), material=SiN)"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1b-simple_cell.html#effect-of-si-thickness",
    "href": "solar-cell-simulation/notebooks/1b-simple_cell.html#effect-of-si-thickness",
    "title": "Example 1b: Basic cell optics",
    "section": "Effect of Si thickness",
    "text": "Effect of Si thickness\nNow we are going to loop through the different Si thicknesses generated above, and create a simple solar cell-like structure. Because we will only do an optical calculation, we don’t need to define a junction and can just make a simple stack of layers.\nWe then calculate reflection, absorption and transmission (RAT) for two different situations: 1. a fully coherent stack 2. assuming the silicon layer is incoherent. This means that light which enters the Si layer cannot interfere with itself, but light in the ARC layer can still show interference. In very thick layers (much thicker than the wavelength of light being considered) this is likely to be more physically accurate because real light does not have infinite coherence length; i.e. if you measured wavelength-dependent transmission or reflection of a Si wafer hundreds of microns thick you would not expect to see interference fringes.\nPLOT 1\n\nplt.figure()\n\nfor i1, Si_t in enumerate(Si_thicknesses):\n\n    base_layer = Layer(width=Si_t, material=Si_p) # silicon layer\n    solar_cell = OptiStack([ARC_layer, base_layer]) # OptiStack (optical stack) to feed into calculate_rat function\n\n    # Coherent calculation:\n    RAT_c = calculate_rat(solar_cell, wavelengths*1e9, no_back_reflection=False) # coherent calculation\n    # For historical reasons, Solcore's default setting is to ignore reflection at the back of the cell (i.e. at the\n    # interface between the final material in the stack and the substrate). Hence we need to tell the calculate_rat\n    # function NOT to ignore this reflection (no_back_reflection=False).\n\n    # Calculation assuming no interference in the silicon (\"incoherent\"):\n    RAT_i = calculate_rat(solar_cell, wavelengths*1e9, no_back_reflection=False,\n                          coherent=False, coherency_list=['c', 'i']) # partially coherent: ARC is coherent, Si is not\n\n    # Plot the results:\n    plt.plot(wavelengths*1e9, RAT_c[\"A\"], color=colors[i1], label=str(round(Si_t*1e6, 1)), alpha=0.7)\n    plt.plot(wavelengths*1e9, RAT_i[\"A\"], '--', color=colors[i1])\n\nplt.legend(title=r\"Thickness ($\\mu$m)\")\nplt.xlim(300, 1300)\nplt.ylim(0, 1.02)\nplt.ylabel(\"Absorption\")\nplt.title(\"(1) Absorption in Si with varying thickness\")\nplt.show()\n\n\n\n\nWe can see that the coherent calculations (solid lines) show clear interference fringes which depend on the Si thickness. The incoherent calculations do not have these fringes and seem to lie around the average of the interference fringes. For both sets of calculations, we see increasing absorption as the Si gets thicker, as expected."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1b-simple_cell.html#effect-of-reflective-substrate",
    "href": "solar-cell-simulation/notebooks/1b-simple_cell.html#effect-of-reflective-substrate",
    "title": "Example 1b: Basic cell optics",
    "section": "Effect of reflective substrate",
    "text": "Effect of reflective substrate\nNow we repeat the calculation, but with an Ag substrate under the Si. Previously, we did not specify the substrate and so it was assumed by Solcore to be air (n=1, k=0).\nPLOT 2\n\nplt.figure()\n\nfor i1, Si_t in enumerate(Si_thicknesses):\n\n    base_layer = Layer(width=Si_t, material=Si_p)\n\n    # As before, but now we specify the substrate to be silver:\n    solar_cell = OptiStack([ARC_layer, base_layer], substrate=Ag)\n\n    RAT_c = calculate_rat(solar_cell, wavelengths*1e9, no_back_reflection=False)\n    RAT_i = calculate_rat(solar_cell, wavelengths*1e9, no_back_reflection=False,\n                          coherent=False, coherency_list=['c', 'i'])\n    plt.plot(wavelengths*1e9, RAT_c[\"A\"], color=colors[i1],\n             label=str(round(Si_t*1e6, 1)), alpha=0.7)\n    plt.plot(wavelengths*1e9, RAT_i[\"A\"], '--', color=colors[i1])\n\nplt.legend(title=r\"Thickness ($\\mu$m)\")\nplt.xlim(300, 1300)\nplt.ylim(0, 1.02)\nplt.ylabel(\"Absorption\")\nplt.title(\"(2) Absorption in Si with varying thickness (Ag substrate)\")\nplt.show()\n\n\n\n\nWe see that the interference fringes get more prominent in the coherent calculation, due to higher reflection at the rear Si/Ag surface compared to Ag/Air. We also see a slightly boosted absorption at long wavelengths at all thicknesses, again due to improved reflection at the rear surface"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1b-simple_cell.html#effect-of-polarization-and-angle-of-incidence",
    "href": "solar-cell-simulation/notebooks/1b-simple_cell.html#effect-of-polarization-and-angle-of-incidence",
    "title": "Example 1b: Basic cell optics",
    "section": "Effect of polarization and angle of incidence",
    "text": "Effect of polarization and angle of incidence\nFinally, we look at the effect of incidence angle and polarization of the light hitting the cell.\nPLOT 3\n\nangles = [0, 30, 60, 70, 80, 89] # angles in degrees\n\nARC_layer = Layer(width=si('75nm'), material=SiN)\nbase_layer = Layer(width=si(\"100um\"), material=Si_p)\n\ncolors = sns.cubehelix_palette(n_colors=len(angles))\n\nplt.figure()\n\nfor i1, theta in enumerate(angles):\n\n    solar_cell = OptiStack([ARC_layer, base_layer])\n\n    RAT_s = calculate_rat(solar_cell, wavelengths*1e9, angle=theta,\n                          pol='s',\n                          no_back_reflection=False,\n                          coherent=False, coherency_list=['c', 'i'])\n    RAT_p = calculate_rat(solar_cell, wavelengths*1e9, angle=theta,\n                          pol='p',\n                          no_back_reflection=False,\n                          coherent=False, coherency_list=['c', 'i'])\n\n    plt.plot(wavelengths*1e9, RAT_s[\"A\"], color=colors[i1], label=str(round(theta)))\n    plt.plot(wavelengths*1e9, RAT_p[\"A\"], '--', color=colors[i1])\n\nplt.legend(title=r\"$\\theta (^\\circ)$\")\nplt.xlim(300, 1300)\nplt.ylim(0, 1.02)\nplt.ylabel(\"Absorption\")\nplt.title(\"(3) Absorption in Si with varying thickness\")\nplt.show()\n\n\n\n\nFor normal incidence (\\(\\theta = 0^\\circ\\)), s (solid lines) and p (dashed lines) polarization are equivalent. As the incidence angle increases, in general absorption is higher for p-polarized light (due to lower reflection). Usually, sunlight is modelled as unpolarized light, which computationally is usually done by averaging the results for s and p-polarized light."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/1b-simple_cell.html#conclusions",
    "href": "solar-cell-simulation/notebooks/1b-simple_cell.html#conclusions",
    "title": "Example 1b: Basic cell optics",
    "section": "Conclusions",
    "text": "Conclusions\nWe have now seen some effects of interference in layers of different thicknesses, and seen the effect of adding a highly reflective substrate. So we already have two strategies for light-trapping/improving the absorption in a solar cell: adding an anti-reflection coating (in example 1a), to reduce front-surface reflection and get more light into the cell, and adding a highly reflective layer at the back, to reduce loss through the back of the cell and keep light trapped in the cell."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/3a-triple_junction.html",
    "href": "solar-cell-simulation/notebooks/3a-triple_junction.html",
    "title": "Example 3a: Triple junction cell",
    "section": "",
    "text": "In the previous examples, we have considered only single-junction cells. However, a major part of Solcore’s capability lies in modelling multi-junction solar cells. In this example, we will look at a triple junction InGaP/GaAs/Ge cell at 1 Sun and under concentration.\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\nfrom solcore import siUnits, material, si\nfrom solcore.solar_cell import SolarCell\nfrom solcore.structure import Junction, Layer\nfrom solcore.solar_cell_solver import solar_cell_solver\nfrom solcore.light_source import LightSource\nfrom solcore.absorption_calculator import search_db\n\nwl = np.linspace(300, 1850, 700) * 1e-9\nWe define our light source, the AM1.5G spectrum, which will be used for I-V calculations (not under concentration):\nlight_source = LightSource(source_type='standard', x=wl, version='AM1.5g')\nNow we need to build the solar cell layer by layer.\nNote: you need to have downloaded the refractiveindex.info database for these to work. See Example 2a.\nMgF2_pageid = search_db(os.path.join(\"MgF2\", \"Rodriguez-de Marcos\"))[0][0];\nZnS_pageid = search_db(os.path.join(\"ZnS\", \"Querry\"))[0][0];\nMgF2 = material(str(MgF2_pageid), nk_db=True)();\nZnS = material(str(ZnS_pageid), nk_db=True)();\n\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\n1 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n234 main    MgF2    Rodriguez-de_Marcos main/MgF2/Rodriguez-de Marcos.yml   1   1   0.0299919   2.00146 960\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\n1 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n623 main    ZnS Querry  main/ZnS/Querry.yml 1   1   0.22    166.6667    312\nTo minimize front surface reflection, we use a four-layer anti-reflection coating (ARC):\nARC = [Layer(si(\"100nm\"), MgF2), Layer(si(\"15nm\"), ZnS), Layer(si(\"15nm\"), MgF2), Layer(si(\"50nm\"), ZnS)]"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/3a-triple_junction.html#top-cell-gainp",
    "href": "solar-cell-simulation/notebooks/3a-triple_junction.html#top-cell-gainp",
    "title": "Example 3a: Triple junction cell",
    "section": "Top cell: GaInP",
    "text": "Top cell: GaInP\nNow we build the top cell, which requires the n and p sides of GaInP and a window layer. We also add some extra parameters needed for the calculation which are not included in the materials database, such as the minority carriers diffusion lengths.\n\nAlInP = material(\"AlInP\")\nInGaP = material(\"GaInP\")\nwindow_material = AlInP(Al=0.52)\n\ntop_cell_n_material = InGaP(In=0.49, Nd=siUnits(2e18, \"cm-3\"), hole_diffusion_length=si(\"200nm\"))\ntop_cell_p_material = InGaP(In=0.49, Na=siUnits(1e17, \"cm-3\"), electron_diffusion_length=si(\"1um\"))"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/3a-triple_junction.html#middle-cell-gaas",
    "href": "solar-cell-simulation/notebooks/3a-triple_junction.html#middle-cell-gaas",
    "title": "Example 3a: Triple junction cell",
    "section": "Middle cell: GaAs",
    "text": "Middle cell: GaAs\n\nGaAs = material(\"GaAs\")\n\nmid_cell_n_material = GaAs(Nd=siUnits(3e18, \"cm-3\"), hole_diffusion_length=si(\"500nm\"))\nmid_cell_p_material = GaAs(Na=siUnits(1e17, \"cm-3\"), electron_diffusion_length=si(\"5um\"))"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/3a-triple_junction.html#bottom-cell-ge",
    "href": "solar-cell-simulation/notebooks/3a-triple_junction.html#bottom-cell-ge",
    "title": "Example 3a: Triple junction cell",
    "section": "Bottom cell: Ge",
    "text": "Bottom cell: Ge\n\nGe = material(\"Ge\")\n\nbot_cell_n_material = Ge(Nd=siUnits(2e18, \"cm-3\"), hole_diffusion_length=si(\"800nm\"), hole_mobility=0.01)\nbot_cell_p_material = Ge(Na=siUnits(1e17, \"cm-3\"), electron_diffusion_length=si(\"50um\"), electron_mobility=0.1)"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/3a-triple_junction.html#putting-the-cell-together",
    "href": "solar-cell-simulation/notebooks/3a-triple_junction.html#putting-the-cell-together",
    "title": "Example 3a: Triple junction cell",
    "section": "Putting the cell together",
    "text": "Putting the cell together\nAnd, finally, we put everything together, adding also the surface recombination velocities. We also add some shading due to the metallisation of the cell = 5%, and a finite series resistance.\n\nsolar_cell = SolarCell(\n    ARC +\n    [\n        Junction([Layer(si(\"20nm\"), material=window_material, role='window'),\n                  Layer(si(\"100nm\"), material=top_cell_n_material, role='emitter'),\n                  Layer(si(\"560nm\"), material=top_cell_p_material, role='base'),\n                  ], sn=1, sp=1, kind='DA'),\n        Junction([Layer(si(\"200nm\"), material=mid_cell_n_material, role='emitter'),\n                  Layer(si(\"3000nm\"), material=mid_cell_p_material, role='base'),\n                  ], sn=1, sp=1, kind='DA'),\n        Junction([Layer(si(\"400nm\"), material=bot_cell_n_material, role='emitter'),\n                  Layer(si(\"100um\"), material=bot_cell_p_material, role='base'),\n                  ], sn=1, sp=1, kind='DA'),\n    ], shading=0.05, R_series=2e-6)"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/3a-triple_junction.html#setting-the-depth-spacing",
    "href": "solar-cell-simulation/notebooks/3a-triple_junction.html#setting-the-depth-spacing",
    "title": "Example 3a: Triple junction cell",
    "section": "Setting the depth spacing",
    "text": "Setting the depth spacing\nThe ‘position’ user option in Solcore determines at which z-points the absorption profile is calculated. You can specify this is multiple different ways:\n\na vector which specifies each position (in m) at which the depth should be calculated\na single number which specifies the spacing (in m) to generate the position vector, e.g. 1e-9 for 1 nm spacing\na list of numbers which specify the spacing (in m) to be used in each layer. This list can have EITHER the length of the number of individual layers + the number of junctions in the cell object, OR the length of the total number of individual layers including layers inside junctions.\n\nHere we use the final options, setting the spacing to use per junction/layer. We use 0.1 nm for all layers except the final layer, the Ge, where we use 10 nm.\n\nposition = len(solar_cell) * [0.1e-9]\nposition[-1] = 10e-9 # Indexing with -1 in a Python list/array gives you the last element\n\nNow that we have made the cell and set the options, we calculate and plot the EQE.\nPLOT 1: EQE of a triple junction cell, comparing TMM and BL optical methods\n\nplt.figure()\n\n# First calculate with TMM optical method\nsolar_cell_solver(solar_cell, 'qe', user_options={'wavelength': wl, 'optics_method': \"TMM\",\n                                                  'position': position, 'recalculate_absorption': True})\n\nplt.plot(wl * 1e9, solar_cell[4].eqe(wl) * 100, 'b', label='GaInP (TMM)')\nplt.plot(wl * 1e9, solar_cell[5].eqe(wl) * 100, 'g', label='InGaAs (TMM)')\nplt.plot(wl * 1e9, solar_cell[6].eqe(wl) * 100, 'r', label='Ge (TMM)')\nplt.plot(wl * 1e9, 100 * (1 - solar_cell.reflected), 'k--', label='1-R (TMM)')\n\n# Recalculate with simple Beer-Lambert (BL) law absorption to compare\nsolar_cell_solver(solar_cell, 'qe', user_options={'wavelength': wl, 'optics_method': \"BL\",\n                                                  'position': position, 'recalculate_absorption': True})\n\nplt.plot(wl * 1e9, solar_cell[4].eqe(wl) * 100, 'b--', alpha=0.5, label='GaInP (BL)')\nplt.plot(wl * 1e9, solar_cell[5].eqe(wl) * 100, 'g--', alpha=0.5, label='InGaAs (BL)')\nplt.plot(wl * 1e9, solar_cell[6].eqe(wl) * 100, 'r--', alpha=0.5, label='Ge (BL)')\nplt.legend()\nplt.ylim(0, 100)\nplt.ylabel('EQE (%)')\nplt.xlabel('Wavelength (nm)')\nplt.tight_layout()\nplt.title(\"(1) EQE and absorption for 3J cell using TMM and BL optical methods\")\nplt.show()\n\nSolving optics of the solar cell...\nTreating layer(s) 10 incoherently\nCalculating RAT...\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/MgF2/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/MgF2/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/ZnS/Querry.yml loaded.\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/ZnS/Querry.yml loaded.\nCalculating absorption profile...\nSolving QE of the solar cell...\nSolving optics of the solar cell...\nSolving QE of the solar cell...\n\n\n/Users/phoebe/Documents/develop/solcore5/solcore/analytic_solar_cells/depletion_approximation.py:617: RuntimeWarning: invalid value encountered in true_divide\n  iqe =  j_sc / current_absorbed\n/Users/phoebe/Documents/develop/solcore5/solcore/analytic_solar_cells/depletion_approximation.py:617: RuntimeWarning: invalid value encountered in true_divide\n  iqe =  j_sc / current_absorbed\n\n\n\n\n\nWe see that the BL absorption is higher everywhere, because it does not include any front-surface reflection. In the TMM calculation, we see interference fringes and some front-surface reflection (though due to the 4-layer ARC, the reflection is quite low everywhere).\nNow we calculate and plot the light IV under the AM1.5G spectrum, using the TMM optical method\nPLOT 2: Light IV for triple-junction cell\n\nV = np.linspace(0, 3, 300)\nsolar_cell_solver(solar_cell, 'iv', user_options={'voltages': V, 'light_iv': True,\n                                                  'wavelength': wl, 'mpp': True,\n                                                  'light_source': light_source,\n                                                  'recalculate_absorption': True,\n                                                  'optics_method': \"TMM\"})\n\nplt.figure()\nplt.plot(V, solar_cell.iv['IV'][1], 'k', linewidth=3, label='Total')\nplt.plot(V, -solar_cell[4].iv(V), 'b', label='GaInP')\nplt.plot(V, -solar_cell[5].iv(V), 'g', label='InGaAs')\nplt.plot(V, -solar_cell[6].iv(V), 'r', label='Ge')\nplt.text(1.4, 220, 'Efficieny (%): ' + str(np.round(solar_cell.iv['Eta'] * 100, 1)))\nplt.text(1.4, 200, 'FF (%): ' + str(np.round(solar_cell.iv['FF'] * 100, 1)))\nplt.text(1.4, 180, r'V$_{oc}$ (V): ' + str(np.round(solar_cell.iv[\"Voc\"], 2)))\nplt.text(1.4, 160, r'I$_{sc}$ (A/m$^2$): ' + str(np.round(solar_cell.iv[\"Isc\"], 2)))\n\nplt.legend()\nplt.ylim(0, 250)\nplt.xlim(0, 3)\nplt.ylabel('Current (A/m$^2$)')\nplt.xlabel('Voltage (V)')\nplt.title(\"(2) IV characteristics of 3J cell\")\n\nplt.show()\n\nSolving optics of the solar cell...\nTreating layer(s) 10 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell..."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/3a-triple_junction.html#cell-behaviour-under-concentration",
    "href": "solar-cell-simulation/notebooks/3a-triple_junction.html#cell-behaviour-under-concentration",
    "title": "Example 3a: Triple junction cell",
    "section": "Cell behaviour under concentration",
    "text": "Cell behaviour under concentration\nMulti-junction cells are often used in concetrator PV applications. Here, we look at the effect of increasing the concentration on the \\(V_{oc}\\), \\(J_{sc}\\) and the efficiency \\(\\eta\\). Note that in order to reproduce the behaviour we see in real concentrator cells (initial increase in efficiency due to increased \\(V_{oc}\\), with a reduction in efficiency at very high concentrations due to a decrease in fill factor due to series resistance), we need to specify a series resistance in the cell definition above; if not, the simulated efficiency would continue to increase.\nWe consider concentrations between 1x and 3000x, linearly spaced on a log scale:\n\nconcentration = np.linspace(np.log(1), np.log(3000), 20)\nconcentration = np.exp(concentration)\n\nCreate empty arrays to store the data (this is preferable to simply appending data in a loop since it pre-allocates the memory needed to store the arrays):\n\nEffs = np.empty_like(concentration) # creates an empty array with the same shape as the concentration array\nVocs = np.empty_like(concentration)\nIscs = np.empty_like(concentration)\n\nV = np.linspace(0, 3.5, 300)\n\nLoop through the concentrations. We use only the direct spectrum (AM1.5D) since diffuse light will not be concentrated:\n\nfor i1, conc in enumerate(concentration):\n\n    # We make a light source with the concentration being considered. We also use AM1.5D (direct only) rather than AM1.5G\n    # (direct + diffuse):\n    light_conc = LightSource(source_type='standard', x=wl, version='AM1.5d', concentration=conc)\n\n    solar_cell_solver(solar_cell, 'iv', user_options={'voltages': V, 'light_iv': True,\n                                                      'wavelength': wl, 'mpp': True,\n                                                      'light_source': light_conc});\n\n    # Save the calculated values in the arrays:\n    Effs[i1] = solar_cell.iv[\"Eta\"] * 100\n    Vocs[i1] = solar_cell.iv[\"Voc\"]\n    Iscs[i1] = solar_cell.iv[\"Isc\"]\n\nPLOT 3: Efficiency, open-circuit voltage and short-circuit current at different concentrations for the 3J cell\n\nplt.figure(figsize=(10, 3))\nplt.subplot(131)\nplt.semilogx(concentration, Effs, '-o')\nplt.ylabel('Efficiency (%)')\nplt.xlabel('Concentration')\nplt.title(\"(3) Efficiency, V$_{oc}$ and J$_{sc}$ vs. concentration for 3J cell\")\n\nplt.subplot(132)\nplt.semilogx(concentration, Vocs, '-o')\nplt.ylabel(r'V$_{OC}$ (V)')\nplt.xlabel('Concentration')\n\nplt.subplot(133)\nplt.plot(concentration, Iscs / 10000, '-o')\nplt.ylabel(r'J$_{SC}$ (A/cm$^2$)')\nplt.xlabel('Concentration')\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/5a-ultrathin_GaAs_cell.html",
    "href": "solar-cell-simulation/notebooks/5a-ultrathin_GaAs_cell.html",
    "title": "Example 5a: Ultra-thin GaAs cell with diffraction grating",
    "section": "",
    "text": "In previous examples, we have considered a few different methods used to improve absorption in solar cells: anti-reflection coatings, to decrease front-surface reflection, metallic rear mirrors to reduce transmission and increase the path length of light in the cell, and textured surfaces (with pyramids) which are used on Si cells to reduce reflection and increase the path length of light in the cell. Another method which can be used for light-trapping is the inclusion of periodic structures such as diffraction gratings or photonic crystals; here, we will consider an ultra-thin (80 nm) GaAs cell with a diffraction grating.\nThis example is based on the simulations done for this paper.\nNote: This example requires that you have a working S4 installation.\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport os\n\nfrom solcore import si, material\nfrom solcore.structure import Layer\nfrom solcore.light_source import LightSource\nfrom solcore.solar_cell import SolarCell\nfrom solcore.constants import q\nfrom solcore.absorption_calculator import search_db\n\nfrom rayflare.rigorous_coupled_wave_analysis.rcwa import rcwa_structure\nfrom rayflare.transfer_matrix_method.tmm import tmm_structure\nfrom rayflare.options import default_options"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/5a-ultrathin_GaAs_cell.html#setting-up",
    "href": "solar-cell-simulation/notebooks/5a-ultrathin_GaAs_cell.html#setting-up",
    "title": "Example 5a: Ultra-thin GaAs cell with diffraction grating",
    "section": "Setting up",
    "text": "Setting up\nFirst, defining all the materials. We are just going to do an optical simulation, so don’t have to worry about doping levels and other parameters which would affect the electrical performance of the cell.\n\nInAlP = material('AlInP')(Al=0.5)  # In0.5Al0.5P\nGaAs = material('GaAs')()\nInGaP = material('GaInP')(In=0.5)  # Ga0.5In0.5P\nSiN = material('Si3N4')()     # for the ARC\nAl2O3 = material('Al2O3P')()  # for the ARC\n\nAir = material('Air')()\n\nThe optical constants used for the silver are very important, so we search for a known reliable dataset (from this paper).\n\nAg_pageid = search_db(os.path.join(\"Ag\", \"Jiang\"))[0][0]\nAg = material(str(Ag_pageid), nk_db=True)()\n\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\n1 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n2   main    Ag  Jiang   main/Ag/Jiang.yml   1   1   0.3 2.0 1701\n\n\nAM0 spectrum (photon flux) for calculating currents. For space applications (i.e. above the atmosphere) we are often interested in AM0. We use Solcore’s LightSource class, then extract the AM0 photon flux at the wavelengths we are going to use in the simulations.\n\nwavelengths = np.linspace(303, 1000, 200) * 1e-9\n\nAM0_ls = LightSource(source_type='standard', version='AM0', x=wavelengths, output_units=\"photon_flux_per_m\")\nAM0 = AM0_ls.spectrum(x=wavelengths)[1] # Photon flux; used to calculate photogenerated current later on\n\nSetting options. We choose s polarization because, for normal incidence, there will not be a difference in the results for \\(s\\) and \\(p\\) polarization (and thus for unpolarized light, u, which would be calculated as the average of the results for \\(s\\) and \\(p\\) polarization. We could set the polarization to u for equivalent results (at normal incidence only), but this would take longer because then RayFlare has to run two calculations and then average them.\nThe other key option is the number of Fourier orders retained: rigorous coupled-wave analysis (RCWA) is a Fourier-space method, and we have to specify how many Fourier orders should be retained in the calculation. As we increase the number of orders, the calculation should become more accurate and eventually converge, but the computation time increases (it scales with the cube of the number of orders).\n\noptions = default_options()\noptions.pol = 's'\noptions.wavelengths = wavelengths\noptions.orders = 100 # Reduce the number of orders to speed up the calculation."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/5a-ultrathin_GaAs_cell.html#on-substrate-device",
    "href": "solar-cell-simulation/notebooks/5a-ultrathin_GaAs_cell.html#on-substrate-device",
    "title": "Example 5a: Ultra-thin GaAs cell with diffraction grating",
    "section": "On-substrate device",
    "text": "On-substrate device\nThis device is still on the GaAs substrate (it is also inverted compared to the other devices, since it represents the device before patterning and lift-off). We create the simulation object using tmm_structure class, and then use the .calculate function defined for the class to calculate the reflection, absorption per layer, and transmission.\n\nprint(\"Calculating on-substrate device...\")\n\nstruct = SolarCell([Layer(si('20nm'), InAlP), Layer(si('85nm'), GaAs),\n                   Layer(si('20nm'), InGaP)])\n\n# make TMM structure for planar device\nTMM_setup = tmm_structure(struct, incidence=Air, transmission=GaAs)\n\n# calculate\nRAT_TMM_onsubs = TMM_setup.calculate(options)\n\nAbs_onsubs = RAT_TMM_onsubs['A_per_layer'][:,1]  # absorption in GaAs\n# indexing of A_per_layer is [wavelengths, layers]\n\nR_onsubs = RAT_TMM_onsubs['R']\nT_onsubs = RAT_TMM_onsubs['T']\n\nCalculating on-substrate device..."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/5a-ultrathin_GaAs_cell.html#planar-silver-mirror-device",
    "href": "solar-cell-simulation/notebooks/5a-ultrathin_GaAs_cell.html#planar-silver-mirror-device",
    "title": "Example 5a: Ultra-thin GaAs cell with diffraction grating",
    "section": "Planar silver mirror device",
    "text": "Planar silver mirror device\nThis device is now flipped (in fabrication terms, the back mirror was applied and then the device lifted off). It has a silver back mirror, which should increase reflection and the rear surface so that less light is lost to the substrate.\n\nprint(\"Calculating planar Ag mirror device...\")\n\nsolar_cell_TMM = SolarCell([Layer(material=InGaP, width=si('20nm')),\n                        Layer(material=GaAs, width=si('85nm')),\n                        Layer(material=InAlP, width=si('20nm'))],\n                           substrate=Ag)\n\nTMM_setup = tmm_structure(solar_cell_TMM, incidence=Air, transmission=Ag)\n\nRAT_TMM = TMM_setup.calculate(options)\n\nAbs_TMM = RAT_TMM['A_per_layer'][:, 1]\nAbs_TMM_InAlPonly = RAT_TMM['A_per_layer'][:, 2]\nAbs_TMM_InGaPonly = RAT_TMM['A_per_layer'][:, 0]\nR_TMM = RAT_TMM['R']\nT_TMM = RAT_TMM['T']\n\nCalculating planar Ag mirror device...\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/Ag/Jiang.yml loaded.\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/Ag/Jiang.yml loaded."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/5a-ultrathin_GaAs_cell.html#nanophotonic-grating-device",
    "href": "solar-cell-simulation/notebooks/5a-ultrathin_GaAs_cell.html#nanophotonic-grating-device",
    "title": "Example 5a: Ultra-thin GaAs cell with diffraction grating",
    "section": "Nanophotonic grating device",
    "text": "Nanophotonic grating device\nFinally, this device has a grating made of silver and SiN, followed by a planar silver back mirror; this leads to diffraction, increasing the path length of light in the cell, while keeping reflection high. Here we use the rcwa_structure class, which is used in the same way as tmm_structure above and rt_structure in Example 4a. Because we are now dealing with a structure which is periodic in the \\(x\\) and \\(y\\) directions (unlike the TMM structures, which are uniform in the plane), we have to specify the size of the unit cell (this does not have to be square; here we have a triangular unit cell to give a grating with a hexagonal layout of circles). Otherwise, the grating layer is specified as normal but with a geometry argument which lists the shapes in the grating and the material they are made of.\nThere are many additional options which can be specified for S4 (which is used to actually run the RCWA calculations); more detail can be found in its documentation here.\n\nprint(\"Calculating nanophotonic grating device...\")\n\nx = 600\n\n# lattice vectors for the grating. Units are in nm!\nsize = ((x, 0), (x / 2, np.sin(np.pi / 3) * x))\n\nropt = dict(LatticeTruncation='Circular',\n            DiscretizedEpsilon=False,\n            DiscretizationResolution=8,\n            PolarizationDecomposition=False,\n            PolarizationBasis='Default',\n            #LanczosSmoothing=dict(Power=2, Width=1),\n            LanczosSmoothing=False,\n            SubpixelSmoothing=False,\n            ConserveMemory=False,\n            WeismannFormulation=False,\n            Verbosity=0)\n\noptions.S4_options = ropt\n\n# grating layers\ngrating = [Layer(width=si(100, 'nm'), material=SiN, geometry=[{'type': 'circle', 'mat': Ag, 'center': (0, 0),\n                                                 'radius': x/3, 'angle': 0}])] # actual grating part of grating\n\n\n# DTL device without anti-reflection coating\nsolar_cell = SolarCell([Layer(material=InGaP, width=si('20nm')),\n                        Layer(material=GaAs, width=si('85nm')),\n                        Layer(material=InAlP, width=si('20nm'))] + grating,\n                       substrate=Ag)\n\n# make RCWA structure\nS4_setup = rcwa_structure(solar_cell, size, options, Air, Ag)\n\n# calculate\n\nRAT = S4_setup.calculate(options)\n\nAbs_DTL = RAT['A_per_layer'][:,1] # absorption in GaAs\n\nR_DTL = RAT['R']\nT_DTL = RAT['T']\n\nCalculating nanophotonic grating device..."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/5a-ultrathin_GaAs_cell.html#nanophotonic-grating-device-with-arc",
    "href": "solar-cell-simulation/notebooks/5a-ultrathin_GaAs_cell.html#nanophotonic-grating-device-with-arc",
    "title": "Example 5a: Ultra-thin GaAs cell with diffraction grating",
    "section": "Nanophotonic grating device with ARC",
    "text": "Nanophotonic grating device with ARC\nThis device is exactly like the previous one, but with the additional of a simple single-layer anti-reflection coating.\n\nprint(\"Calculating nanophotonic grating device with ARC...\")\n\n# DTL device with anti-reflection coating\nsolar_cell = SolarCell([Layer(material=Al2O3, width=si('70nm')),\n                        Layer(material=InGaP, width=si('20nm')),\n                        Layer(material=GaAs, width=si('85nm')),\n                        Layer(material=InAlP, width=si('20nm'))] + grating,\n                       substrate=Ag)\n\n# make RCWA structure\nS4_setup = rcwa_structure(solar_cell, size, options, Air, Ag)\n\n# calculate\nRAT_ARC = S4_setup.calculate(options)\n\nAbs_DTL_ARC = RAT_ARC['A_per_layer'][:,2]     # absorption in GaAs + InGaP\n\nR_DTL_ARC = RAT_ARC['R']\nT_DTL_ARC = RAT_ARC['T']\n\nCalculating nanophotonic grating device with ARC..."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/5a-ultrathin_GaAs_cell.html#plotting-results",
    "href": "solar-cell-simulation/notebooks/5a-ultrathin_GaAs_cell.html#plotting-results",
    "title": "Example 5a: Ultra-thin GaAs cell with diffraction grating",
    "section": "Plotting results",
    "text": "Plotting results\nPLOT 1: Comparing the absorption in GaAs for the four different device architectures\n\n\npal = sns.color_palette(\"husl\", 4)\n\nfig = plt.figure(figsize=(6.4, 4.8))\n\nplt.plot(wavelengths*1e9, 100*Abs_onsubs, color=pal[0], label=\"On substrate\")\nplt.plot(wavelengths*1e9, 100*Abs_TMM, color=pal[1], label=\"Planar mirror\")\nplt.plot(wavelengths*1e9, 100*Abs_DTL, color=pal[2], label=\"Nanophotonic grating (no ARC)\")\nplt.plot(wavelengths*1e9, 100*Abs_DTL_ARC, color=pal[3], label=\"Nanophotonic grating (with ARC)\")\n\nplt.xlim(300, 950)\nplt.ylim(0, 100)\nplt.xlabel('Wavelength (nm)')\nplt.ylabel('EQE (%)')\nplt.legend(loc='upper left')\nplt.show()\n\n\n\n\nWe see that the addition of a planar silver mirror significantly boosts the absorption around 700 nm, essentially by creating a Fabry-Perot (thin film) cavity in the semiconductor layers through high reflection at the rear of the cell. The grating introduces multiple resonances relating to different diffraction orders and waveguide modes in the structure, which boosts the absorption especially close to the absorption edge in comparison to the planar devices.\nPLOT 2: Absorption per layer in the planar Ag device.\n\nfig = plt.figure(figsize=(6.4, 4.8))\nplt.stackplot(wavelengths*1e9,\n              [100*Abs_TMM, 100*Abs_TMM_InGaPonly, 100*Abs_TMM_InAlPonly],\n              colors=pal,\n              labels=['Absorbed in GaAs', 'Absorbed in InGaP', 'Absorbed in InAlP'])\nplt.xlim(300, 950)\nplt.ylim(0, 90)\nplt.xlabel('Wavelength (nm)')\nplt.ylabel('EQE (%)')\nplt.legend(loc='upper right')\nplt.show()\n\n\n\n\nThe plot above shows that at short wavelengths, even very thin layers (in this case, 20 nm of InGaP) can absorb a very significant fraction of the incident radiation. Depending on the device, the carriers generated here may or may not be extracted as current."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/5a-ultrathin_GaAs_cell.html#calculating-photogenerated-current",
    "href": "solar-cell-simulation/notebooks/5a-ultrathin_GaAs_cell.html#calculating-photogenerated-current",
    "title": "Example 5a: Ultra-thin GaAs cell with diffraction grating",
    "section": "Calculating photogenerated current",
    "text": "Calculating photogenerated current\nFinally, we use the photon flux in the AM0 spectrum to calculate the maximum possible achievable current for these devices.\n\nonsubs = 0.1 * q * np.trapz(Abs_onsubs*AM0, wavelengths)\nAg = 0.1 * q * np.trapz(Abs_TMM*AM0, wavelengths)\nDTL = 0.1 * q * np.trapz(Abs_DTL*AM0, wavelengths)\nDTL_ARC = 0.1 * q * np.trapz(Abs_DTL_ARC*AM0, wavelengths)\n\n\nprint('On substrate device current: %.1f mA/cm2 ' % onsubs)\nprint('Planar Ag mirror device current: %.1f mA/cm2 ' % Ag)\nprint('Nanophotonic grating (no ARC) device current: %.1f mA/cm2 ' % DTL)\nprint('Nanophotonic grating (with ARC) device current: %.1f mA/cm2 ' % DTL_ARC)\n\nOn substrate device current: 9.5 mA/cm2 \nPlanar Ag mirror device current: 13.8 mA/cm2 \nNanophotonic grating (no ARC) device current: 18.0 mA/cm2 \nNanophotonic grating (with ARC) device current: 23.0 mA/cm2 \n\n\nAs expected, simply adding a planar mirror boosts the current significantly. The addition of a nanophotonic grating gives a further boost (note that the grating we used here is optimized in terms of grating pitch (period) and dimension; not all gratings would give a boost in current, and some may even reduce performance due to e.g. parasitic absorption)."
  },
  {
    "objectID": "solar-cell-simulation/notebooks/2a-optical_constants.html",
    "href": "solar-cell-simulation/notebooks/2a-optical_constants.html",
    "title": "Example 2a: Optical constant sources",
    "section": "",
    "text": "In the first set of scripts focusing on the Si cell, we used different optical models to calculate total absorption and absorption profiles. These absorption profiles are used by the electrical models (if using the DA or PDD model). However, we didn’t discuss what actually goes into these optical models, which are the optical constants (either the complex refractive index, \\(n + i \\kappa\\) (\\(\\kappa\\) is the extinction coefficient), or equivalently the dielectric function \\(\\epsilon_1 + i \\epsilon_2\\)). In these two examples we will discuss what these values are, how to get them, and how to model them.\nfrom solcore.absorption_calculator.nk_db import download_db, search_db, create_nk_txt\nfrom solcore.absorption_calculator import calculate_rat, OptiStack\nfrom solcore.material_system import create_new_material\nfrom solcore import material\nfrom solcore import si\nfrom solcore.structure import Layer\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom os import remove\n\nimport seaborn as sns"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/2a-optical_constants.html#adding-custom-materials",
    "href": "solar-cell-simulation/notebooks/2a-optical_constants.html#adding-custom-materials",
    "title": "Example 2a: Optical constant sources",
    "section": "Adding custom materials",
    "text": "Adding custom materials\nIf we want to use a material which is not in Solcore’s database, or perhaps we want to use measured data rather than data from a literature source, we can add a material to the database. We need to have n and k data, and (optionally) a parameter file in the correct format - see examples of parameter files in e.g. material_data/Adachi/binaries.txt inside Solcore’s source files. These parameter files contain things like the bandgap, lattice constant, effective carrier masses, etc.\nHere, we create a new material, silicon-germanium-tin, from input files. Here, the parameters in SiGeSn_params.txt have been copied directly from Ge. The last argument, with the parameters file, is optional; if you exclude it the material will be added with just the n and k values and no further information specified (useful if you just want to do optical calculations).\n\ncreate_new_material('SiGeSn', 'data/SiGeSn_n.txt', 'data/SiGeSn_k.txt', 'data/SiGeSn_params.txt')\n\nWhen adding custom materials - or getting the refractive index database - the information will be stored by default in your home directory. You can change thethe SOLCORE_USER_DATA environmental variable in the config file to your prefered location or, by default, it will be in your home directory, in a (hidden) directory called .solcore.\nWe can now create an instance of it like any Solcore material:\n\nwl = si(np.arange(300, 1700, 5), 'nm')\n\nSiGeSn = material('SiGeSn')()\nGe = material('Ge')()\n\nPLOT 1: Comparing the optical constants of SiGeSn and Ge.\n\nplt.figure()\nplt.plot(wl*1e9, SiGeSn.n(wl), 'r-', label='SiGeSn n')\nplt.plot(wl*1e9, SiGeSn.k(wl), 'k-', label=r'SiGeSn $\\kappa$')\n\nplt.plot(wl*1e9, Ge.n(wl), 'r--', label='Ge n')\nplt.plot(wl*1e9, Ge.k(wl), 'k--', label=r'Ge $\\kappa$')\n\nplt.xlabel('Wavelength (nm)')\nplt.ylabel(r'SiGeSn n / $\\kappa$')\nplt.legend()\nplt.title(\"(1) Optical constants of Ge and SiGeSn\")\nplt.show()"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/2a-optical_constants.html#using-the-refractiveindex.info-database",
    "href": "solar-cell-simulation/notebooks/2a-optical_constants.html#using-the-refractiveindex.info-database",
    "title": "Example 2a: Optical constant sources",
    "section": "Using the refractiveindex.info database",
    "text": "Using the refractiveindex.info database\nSolcore can also directly interface with the database from www.refractiveindex.info, which contains around 3000 sets of \\(n\\)/\\(\\kappa\\) data for a large number of different materials. Before the first use, it is necessary to download the database. This only needs to be done once, so you can comment this line out after it’s done:\n\ndownload_db()\n\nNow we can search the database to select an appropriate entry. Search by element/chemical formula, or by the name of the author who published the data. In this case, we look for silver.\n\nsearch_db('Ag', exact=True); # semicolon suppresses additional output in Jupyter Notebook. Do not need to use.\n\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\n17 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n0   main    Ag  Johnson main/Ag/Johnson.yml 1   1   0.1879  1.937   49\n1   main    Ag  Choi    main/Ag/Choi.yml    1   1   1.231   6.988   84\n2   main    Ag  Jiang   main/Ag/Jiang.yml   1   1   0.3 2.0 1701\n3   main    Ag  Yang    main/Ag/Yang.yml    1   1   0.27    24.92   525\n4   main    Ag  McPeak  main/Ag/McPeak.yml  1   1   0.3 1.7 141\n5   main    Ag  Babar   main/Ag/Babar.yml   1   1   0.2066  12.4    69\n6   main    Ag  Wu  main/Ag/Wu.yml  1   1   0.287493    0.999308    450\n7   main    Ag  Werner  main/Ag/Werner.yml  1   1   0.017586    2.479684    150\n8   main    Ag  Stahrenberg main/Ag/Stahrenberg.yml 1   1   0.12782 0.49594 361\n9   main    Ag  Windt   main/Ag/Windt.yml   1   1   0.00236 0.12157 36\n10  main    Ag  Hagemann    main/Ag/Hagemann.yml    1   1   2.48e-06    248.0   148\n11  main    Ag  Ciesielski  main/Ag/Ciesielski.yml  1   1   0.19077 20.912  333\n12  main    Ag  Ciesielski-Ge   main/Ag/Ciesielski-Ge.yml   1   1   0.19077 20.912  333\n13  main    Ag  Ciesielski-Ni   main/Ag/Ciesielski-Ni.yml   1   1   0.19077 15.811  332\n14  main    Ag  Rakic-BB    main/Ag/Rakic-BB.yml    1   1   0.24797 12.398  200\n15  main    Ag  Rakic-LD    main/Ag/Rakic-LD.yml    1   1   0.24797 12.398  200\n16  main    Ag  Werner-DFT  main/Ag/Werner-DFT.yml  1   1   0.017586    2.479684    150\n\n\nThis prints out, line by line, matching entries. This shows us entries with “pageid”s 0 to 16 correspond to silver.\nLet’s compare the optical behaviour of some of those sources:\n\npageid = 0, Johnson\npageid = 2, Jiang\npageid = 4, McPeak\npageid = 10, Hagemann\npageid = 14, Rakic (BB)\n\n(The pageid values listed here are for the 2021-07-18 version of the refractiveindex.info database; this can change with different versions of the database)\nNow, we create instances of materials with the optical constants from the database. The name (when using Solcore’s built-in materials, this would just be the name of the material or alloy, like ‘GaAs’) is the pageid, AS A STRING, while the flag nk_db must be set to True to tell Solcore to look in the previously downloaded database from refractiveindex.info\n\nAg_Joh = material(name='0', nk_db=True)()\nAg_Jia = material(name='2', nk_db=True)()\nAg_McP = material(name='4', nk_db=True)()\nAg_Hag = material(name='10', nk_db=True)()\nAg_Rak = material(name='14', nk_db=True)()\nAg_Sol = material(name='Ag')() # Solcore built-in (from SOPRA)\n\nNow we plot the \\(n\\) and \\(\\kappa\\) data. Note that not all the data covers the full wavelength range, so the \\(n\\)/\\(\\kappa\\) value gets extrapolated from the last point in the dataset to cover any missing values.\nPLOT 2: \\(n\\) and \\(\\kappa\\) values for Ag from different literature sources\n\nnames = ['Johnson', 'Jiang', 'McPeak', 'Hagemann', 'Rakic', 'Solcore built-in']\n\nwl = si(np.arange(250, 900, 5), 'nm')\n\nplt.figure(figsize=(8,4))\n\nplt.subplot(121)\n# We can plot all the n values in one line:\nplt.plot(wl*1e9, np.array([Ag_Joh.n(wl), Ag_Jia.n(wl), Ag_McP.n(wl),\n                           Ag_Hag.n(wl), Ag_Rak.n(wl), Ag_Sol.n(wl)]).T);\nplt.legend(labels=names)\nplt.xlabel(\"Wavelength (nm)\")\nplt.title(\"(2) $n$ and $\\kappa$ values for Ag from different literature sources\")\nplt.ylabel(\"n\")\n\nplt.subplot(122)\nplt.plot(wl*1e9, np.array([Ag_Joh.k(wl), Ag_Jia.k(wl), Ag_McP.k(wl),\n                           Ag_Hag.k(wl), Ag_Rak.k(wl), Ag_Sol.k(wl)]).T)\nplt.legend(labels=names)\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"$\\kappa$\")\nplt.show()\n\nCompare performance as a back mirror on a GaAs ‘cell’; we make a solar cell-like structure with a very thin GaAs absorber (50 nm) and a silver back mirror.\nPLOT 3: compare absorption in GaAs and Ag for a solar cell-like structure, using Ag data from different sources\nSolid line: absorption in GaAs Dashed line: absorption in Ag\n\nGaAs = material('GaAs')()\n\ncolors = sns.color_palette('husl', n_colors=len(names))\n\nplt.figure()\nfor c, Ag_mat in enumerate([Ag_Joh, Ag_Jia, Ag_McP, Ag_Hag, Ag_Rak, Ag_Sol]):\n    my_solar_cell = OptiStack([Layer(width=si('50nm'), material = GaAs)], substrate=Ag_mat)\n    RAT = calculate_rat(my_solar_cell, wl*1e9, no_back_reflection=False)\n    GaAs_abs = RAT[\"A_per_layer\"][1]\n    Ag_abs = RAT[\"T\"]\n    plt.plot(wl*1e9, GaAs_abs, color=colors[c], linestyle='-', label=names[c])\n    plt.plot(wl*1e9, Ag_abs, color=colors[c], linestyle='--')\n\nplt.legend()\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"Absorbed\")\nplt.title(\"(3) Absorption in GaAs depending on silver optical constants\")\nplt.show()"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/2a-optical_constants.html#adding-refractiveindex.info-materials-to-solcores-database",
    "href": "solar-cell-simulation/notebooks/2a-optical_constants.html#adding-refractiveindex.info-materials-to-solcores-database",
    "title": "Example 2a: Optical constant sources",
    "section": "Adding refractiveindex.info materials to Solcore’s database",
    "text": "Adding refractiveindex.info materials to Solcore’s database\nFinally, we can combine the two methods above and add a material from the refractiveindex.info database to Solcore’s database.\nThe search_db function will print the search results, but it also creates a list of lists with details of all the search results. results[0] contains the first entry; results[0][0] is the ‘pageid’ of the first search result.\nThe function create_nk_txt creates files containing the optical constant data in the format required by Solcore. These are saved in the current working directory.\n\nresults = search_db('Diamond')\n\ncreate_nk_txt(pageid=results[0][0], file='C_Diamond')\n\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\n1 results found.\npageid  shelf   book    page    filepath    hasrefractive   hasextinction   rangeMin    rangeMax    points\n2897    3d  crystals    diamond main/C/Phillip.yml  1   1   0.035424054 10.0    176\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/C/Phillip.yml loaded.\nWrote C_Diamond_n.txt\nWrote C_Diamond_k.txt\n\n\nWe now use these files to create a new material in the Solcore database:\n\ncreate_new_material(mat_name='Diamond', n_source='C_Diamond_n.txt', k_source='C_Diamond_k.txt')\n\nMaterial created with optical constants n and k only.\n\n\nWe can now delete the files with the Diamond data, since they have been copied into the user-defined materials directory:\n\nremove(\"C_diamond_n.txt\")\nremove(\"C_diamond_k.txt\")\n\nNow we can use this material as we would any material from Solcore’s database:\nPLOT 4: Optical constants of diamond\n\nDiamond = material('Diamond')()\n\nplt.figure()\nplt.plot(si(np.arange(100, 800, 5), 'nm') * 1e9, Diamond.n(si(np.arange(100, 800, 5), 'nm')))\nplt.plot(si(np.arange(100, 800, 5), 'nm') * 1e9, Diamond.k(si(np.arange(100, 800, 5), 'nm')))\nplt.title(\"(4) Optical constants for diamond\")\nplt.show()"
  },
  {
    "objectID": "solar-cell-simulation/notebooks/2a-optical_constants.html#conclusions",
    "href": "solar-cell-simulation/notebooks/2a-optical_constants.html#conclusions",
    "title": "Example 2a: Optical constant sources",
    "section": "Conclusions",
    "text": "Conclusions\nSo, we have at least 4 different ways of getting optical constants:\n\nFrom Solcore’s database\nBy adding our own material data to Solcore’s database\nBy using the refractiveindex.info database directly\nSimilarly, we can add materials from the refractiveindex.info database to Solcore’s database\n\nIf we add materials to the database, we can also choose to add non-optical parameters."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/6a-TMM_introduction.html",
    "href": "solcore-workshop-2/notebooks/6a-TMM_introduction.html",
    "title": "Section 6a: Basic cell optics",
    "section": "",
    "text": "In this script, we will build on the TMM model from example 1(a) and look at the effects of interference.\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom solcore import material, si\nfrom solcore.solar_cell import Layer\nfrom solcore.absorption_calculator import calculate_rat, OptiStack\nimport seaborn as sns\n\nWARNING: The RCWA solver will not be available because an S4 installation has not been found."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/6a-TMM_introduction.html#setting-up",
    "href": "solcore-workshop-2/notebooks/6a-TMM_introduction.html#setting-up",
    "title": "Section 6a: Basic cell optics",
    "section": "Setting up",
    "text": "Setting up\nFirst, let’s define some materials:\n\nSi = material(\"Si\")\nSiN = material(\"Si3N4\")()\nAg = material(\"Ag\")()\n\nNote the second set of brackets (or lack thereof). The Solcore material system essentially operates in two stages; we first call the material function with the name of the material we want to use, for example Si = material(“Si”), which creates a general Python class corresponding to that material. We then call this class to specify further details, such as the temperature, doping level, or alloy composition (where relavant). This happens below when defining Si_n and Si_p; both are use the Si class defined above, and adding further details to the material. For the definitions of SiN and Ag above, we do both steps in a single line, hence the two sets of brackets.\n\nSi_n = Si(Nd=si(\"1e21cm-3\"), hole_diffusion_length=si(\"10um\"))\nSi_p = Si(Na=si(\"1e16cm-3\"), electron_diffusion_length=si(\"400um\"))\n\nTo look at the effect of interference in the Si layer at different thicknesses, we make a list of thicknesses to test (evenly spaced on a log scale from 400 nm to 300 um):\n\nSi_thicknesses = np.linspace(np.log(0.4e-6), np.log(300e-6), 8)\nSi_thicknesses = np.exp(Si_thicknesses)\n\nwavelengths = si(np.linspace(300, 1200, 400), \"nm\")\n\noptions = {\n    \"recalculate_absorption\": True,\n    \"optics_method\": \"TMM\",\n    \"wavelength\": wavelengths\n           }\n\nMake a color palette using the seaborn package to make the plots look nicer\n\ncolors = sns.color_palette('rocket', n_colors=len(Si_thicknesses))\ncolors.reverse()\n\ncreate an ARC layer:\n\nARC_layer = Layer(width=si('75nm'), material=SiN)"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/6a-TMM_introduction.html#effect-of-si-thickness",
    "href": "solcore-workshop-2/notebooks/6a-TMM_introduction.html#effect-of-si-thickness",
    "title": "Section 6a: Basic cell optics",
    "section": "Effect of Si thickness",
    "text": "Effect of Si thickness\nNow we are going to loop through the different Si thicknesses generated above, and create a simple solar cell-like structure. Because we will only do an optical calculation, we don’t need to define a junction and can just make a simple stack of layers.\nWe then calculate reflection, absorption and transmission (RAT) for two different situations: 1. a fully coherent stack 2. assuming the silicon layer is incoherent. This means that light which enters the Si layer cannot interfere with itself, but light in the ARC layer can still show interference. In very thick layers (much thicker than the wavelength of light being considered) this is likely to be more physically accurate because real light does not have infinite coherence length; i.e. if you measured wavelength-dependent transmission or reflection of a Si wafer hundreds of microns thick you would not expect to see interference fringes.\nPLOT 1\n\nplt.figure()\n\nfor i1, Si_t in enumerate(Si_thicknesses):\n\n    base_layer = Layer(width=Si_t, material=Si_p) # silicon layer\n    solar_cell = OptiStack([ARC_layer, base_layer]) # OptiStack (optical stack) to feed into calculate_rat function\n\n    # Coherent calculation:\n    RAT_c = calculate_rat(solar_cell, wavelengths*1e9, no_back_reflection=False) # coherent calculation\n    # For historical reasons, Solcore's default setting is to ignore reflection at the back of the cell (i.e. at the\n    # interface between the final material in the stack and the substrate). Hence we need to tell the calculate_rat\n    # function NOT to ignore this reflection (no_back_reflection=False).\n\n    # Calculation assuming no interference in the silicon (\"incoherent\"):\n    RAT_i = calculate_rat(solar_cell, wavelengths*1e9, no_back_reflection=False,\n                          coherent=False, coherency_list=['c', 'i']) # partially coherent: ARC is coherent, Si is not\n\n    # Plot the results:\n    plt.plot(wavelengths*1e9, RAT_c[\"A\"], color=colors[i1], label=str(round(Si_t*1e6, 1)), alpha=0.7)\n    plt.plot(wavelengths*1e9, RAT_i[\"A\"], '--', color=colors[i1])\n\nplt.legend(title=r\"Thickness ($\\mu$m)\")\nplt.xlim(300, 1300)\nplt.ylim(0, 1.02)\nplt.ylabel(\"Absorption\")\nplt.title(\"(1) Absorption in Si with varying thickness\")\nplt.show()\n\n\n\n\nWe can see that the coherent calculations (solid lines) show clear interference fringes which depend on the Si thickness. The incoherent calculations do not have these fringes and seem to lie around the average of the interference fringes. For both sets of calculations, we see increasing absorption as the Si gets thicker, as expected."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/6a-TMM_introduction.html#effect-of-reflective-substrate",
    "href": "solcore-workshop-2/notebooks/6a-TMM_introduction.html#effect-of-reflective-substrate",
    "title": "Section 6a: Basic cell optics",
    "section": "Effect of reflective substrate",
    "text": "Effect of reflective substrate\nNow we repeat the calculation, but with an Ag substrate under the Si. Previously, we did not specify the substrate and so it was assumed by Solcore to be air (\\(n\\) = 1, \\(\\kappa\\) = 0).\nPLOT 2\n\nplt.figure()\n\nfor i1, Si_t in enumerate(Si_thicknesses):\n\n    base_layer = Layer(width=Si_t, material=Si_p)\n\n    # As before, but now we specify the substrate to be silver:\n    solar_cell = OptiStack([ARC_layer, base_layer], substrate=Ag)\n\n    RAT_c = calculate_rat(solar_cell, wavelengths*1e9, no_back_reflection=False)\n    RAT_i = calculate_rat(solar_cell, wavelengths*1e9, no_back_reflection=False,\n                          coherent=False, coherency_list=['c', 'i'])\n    plt.plot(wavelengths*1e9, RAT_c[\"A\"], color=colors[i1],\n             label=str(round(Si_t*1e6, 1)), alpha=0.7)\n    plt.plot(wavelengths*1e9, RAT_i[\"A\"], '--', color=colors[i1])\n\nplt.legend(title=r\"Thickness ($\\mu$m)\")\nplt.xlim(300, 1300)\nplt.ylim(0, 1.02)\nplt.ylabel(\"Absorption\")\nplt.title(\"(2) Absorption in Si with varying thickness (Ag substrate)\")\nplt.show()\n\n\n\n\nWe see that the interference fringes get more prominent in the coherent calculation, due to higher reflection at the rear Si/Ag surface compared to Ag/Air. We also see a slightly boosted absorption at long wavelengths at all thicknesses, again due to improved reflection at the rear surface"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/6a-TMM_introduction.html#effect-of-polarization-and-angle-of-incidence",
    "href": "solcore-workshop-2/notebooks/6a-TMM_introduction.html#effect-of-polarization-and-angle-of-incidence",
    "title": "Section 6a: Basic cell optics",
    "section": "Effect of polarization and angle of incidence",
    "text": "Effect of polarization and angle of incidence\nFinally, we look at the effect of incidence angle and polarization of the light hitting the cell.\nPLOT 3\n\nangles = [0, 30, 60, 70, 80, 89] # angles in degrees\n\nARC_layer = Layer(width=si('75nm'), material=SiN)\nbase_layer = Layer(width=si(\"100um\"), material=Si_p)\n\ncolors = sns.cubehelix_palette(n_colors=len(angles))\n\nplt.figure()\n\nfor i1, theta in enumerate(angles):\n\n    solar_cell = OptiStack([ARC_layer, base_layer])\n\n    RAT_s = calculate_rat(solar_cell, wavelengths*1e9, angle=theta,\n                          pol='s',\n                          no_back_reflection=False,\n                          coherent=False, coherency_list=['c', 'i'])\n    RAT_p = calculate_rat(solar_cell, wavelengths*1e9, angle=theta,\n                          pol='p',\n                          no_back_reflection=False,\n                          coherent=False, coherency_list=['c', 'i'])\n\n    plt.plot(wavelengths*1e9, RAT_s[\"A\"], color=colors[i1], label=str(round(theta)))\n    plt.plot(wavelengths*1e9, RAT_p[\"A\"], '--', color=colors[i1])\n\nplt.legend(title=r\"$\\theta (^\\circ)$\")\nplt.xlim(300, 1300)\nplt.ylim(0, 1.02)\nplt.ylabel(\"Absorption\")\nplt.title(\"(3) Absorption in Si with varying angle of incidence\")\nplt.show()\n\n\n\n\nFor normal incidence (\\(\\theta = 0^\\circ\\)), s (solid lines) and p (dashed lines) polarization are equivalent. As the incidence angle increases, in general absorption is higher for p-polarized light (due to lower reflection). Usually, sunlight is modelled as unpolarized light, which computationally is usually done by averaging the results for s and p-polarized light."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/6a-TMM_introduction.html#conclusions",
    "href": "solcore-workshop-2/notebooks/6a-TMM_introduction.html#conclusions",
    "title": "Section 6a: Basic cell optics",
    "section": "Conclusions",
    "text": "Conclusions\nWe have now seen some effects of interference in layers of different thicknesses, and seen the effect of adding a highly reflective substrate. So we already have two strategies for light-trapping/improving the absorption in a solar cell: adding an anti-reflection coating (in example 1a), to reduce front-surface reflection and get more light into the cell, and adding a highly reflective layer at the back, to reduce loss through the back of the cell and keep light trapped in the cell."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/6a-TMM_introduction.html#questions",
    "href": "solcore-workshop-2/notebooks/6a-TMM_introduction.html#questions",
    "title": "Section 6a: Basic cell optics",
    "section": "Questions",
    "text": "Questions\n\nWhy are the interference fringes stronger when adding a silver back mirror, compared to having air behind the Si?\nWe modelled s and p-polarized light - how do we normally model unpolarized light?"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/2-Efficiency_limits.html",
    "href": "solcore-workshop-2/notebooks/2-Efficiency_limits.html",
    "title": "Section 2: Integration for limiting current, limiting voltage model, efficiency limit",
    "section": "",
    "text": "Tuesday 1 August 2023"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/2-Efficiency_limits.html#trivich-flinn-efficiency-limit",
    "href": "solcore-workshop-2/notebooks/2-Efficiency_limits.html#trivich-flinn-efficiency-limit",
    "title": "Section 2: Integration for limiting current, limiting voltage model, efficiency limit",
    "section": "Trivich-Flinn Efficiency limit",
    "text": "Trivich-Flinn Efficiency limit\nIn 1955 Trivich & Flinn published a model for limiting efficiency. The limit it produces is too high, but it represents a good place to start with a computer model.\nTrivich D, Flinn PA. Maximum efﬁciency of solar energy conversion by quantum processes. In Solar Energy Research, Daniels F, Dufﬁe J (eds). Thames and Hudson: London, 1955.\nTrivich & Flinn assumed that the ideal solar cell would absorb all photons with energy above the band-gap energy \\(E_g\\) and that the maximum voltage that could ever be attained in a solar cell is the band-gap energy. The latter assumption is incorrect unless the solar cell is operating at absolute zero temperature.\nTo develop a model for the Trivich & Flinn efficiency limit the first step is to calculate what the limit to the photocurrent is in a solar cell."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/2-Efficiency_limits.html#limits-to-the-short-circuit-current",
    "href": "solcore-workshop-2/notebooks/2-Efficiency_limits.html#limits-to-the-short-circuit-current",
    "title": "Section 2: Integration for limiting current, limiting voltage model, efficiency limit",
    "section": "Limits to the short-circuit current",
    "text": "Limits to the short-circuit current\n\nSolar Spectrum\nThe solar spectrum defines the ultimate current that a solar cell can produce. First we will plot the AM1.5G solar spectrum \\(b(\\lambda)\\) as a spectral irradiance, meaning that the y-axis has units of \\(W.m^{-2}.nm^{-1}\\)\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom solcore.light_source import LightSource\nimport seaborn as sns\n\n# Setup the AM1.5G solar spectrum\nwl = np.linspace(300, 4000, 4000) * 1e-9    # wl contains the x-coordinate in wavelength\nam15g = LightSource(source_type='standard', x=wl*1e9, version='AM1.5g',\n                    output_units=\"power_density_per_nm\")\n\nplt.figure()\nplt.title('Spectral Irradiance')\nplt.plot(*am15g.spectrum(wl*1e9), label='AM1.5G')\nplt.xlim(300, 3000)\nplt.xlabel('Wavelength (nm)')\nplt.ylabel('Power density (Wm$^{-2}$nm$^{-1}$)')\nplt.legend()\n\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\n\n\n&lt;matplotlib.legend.Legend at 0x175783150&gt;\n\n\n\n\n\nLet us now integrate the solar spectrum to provide the total irradiance in units of [\\(W.m^{-2}\\)]. The code below performs the following operation \\(b=\\int^{\\infty}_{0} b(\\lambda) d\\lambda\\)\n\n# Since .spectrum function returns a tuple (x,y) but np.trapz requires data in format (y,x) these are extracted into separate 1D np arrays.\nyval = am15g.spectrum()[1]\nxval = am15g.spectrum()[0]\nintegrated_value = np.trapz(yval,xval)  # Perform integration using trapezium rule\nb = integrated_value  # Save the integrated power density for the sun for later.\nprint('b = ', integrated_value)\n\nb =  1000.3974821197136\n\n\nLet’s take the opportunity to learn how to format numbers nicely in Python. Here we use the command “%.0f” % to display the value to zero decimal places.\n\nprint('b = ',\"%.0f\" % integrated_value,\"W.m-2\")\n\nb =  1000 W.m-2\n\n\nSolcore performs this integration for us internally. Let’s try the same exercise but for the extraterrestrial solar spectrum, AM0\n\nam0 = LightSource(source_type='standard', x=wl*1e9, version='AM0')\nprint(\"AM0 integrates to\", \"%.0f\" % am0.power_density, \"W.m-2\")\n\nAM0 integrates to 1348 W.m-2\n\n\n\n\nSpectral Photon Flux\nTo calculate a short-circuit current it is convenient to change the units. Two changes are necessary : 1. Since we specify band-gap energies in electron volts (eV) we need to transform the x-axis from nm to eV 2. Photocurrent is proportional to the incident photon flux (number of photons per second) not the irradiance (watts) so we need to convert the y-axis from energy to photon number.\nNote: The conversion is performed internally within the software but be aware that because the transformation from wavelength is non-linear, changing the x-axis from nm to eV also changes the y-values of the data. This is known as a Jacobian transformation and discussed in more detail in an article “Getting the basics right: Jacobian Conversion of Wavelength and Energy Scales for Quantatitive Analysis of Emission Spectra”, Journal of Physical Chemistry, 4(19) 3316 (2013)\n\nev = np.linspace(0.02,4,4000)\nflux = LightSource(source_type='standard', version='AM1.5g', x=ev, output_units='photon_flux_per_ev')\n\nplt.figure()\nplt.title('Spectral Photon Flux')\nplt.plot(*flux.spectrum(), label='AM1.5G')\nplt.xlim(0.2, 4)\nplt.xlabel('Photon Energy (eV)')\nplt.ylabel('Photon flux N ($ph.s^{-1}m^{-2}eV^{-1}$)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x177da5050&gt;\n\n\n\n\n\n\n\nCalculating the short-circuit current\nIntegrating the photon flux can provide an upper limit to the short-circuit current [A.m-2]. We can integrate the spectrum over the entire spectral range using \\(J_{sc}=q\\int_{0}^{\\infty}N(E)dE\\)\n\nq = 1.60217662E-19\nyval = flux.spectrum()[1]\nxval = flux.spectrum()[0]\nyint = q*np.trapz(yval,xval)  # Perform integration using trapezium rule\n\nprint(\"%.0f\" % yint)\n\n690\n\n\nA more useful calculation is to calculate the current that a solar cell would produce with a particular band-gap energy. To do this requires a bit more coding, since we now wish to integrate between limits: \\(J_{sc}=q\\int_{Eg}^{\\infty}N(E)dE\\)\nLet’s do this for a band-gap of 1.42 eV:\n\nq = 1.60217662E-19\neg = 1.42\nyval = flux.spectrum()[1]\nxval = flux.spectrum()[0]\n\nyval[xval &lt; eg] = 0 # set photon flux to zero for photon energies below the band-gap\n\nyint = q*np.trapz(yval,xval)  # Perform integration using trapezium rule\n\nprint(\"%.0f\" % yint)\n\n321\n\n\nLet’s reproduce the \\(J_{sc}\\) vs \\(E_g\\) graph that is shown on p. 87 of Martin Green’s Solar Cells book:\n\nq = 1.60217662E-19\n\ndef getJsc(eg):\n    yval = flux.spectrum()[1]  # Start with the solar spectrum in yval & xval\n    xval = flux.spectrum()[0]\n    yval[xval &lt; eg] = 0 # set photon flux to zero for photon energies below the band-gap\n    return q*np.trapz(yval,xval)  # return the integrated value\n\neg = np.linspace(0.5,2.5,100)\njsc = np.vectorize(getJsc)(eg)\n\nplt.figure()\nplt.title('Limit to the short-circuit current $J_{sc}$')\nplt.plot(eg, jsc/10, label='AM1.5G')  # Divide by 10 to convert from A.m^-2 to mA.cm^-2\nplt.xlim(0.5, 2.5)\nplt.xlabel('Band Gap energy (eV)')\nplt.ylabel('$J_{sc}$ ($mA.cm^{-2}$)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x177dde090&gt;\n\n\n\n\n\n\n\nCalculating the Trivich-Flinn Efficiency limit\nNow that the limit to \\(J_{sc}\\) is known, we can estimate the power of delivered by the solar cell by evaluating \\(\\frac{Eg J_{sc}}{b}\\)\n\nplt.figure()\nplt.title('Trivich-Flinn Single Junction Efficiency Limit')\nplt.plot(eg, 100*eg*jsc/b,label='AM1.5G')  # Divide by 10 to convert from A.m^-2 to mA.cm^-2\nplt.xlim(0.5, 2.5)\nplt.xlabel('Band Gap energy (eV)')\nplt.ylabel('Efficiency (%)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x177edb150&gt;"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/2-Efficiency_limits.html#the-shockley-queisser-efficiency-limit",
    "href": "solcore-workshop-2/notebooks/2-Efficiency_limits.html#the-shockley-queisser-efficiency-limit",
    "title": "Section 2: Integration for limiting current, limiting voltage model, efficiency limit",
    "section": "The Shockley-Queisser Efficiency limit",
    "text": "The Shockley-Queisser Efficiency limit\nShockley & Queisser refined the Trivich-Flinn limit by linking the voltage a solar cell can deliver to the Fermi level separation in the conduction and valance bands, not the band-gap energy.\nTo do this, a model is required for the recombination processes between the conduction and valance bands. The most fundamental (and inescapable) recombination mechanism is the radiative process. In section 3 we will derive a limit to Shockley’s diode equation \\(J=J_0 e^{\\frac{V}{kT}}\\) for the radiative limit, that being a diode where all current flows are linked to an optical process, either absorption or recombination.\nIn the radiative limit and an abrupt band-edge at band-gap energy \\(E_g\\) it can be shown that \\(J_0\\) is approximated by \\(J_0=q \\frac{2 \\pi}{c^2 h^3} kT \\left(E_g^2+2 E_g k T+2 k^2 T^2\\right) e^{\\frac{-E_g}{k T}}\\)\nWe can now plot a chart of \\(J_0\\) as a function of band-gap energy using this expression:\n\n# Define some physical constants:\nq = 1.60217662E-19  # electronic charge [C]\nk = 1.38064852E-23/q   # Boltzmann constant [eV/K]\nh = 6.62607004E-34/q  # Planck constant expressed in [eV.s]\nc = 299792458  # Speed of light [m.s^-1]\n\nt = 300  # Perform the calculation for a solar cell at 300K.\n\n# Define a function to return J0 implementing the expression above\ndef getJ0(eg):\n    return k*t*q*(2*np.pi/(c**2*h**3))*(eg**2+2*eg*k*t+2*k**2*t**2)*np.exp(-eg/(k*t))\n\neg = np.linspace(0.5,2.5,100)\nj0 = np.vectorize(getJ0)(eg)\n\nplt.figure()\nplt.title('The radiative limit to $J_0$ plotted as a function of band-gap energy Eg')\nplt.plot(eg,j0,label='J0')  # Divide by 10 to convert from A.m^-2 to mA.cm^-2\nplt.xlim(0.2, 2.5)\nplt.xlabel('Band Gap energy (eV)')\nplt.ylabel('$J_{0}$ ($A.m^{-2}$)')\nplt.yscale(\"log\")\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x177f1ccd0&gt;\n\n\n\n\n\nLet’s obtain J0 for GaAs and InGaP, two common III-V materials that are used in tandem solar cells: evaluate getJ0() for Eg=1.42 and Eg=1.88\n\ngetJ0(1.42)\n\n1.195457897843886e-17\n\n\n\ngetJ0(1.88)\n\n3.888154629395649e-25"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/2-Efficiency_limits.html#calculating-the-iv-curve",
    "href": "solcore-workshop-2/notebooks/2-Efficiency_limits.html#calculating-the-iv-curve",
    "title": "Section 2: Integration for limiting current, limiting voltage model, efficiency limit",
    "section": "Calculating the IV curve",
    "text": "Calculating the IV curve\nWe are now able to calculate the limiting efficiency for a solar cell using the simple Shockley diode expression \\(J(V)=J_{s c}-J_0\\left(e^{\\frac{q V}{k T}}-1\\right)\\). Let’s plot the IV curve for a band-gap of 1.42eV\n\ndef getJ(v,eg):\n    return getJsc(eg) - getJ0(eg)*(np.exp(v/(k*t)) - 1)\n\neg = 1.42\nv = np.linspace(0,1.2,100)\nj = np.vectorize(getJ)(v,eg)\n\nplt.figure(3)\nplt.title('Limiting Efficiency IV curve for Eg=1.42eV (GaAs)')\nplt.plot(v,j/10)  #convert to mA.cm^-2\nplt.xlim(0.2, 1.2)\nplt.ylim(0,35)\nplt.xlabel('Voltage (V)')\nplt.ylabel('Current ($mA.cm^{-2}$)')\n\nText(0, 0.5, 'Current ($mA.cm^{-2}$)')"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/2-Efficiency_limits.html#calculating-the-electrical-power-curve-and-finding-the-maximum-power",
    "href": "solcore-workshop-2/notebooks/2-Efficiency_limits.html#calculating-the-electrical-power-curve-and-finding-the-maximum-power",
    "title": "Section 2: Integration for limiting current, limiting voltage model, efficiency limit",
    "section": "Calculating the electrical power curve and finding the maximum power",
    "text": "Calculating the electrical power curve and finding the maximum power\n\nplt.figure()\nplt.title('Limiting Efficiency power curve for $E_g$ = 1.42 eV (GaAs)')\nplt.plot(v,v*j)\nplt.xlim(0.2, 1.2)\nplt.ylim(0,350)\nplt.xlabel('Voltage (V)')\nplt.ylabel('Power ($W.m^{-2}$)')\n\nText(0, 0.5, 'Power ($W.m^{-2}$)')\n\n\n\n\n\nDefine a function to find the maximum power point of the curve above:\n\ndef getPmax(eg):\n    v = np.linspace(0,eg-0.1,500)\n    p = v*np.vectorize(getJ)(v,eg)\n    return (np.amax(p))  # The amax command returns the maximum value in the array p\n\nTest it out on the curve above\n\ngetPmax(1.42)\n\n331.6412760959975\n\n\n\nPlotting the Shockley-Queisser efficiency limit graph:\nFinally we can calculate the Shockley-Queisser efficiency limit for AM1.5G\n\neg = np.linspace(0.5,2.5,100)\np = np.vectorize(getPmax)(eg)\n\nplt.figure(3)\nplt.title('Limiting Shockley-Queisser Efficiency Curve')\nplt.plot(eg, p/b, label='AM1.5G')  # Remember b is the integrated power of the\n# incident sunlight\nplt.xlim(0.2, 2.5)\nplt.xlabel('Band Gap energy (eV)')\nplt.ylabel('Efficiency (%)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x298214750&gt;"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/2-Efficiency_limits.html#an-easier-way-using-solcore",
    "href": "solcore-workshop-2/notebooks/2-Efficiency_limits.html#an-easier-way-using-solcore",
    "title": "Section 2: Integration for limiting current, limiting voltage model, efficiency limit",
    "section": "An easier way – using Solcore!",
    "text": "An easier way – using Solcore!\nThe Solcore library has all the functions we have written above built into it. We worked through this example step by step, but we can calculate the same result using the code below. First let’s calculate an IV curve for a Shockley-Queisser solar cell with a band-gap of 1.42eV:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom solcore.light_source import LightSource\nfrom solcore.solar_cell import SolarCell\nfrom solcore.solar_cell_solver import solar_cell_solver\nfrom solcore.structure import Junction\n\n# Load the AM1.5G solar spectrum\nwl = np.linspace(300, 4000, 4000) * 1e-9    # wl contains the x-coordinate in wavelength\nam15g = LightSource(source_type='standard', x=wl, version='AM1.5g')\n\neg = 1.42\nV = np.linspace(0, 1.3, 500)\ndb_junction = Junction(kind='DB', T=300, Eg=eg, A=1, R_shunt=np.inf, n=1) #\n# detailed-balance junction (Shockley-Queisser limit)\n\nmy_solar_cell = SolarCell([db_junction], T=300, R_series=0)\n\nsolar_cell_solver(my_solar_cell, 'iv',\n                      user_options={'T_ambient': 300, 'db_mode': 'top_hat', 'voltages': V, 'light_iv': True,\n                                    'internal_voltages': np.linspace(0, 1.3, 400), 'wavelength': wl,\n                                    'mpp': True, 'light_source': am15g})\n\nplt.figure()\nplt.title('Limiting Efficiency IV curve for $E_g$ = 1.42eV')\nplt.plot(V, my_solar_cell.iv.IV[1], 'k')\nplt.ylim(0, 350)\nplt.xlim(0, 1.2)\nplt.text(0.1,300,f'Jsc: {my_solar_cell.iv.Isc:.2f}')\nplt.text(0.1,280,f'Voc: {my_solar_cell.iv.Voc:.2f}')\nplt.text(0.1,260,f'Pmax: {my_solar_cell.iv.Pmpp:.2f}')\nplt.xlabel('Voltage (V)')\nplt.ylabel('Current (A/m$^2$)')\nplt.show()\n\n/Users/z3533914/.pyenv/versions/3.11.5/lib/python3.11/site-packages/solcore/registries.py:73: UserWarning: Optics solver 'RCWA' will not be available. An installation of S4 has not been found.\n  warn(\n\n\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\n\n\n\n\n\nThe Shockley-Queisser efficiency calculation can now be performed over a range of band-gap energies. To do this, we make a function that calculates the maximum power Pmax as a function of band-gap energy.\n\n%%capture\n# A command that prevents the screen from filling up with unnecessary working\n\n# Function that returns the maximum power for a Shockley-Queisser solar cell with band-gap Eg\ndef getPmax(eg):\n    V = np.linspace(0, eg-0.1, 500)\n    db_junction = Junction(kind='DB', T=300, Eg=eg, A=1, R_shunt=np.inf, n=1)\n    my_solar_cell = SolarCell([db_junction], T=300, R_series=0)\n\n    solar_cell_solver(my_solar_cell, 'iv',\n                      user_options={'T_ambient': 300, 'db_mode': 'top_hat', 'voltages': V, 'light_iv': True, 'wavelength': wl,\n                                    'mpp': True, 'light_source': am15g})\n    return(my_solar_cell.iv.Pmpp)\n\n# Define the range of band-gaps to perform the calculation over\neg=np.linspace(0.5,2.5,100)\n# Perform the claculation for all values of eg\np=np.vectorize(getPmax)(eg)\n\nNow let’s plot the result:\n\nplt.figure()  # Plot the results calculated above:\nplt.title('Shockley-Queisser Limiting Efficiency for Unconentrated Sunlight')\nplt.plot(eg, p/am15g.power_density,label='AM1.5G')\nplt.xlim(0.5, 2.5)\nplt.xlabel('Band Gap energy (eV)')\nplt.ylabel('Efficiency (%)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x2981fe210&gt;\n\n\n\n\n\n\nEffect of solar concentration on a Shockley-Queisser Solar Cell\nIn a Trivich-Flinn model for a solar cell, concentrated sunlight is only expected to increase the current of a solar cell, not the voltage. In that model the current would increase in proportion with the concentration so the efficiency of the solar cell would be unchanged.\nIn the Shockley-Queisser model, concentrated sunlight increased both the current and the voltage of the solar cell which, in the absence of series resistance losses, leads to an increase in the efficiency of the solar cell. Here we calculate the Shockley-Queisser efficiency at different solar concentrations under the direct solar spectrum AM1.5D:\n\n%%capture\n\n# Set up a series of AM1.5D solar spectra at different concentrations\nwl = np.linspace(300, 4000, 4000) * 1e-9    #wl contains the x-ordinate in wavelength\nam15d1x = LightSource(source_type='standard', x=wl, version='AM1.5d', concentration=1)\nam15d30x = LightSource(source_type='standard', x=wl, version='AM1.5d', concentration=30)\nam15d1000x = LightSource(source_type='standard', x=wl, version='AM1.5d',\n                         concentration=1000)\n\n#Define a function to find Pmax for a particular band-gap energy and solar spectrum\ndef getPmax(eg,spectrum):\n    V = np.linspace(0, eg-0.1, 500)\n    db_junction = Junction(kind='DB', T=300, Eg=eg, A=1, R_shunt=np.inf, n=1)\n    my_solar_cell = SolarCell([db_junction], T=300, R_series=0)\n\n    solar_cell_solver(my_solar_cell, 'iv',\n                      user_options={'T_ambient': 300, 'db_mode': 'top_hat', 'voltages': V, 'light_iv': True, 'wavelength': wl,\n                                    'mpp': True, 'light_source': spectrum})\n    return my_solar_cell.iv.Pmpp\n\n# Evaluate the Pmax function for band-gaps spanning 0.8 to 1.6eV and concentrations 1x,30x,1000x\neg = np.linspace(0.8,1.6,100)\np1x = np.vectorize(getPmax)(eg, am15d1x)\np30x = np.vectorize(getPmax)(eg, am15d30x)\np1000x = np.vectorize(getPmax)(eg, am15d1000x)\n\n\n# Setup a figure for dual y-axes\nfig, ax = plt.subplots(1)\n\n# Plot the SQ curves\ncolors = sns.color_palette('husl', n_colors=3)\nax.plot(eg, 100*p1x/am15d1x.power_density,label='$\\eta$ @ AM1.5d 1x', color=colors[0])\nax.axvline(eg[np.argmax(p1x)], color=colors[0])\n\nax.plot(eg, 100*p30x/am15d30x.power_density,label='$\\eta$ @ AM1.5d 30x', color=colors[1])\nax.axvline(eg[np.argmax(p30x)], color=colors[1])\n\nax.plot(eg, 100*p1000x/am15d1000x.power_density,label='$\\eta$ @ AM1.5d 1000x', color=colors[2])\nax.axvline(eg[np.argmax(p1000x)], color=colors[2])\n\n# Define the second y-axis and plot the photon flux in units of eV\nax2 = ax.twinx()\nax2.plot(eg, am15d1x.spectrum(x=eg, output_units=\"photon_flux_per_ev\")[1],\n         '--', color='grey', label=\"AM1.5d\")\n\nax.set_xlim(0.8, 1.6)\nax.set_xlabel('Band Gap energy (eV)')\nax.set_ylabel('Efficiency (%)')\nax2.set_ylabel(r'Photon flux (s$^{-1}$ m$^{-2}$ eV$^{-1}$)')\nax.legend()\nax2.legend()\n\n&lt;matplotlib.legend.Legend at 0x2bf13f050&gt;\n\n\n\n\n\nThe maximum band-gap energy moves to lower energies with increaseing solar concentration. This arises since although the current increases with increasing solar concentration, the cell voltage also increases which means the optimal effiicency is obtained at lower band-gaps. However, the drop in band-gap energy is modest owing to a strong atmospheric absorption feature at 1.1um which serves to pin the optimum bandgap around 1.12eV.\n\n\nExercise: Concentrated AM0\nTry repeating the example above but use the AM0 extraterrestial spectrum. Observe what happens to the band-gap shift with increasing concentration. How is it different to AM1.5d?"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/3-IV_fitting.html",
    "href": "solcore-workshop-2/notebooks/3-IV_fitting.html",
    "title": "Fitting IV data using Shockley’s Diode Equation",
    "section": "",
    "text": "We have seen how we can calculate the radiative limits to solar cell efficiency. Let us now tackle the problem from the opposite direction and fit data to an empirical 2-diode model\n$ J= J_{}-J_{01}-J_{02}-(V+J R_s) / R_{}$\nWhere \\(J_{01}\\) is the diode saturation current with ideality \\(n_1\\), \\(J_{02}\\) is the diode satudation current with ideality \\(n_2\\), \\(R_s\\) is the lumped series resistance and \\(R_{sh}\\) is the shunt resistance.\nThe diode ideality factors are sometimes used as free parameters when fitting IV data. Here we choose to assign specific values so provide physical meaning to the \\(J_0\\) values. Setting \\(n_1=1\\) means \\(J_01\\) accounts for all radiative processes throughout the device and non-radiative processes in the neutral regions of the device, including surface recombination. Setting \\(n_2=2\\) approximates Shockley-Read-Hall recombination in the space-charge-region of the junction where the electron and hole carrier densities are similar."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/3-IV_fitting.html#fitting-iv-data",
    "href": "solcore-workshop-2/notebooks/3-IV_fitting.html#fitting-iv-data",
    "title": "Fitting IV data using Shockley’s Diode Equation",
    "section": "Fitting IV data",
    "text": "Fitting IV data\nImagine you have measured some dark IV data and light IV data and wish to analyse it. Here we take data from this publication Tobin, SP, Vernon, SM, Bajgar, C, Wojtczuk, SJ, Melloch, MR, Keshavarzi, A, Stellwag, TB, Venkatensan, S, Lundstrom, MS, & Emery, KA. ’Assessment of MOCVD-grown and MBE-Grown GaAs for High-Efficiency Solar-Cell Applications’. IEEE Transactions on Electron Devices, 37(2) (1990) 469\nFirst let’s plot the data reported by Tobin et al., for sample 1552-3-5\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom pathlib import Path\n\ndef this_dir_file(f):\n    file_path = Path.cwd()\n    return file_path / \"data\" /  f\n\n# Load the light-IV data\nlivData = np.loadtxt(this_dir_file(\"gaas_lightiv.csv\"), unpack=True, delimiter=\",\")\n# Load the dark-IV data\ndivData = np.loadtxt(this_dir_file(\"gaas_darkiv.csv\"), unpack=True, delimiter=\",\")\n\nplt.figure(1)\nplt.semilogy(divData[0],divData[1],'o',color=\"red\", label='Data')\nplt.title('Dark-IV for Spire cell 1552-3-5')\nplt.xlabel('Voltage / V')\nplt.ylabel('Current / $mA.cm^{-2}$')\nplt.show()\n\nplt.figure(2)\nplt.plot(livData[0],livData[1],'o',color=\"red\")\nplt.title('Light-IV for Spire cell 1552-3-5')\nplt.xlabel('Voltage / V')\nplt.ylabel('Current / mA')\nplt.text(-0,5,'Sample=1552-3-5')\nplt.text(-0,4,'Area=$0.25cm^{-2}$')\nplt.show()\n\nSecond, let us fit the dark current for the solar cell. To do this weconstruct a 2-diode (2D) model for this cell using the 2D junction model.\n\nfrom solcore.solar_cell import SolarCell\nfrom solcore.solar_cell_solver import solar_cell_solver\nfrom solcore.structure import Junction\n\n# Units for j0 values are A.m-2\ngaas_junction = Junction(kind='2D', T=300, n1=1,n2=2, jref=300,  j01=1.3e-19*1E4,j02=5.82E-12*1E4, R_series=0.000000012, R_shunt=1500000.0,jsc=1E-10)\n\nV = np.linspace(0.2, 1.2, 300)\n\ngaas_solar_cell = SolarCell([gaas_junction], T=300)\n\nsolar_cell_solver(gaas_solar_cell, 'iv',\nuser_options={'T_ambient': 300, 'db_mode': 'top_hat', 'voltages': V, 'light_iv': True,\n            'internal_voltages': np.linspace(-1, 1.2, 1100),\n            'mpp': True})\n\nplt.figure(1)\nplt.semilogy(divData[0],divData[1],'o',color=\"red\", label='Data')\nplt.semilogy(V, -gaas_solar_cell.iv['IV'][1],label='model')\nplt.title('Dark-IV for Spire cell 1552-3-5')\nplt.xlabel('Voltage / V')\nplt.ylabel('Current / $mA.cm^{-2}$')\nplt.legend()\nplt.show()\n\n\nFitting the Light-IV\nJ01 and J02 and resistance values have been estimated from the dark-IV. Now check to see if they are consistent with the light-IV. We just change the jsc value to the stated 27.8\\(mA.cm^{-2}\\).\nWe extract the Jsc, Voc and FF from the fitted data.\n\n# All parameters are entered in units of A & m-2\ngaas_junction = Junction(kind='2D', T=300, n1=1,n2=2, jref=300,  j01=1.3e-19*1E4,j02=5.82E-12*1E4, R_series=0.000000012, R_shunt=1500000.0,jsc=278.9)\n\ngaas_solar_cell = SolarCell([gaas_junction], T=300)\n\nsolar_cell_solver(gaas_solar_cell, 'iv',\nuser_options={'T_ambient': 300, 'db_mode': 'top_hat', 'voltages': V, 'light_iv': True,\n            'internal_voltages': np.linspace(-1, 1.1, 1100),\n            'mpp': True})\n\nplt.figure(1)\nplt.plot(livData[0],livData[1],'o',color=\"red\",label='data')\nplt.plot(V, gaas_solar_cell.iv['IV'][1]/40,label='model')  # divide by 10 to convert A/m2 to mA/cm2 and by 4 to account for 0.25cm2 device area\nplt.ylim(-4,8)\nplt.title('Spire GaAs global $1000W/m^{2}$')\nplt.xlabel('Voltage / V')\nplt.ylabel('Current / mA')\nplt.text(0,5.6,'PV parameters from fitted data:')\nplt.text(0,4.8,f'Jsc: {gaas_solar_cell.iv.Isc/10:.2f} $mA.cm^-2$')\nplt.text(0,4,f'Voc: {gaas_solar_cell.iv.Voc:.2f} V')\nplt.text(0,3.2,f'FF: {gaas_solar_cell.iv.FF:.2f}')\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/3-IV_fitting.html#effect-of-series-shunt-resistance-on-the-fill-factor",
    "href": "solcore-workshop-2/notebooks/3-IV_fitting.html#effect-of-series-shunt-resistance-on-the-fill-factor",
    "title": "Fitting IV data using Shockley’s Diode Equation",
    "section": "Effect of series & shunt resistance on the Fill Factor",
    "text": "Effect of series & shunt resistance on the Fill Factor\nThe GaAs solar cell above is largely unaffected by series and shunt resistance. Let us explore the effect of series and shunt resistance on this solar cell.\n\nEffect of Series resistance on Fill Factor\n\n# Setup the figure ahead of plotting data\nplt.figure(1)\n\n# List of series resistances for which the calculation should be performed\nrs_list=[0.0000012,0.00012,0.0006]\n\ncounter=0  # Used to format the text on the plot\n\nfor rs in rs_list:   #Iterate through all the values of rs in rs_list\n    # All parameters are entered in units of A & m-2\n    gaas_junction = Junction(kind='2D', T=300, n1=1,n2=2, jref=300,  j01=1.3e-19*1E4,j02=5.82E-12*1E4, R_series=rs, R_shunt=1500000.0,jsc=278.9)\n\n    gaas_solar_cell = SolarCell([gaas_junction], T=300)\n\n    solar_cell_solver(gaas_solar_cell, 'iv',\n    user_options={'T_ambient': 300, 'db_mode': 'top_hat', 'voltages': V, 'light_iv': True,\n            'internal_voltages': np.linspace(-1, 1.1, 1100),\n            'mpp': True})\n\n    plt.plot(V, gaas_solar_cell.iv['IV'][1]/40,label=rs)  # divide by 10 to convert A/m2 to mA/cm2 and by 4 to account for 0.25cm2 device area\n    text=str(rs)+f'ohm, FF: {gaas_solar_cell.iv.FF:.2f}'\n    plt.text (0.3,6-0.7*counter,text)\n    counter=counter+1\n\nplt.ylim(-4,8)\nplt.title('Effect of Series Resistance on Fill Factor')\nplt.xlabel('Voltage / V')\nplt.ylabel('Current / mA')\nplt.legend()\nplt.show()\n\n\n\nEffect of Shunt resistance on Fill Factor\n\n# Setup the figure ahead of plotting data\nplt.figure(1)\n\n# List of series resistances for which the calculation should be performed\nrsh_list=[1,0.04,0.02]\n\ncounter=0  # Used to format the text on the plot\n\nfor rsh in rsh_list:   #Iterate through all the values of rs in rs_list\n    # All parameters are entered in units of A & m-2\n    gaas_junction = Junction(kind='2D', T=300, n1=1,n2=2, jref=300,  j01=1.3e-19*1E4,j02=5.82E-12*1E4, R_series=0.0000012, R_shunt=rsh,jsc=278.9)\n\n    gaas_solar_cell = SolarCell([gaas_junction], T=300)\n\n    solar_cell_solver(gaas_solar_cell, 'iv',\n    user_options={'T_ambient': 300, 'db_mode': 'top_hat', 'voltages': V, 'light_iv': True,\n            'internal_voltages': np.linspace(-1, 1.1, 1100),\n            'mpp': True})\n\n    plt.plot(V, gaas_solar_cell.iv['IV'][1]/40,label=str(rsh)+f'ohm, FF: {gaas_solar_cell.iv.FF:.2f}')  # divide by 10 to convert A/m2 to mA/cm2 and by 4 to account for 0.25cm2 device area\n    text=str(rsh)+f'ohm, FF: {gaas_solar_cell.iv.FF:.2f}'\n    plt.text (0.3,4-0.7*counter,text)\n    counter=counter+1\n\nplt.ylim(-4,8)\nplt.title('Effect of Shunt Resistance on Fill Dactor')\nplt.xlabel('Voltage / V')\nplt.ylabel('Current / mA')\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/4-Spectral2.html",
    "href": "solcore-workshop-2/notebooks/4-Spectral2.html",
    "title": "Section 4: Calculating Spectral Irradiance using SPCTRAL 2",
    "section": "",
    "text": "SPCTRAL 2 is a clear-sky spectral irradiance model that accounts for variations in the atmospheric conditions and air-mass. Developed at NREL in 1984, it generates terrestrial spectral irradiance from 300nm to 4um with a resolution of approximately 10nm.\n“Simple Solar Spectral Model for Direct and Diffuse Irradiance on Horizontal and Tilted Planes at the Earth’s Surface for Cloudless Atmospheres”, R. Bird, C. Riordan, December 1984\nThe Solcore implementation accomodates the following inputs (stated values are defaults):\nAll the inputs are numeric other than the aod_model whose options are: ‘rural’, ‘urban’, ‘maritime’ and ‘tropospheric’."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/4-Spectral2.html#comparison-between-spctral2-with-default-parameters-and-am1.5g",
    "href": "solcore-workshop-2/notebooks/4-Spectral2.html#comparison-between-spctral2-with-default-parameters-and-am1.5g",
    "title": "Section 4: Calculating Spectral Irradiance using SPCTRAL 2",
    "section": "Comparison between SPCTRAL2 with default parameters and AM1.5G",
    "text": "Comparison between SPCTRAL2 with default parameters and AM1.5G\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom solcore.light_source import LightSource\n\n# Setup the AM1.5G solar spectrum\nwl = np.linspace(300, 4000, 4000) * 1e-9    #wl contains the x-ordinate in wavelength\nam15g = LightSource(source_type='standard', x=wl*1e9, version='AM1.5g')\n\nspc2default = LightSource(source_type='SPECTRAL2',  x=wl * 1e9)\n\nplt.figure()\nplt.title(\"Comparing SPCTRAL 2 vs AM1.5G\")\nplt.plot(*am15g.spectrum(wl*1e9), label='AM1.5G')\nplt.plot(*spc2default.spectrum(wl*1e9), label='SPC-default')\nplt.xlim(300, 3000)\nplt.xlabel('Wavelength (nm)')\nplt.ylabel('Power density (Wm$^{-2}$nm$^{-1}$)')\nplt.legend()\n\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\n\n\n&lt;matplotlib.legend.Legend at 0x12ee06f50&gt;"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/4-Spectral2.html#adjusting-the-precipitable-water-value",
    "href": "solcore-workshop-2/notebooks/4-Spectral2.html#adjusting-the-precipitable-water-value",
    "title": "Section 4: Calculating Spectral Irradiance using SPCTRAL 2",
    "section": "Adjusting the precipitable water value",
    "text": "Adjusting the precipitable water value\nThe default SPCTRAL2 parameters results in almost no atmospheric absorption. This suggests the precipitable water column thickness is much too low, the default is 0.00142 cm. Let’s increase that value to 1cm to roughly match AM1.5G:\n\nspc2pc = LightSource(source_type='SPECTRAL2', precipwater=1.0, x=wl * 1e9)\n\nplt.figure()\nplt.title('Comparions between SPCTRAL2 defaults, 1cm precipitable water & AM1.5G')\nplt.plot(*am15g.spectrum(wl*1e9), label='AM1.5G')\nplt.plot(*spc2default.spectrum(wl*1e9), label='SPC-default')\nplt.plot(*spc2pc.spectrum(wl*1e9), label='PC water')\n\nplt.xlim(300, 3000)\nplt.xlabel('Wavelength (nm)')\nplt.ylabel('Power density (Wm$^{-2}$nm$^{-1}$)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x12ef7a890&gt;"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/4-Spectral2.html#atmospheric-turbidity",
    "href": "solcore-workshop-2/notebooks/4-Spectral2.html#atmospheric-turbidity",
    "title": "Section 4: Calculating Spectral Irradiance using SPCTRAL 2",
    "section": "Atmospheric Turbidity",
    "text": "Atmospheric Turbidity\nThe short wavelength is attenuated which is likely due to a high level of aerosol loading in the default spectrum. To address this atmospheric turbidity can be reduced to around 0.05.\n\nspc2high = LightSource(source_type='SPECTRAL2', precipwater=1.0, turbidity=0.2, x=wl * 1e9)\nspc2med = LightSource(source_type='SPECTRAL2', precipwater=1.0, turbidity=0.1, x=wl * 1e9)\nspc2low = LightSource(source_type='SPECTRAL2', precipwater=1.0, turbidity=0.05, x=wl * 1e9)\n\nplt.figure()\nplt.title('Spectral Irradiance Plotted for Different Aersol Models')\nplt.plot(*am15g.spectrum(wl*1e9), label='AM1.5G')\nplt.plot(*spc2high.spectrum(wl*1e9), label='Turbidity = 0.2')\nplt.plot(*spc2med.spectrum(wl*1e9), label='Turbidity = 0.1')\nplt.plot(*spc2low.spectrum(wl*1e9), label='Turbidity = 0.05')\nplt.xlim(300, 3000)\nplt.xlabel('Wavelength (nm)')\nplt.ylabel('Power density (Wm$^{-2}$nm$^{-1}$)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x12f727450&gt;"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/4-Spectral2.html#variation-with-aerosol-models",
    "href": "solcore-workshop-2/notebooks/4-Spectral2.html#variation-with-aerosol-models",
    "title": "Section 4: Calculating Spectral Irradiance using SPCTRAL 2",
    "section": "Variation with Aerosol models",
    "text": "Variation with Aerosol models\nSeveral standard aerosol models are implemented in SPCTRAL 2 that were established by Shettle & Fenn.\nShettle, E. P., and R. W. Fenn, “Models of the Atmospheric Aerosol and Their Optical Properties, II Proceedings of the Advisory Group for Aerospace Reseach and Development Conference No . 183, Optical Propagation in the Atmosphere, 1975, pp. 2.1-2.16. Presented at the Electromagnetic Wave Propagation Panel Symposium, Lyngby, Denmark; 27-31 October 1975.\nHere we plot some of them with a turbidity of 0.2 to emphasise the different spectral behaviour:\n\nspc2rural = LightSource(source_type='SPECTRAL2', precipwater=1.0, turbidity=0.2,\n                        aod_model='rural', x=wl * 1e9)\nspc2marit = LightSource(source_type='SPECTRAL2', precipwater=1.0, turbidity=0.2,\n                        aod_model='maritime', x=wl * 1e9)\nspc2tropo = LightSource(source_type='SPECTRAL2', precipwater=1.0, turbidity=0.2,\n                        aod_model='tropospheric', x=wl * 1e9)\n\nplt.figure(1)\nplt.title('Spectral Irradiance Plotted for Different Aersol Models')\nplt.plot(*am15g.spectrum(wl*1e9), label='AM1.5G')\nplt.plot(*spc2rural.spectrum(wl*1e9), label='rural')\nplt.plot(*spc2marit.spectrum(wl*1e9), label='maritime')\nplt.plot(*spc2tropo.spectrum(wl*1e9), label='tropospheric')\nplt.xlim(300, 3000)\nplt.xlabel('Wavelength (nm)')\nplt.ylabel('Power density (Wm$^{-2}$nm$^{-1}$)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x12f7769d0&gt;"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/4-Spectral2.html#changing-the-time-of-day",
    "href": "solcore-workshop-2/notebooks/4-Spectral2.html#changing-the-time-of-day",
    "title": "Section 4: Calculating Spectral Irradiance using SPCTRAL 2",
    "section": "Changing the time of day",
    "text": "Changing the time of day\nOne of the most common uses for a spectral irradiance model such as SPCTRAL2 is to calculate how a particular solar cell technology behaves under varying spectral conditions during the day. This is particularly important whan working with series connected tandem solar cells where the current matching condition will vary according to the incident spectrum. Here we plot the spectral irradiance at 12pm, 2pm, 3pm, 4pm, 5pm, 6pm and 7pm. Note the strong relative loss in short-wavelength light relative to the infrared as the air-mass increases throughout the afternoon.\n\nimport datetime\n\nplt.figure(1)\nplt.title('Spectral Irradiance plotted from 12pm-7pm')\nhours=[12, 14, 15, 16, 17, 18, 19]\n\nfor h in hours:\n    spc2 = LightSource(source_type='SPECTRAL2', dateAndTime=datetime.datetime(2011, 6, 30, h, 00),\n                       precipwater=1.0, turbidity=0.05, x=wl * 1e9)\n    plt.plot(*spc2.spectrum(wl*1e9), label='hour '+ str(h))\n\nplt.xlim(300, 3000)\nplt.xlabel('Wavelength (nm)')\nplt.ylabel('Power density (Wm$^{-2}$nm$^{-1}$)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x12f8a5d10&gt;"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html",
    "href": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "",
    "text": "In this first set of examples, we will look at simple planar Si solar cell.\nIn this script, we will look at the difference between Beer-Lambert absorption calculations, using the Fresnel equations for front-surface reflection, and using the transfer-matrix model.\nFirst, lets import some very commonly-used Python packages:\nimport numpy as np\nimport matplotlib.pyplot as plt\nNumpy is a Python library which adds supports for multi-dimensional data arrays and matrices, so it is very useful for storing and handling data. You will probably use it in every Solcore script you write. Here, it is imported under the alias ‘np’, which you will see used below. matplotlib is used for making plots, and is imported under the alias ‘plt’. Both the ‘np’ and ‘plt’ aliases are extremely commonly used in Python programming.\nNow, let’s import some things from Solcore (which will be explained as we use them):\nfrom solcore import material, si\nfrom solcore.solar_cell import SolarCell, Layer, Junction\nfrom solcore.solar_cell_solver import solar_cell_solver\nfrom solcore.interpolate import interp1d"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html#defining-materials",
    "href": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html#defining-materials",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "Defining materials",
    "text": "Defining materials\nTo define our solar cell, we first want to define some materials. Then we want to organise those materials into Layers, organise those layers into a Junction (or multiple Junctions, for a multi-junction cell, as we will see later), and then finally define a SolarCell with that Junction.\nFirst, let’s define a silicon material. Silicon, along with many other semiconductors, dielectrics, and metals common in solar cells, is included in Solcore’s database:\n\nSi = material(\"Si\")\n\nThis creates an instance of the Si material. However, to use this in a solar cell we need to do specify some more information, specifically the doping level and the minority carrier diffusion length. The ‘si’ function comes in handy here to convert all quantities to base units e.g. m, m\\(^{-3}\\)…\n\nSi_p = Si(Na=si(\"1e21cm-3\"), electron_diffusion_length=si(\"4um\"))\nSi_n = Si(Nd=si(\"1e16cm-3\"), hole_diffusion_length=si(\"200um\"))"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html#defining-layers",
    "href": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html#defining-layers",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "Defining layers",
    "text": "Defining layers\nNow we define the emitter and base layers we will have in the solar cell; we specify their thickness, the material they are made of and the role they play within the cell (emitter or base). We create a junction which is a total of 200 \\(\\mu\\)m thick, with a 1 \\(\\mu\\)m junction depth.\n\nemitter_layer = Layer(width=si(\"1um\"), material=Si_p, role='emitter')\nbase_layer = Layer(width=si(\"199um\"), material=Si_n, role='base')\n\nNow we create the p-n junction using the layers defined above. We set kind=“DA” to tell Solcore to use the Depletion Approximation in the calculation:\n\nSi_junction = Junction([emitter_layer, base_layer], kind=\"DA\")"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html#setting-user-options",
    "href": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html#setting-user-options",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "Setting user options",
    "text": "Setting user options\nWavelengths we want to use in the calculations; wavelengths between 300 and 1200 nm, at 200 evenly spaced intervals:\n\nwavelengths = si(np.linspace(300, 1200, 200), \"nm\")\n\nNote that here and above in defining the layers and materials we have used the “si()” function multiple times: you can use this to automatically convert quantities in other units to base SI units (e.g. nanometres to metres).\nNow we specify some options for running the calculation. Initially we will use the Beer-Lambert absorption law (\\(I(z) = I_0 e^{-\\alpha*z}\\)) to calculate the optics of the cell (“BL”). We set the wavelengths we want to use, and we set “recalculate_absorption” to True so that further down in the script when we try different optics methods, Solcore knows we want to re-calculate the optics of the cell rather than re-using previous results. We can specify the options in a Python format called a dictionary:\n\noptions = {\n    \"recalculate_absorption\": True,\n    \"optics_method\": \"BL\",\n    \"wavelength\": wavelengths\n           }"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html#running-cell-simulations",
    "href": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html#running-cell-simulations",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "Running cell simulations",
    "text": "Running cell simulations\nDefine the solar cell; in this case it is very simple and we just have a single junction:\n\nsolar_cell = SolarCell([Si_junction])\n\nNow we use solar_cell_solver to calculate the QE of the cell; we can ask solar_cell_solver to calculate ‘qe’, ‘optics’ or ‘iv’.\n\nsolar_cell_solver(solar_cell, 'qe', options)\n\nSolving QE of the solar cell...\n\n\nPLOT 1: plotting the QE in the Si junction, as well as the fraction of light absorbed in the junction and reflected. Because we are using the Beer-Lambert absorption law and we did not specify external reflectance, the reflectance = 0 over the whole wavelength range.\n\nplt.figure()\nplt.plot(wavelengths*1e9, 100*solar_cell[0].eqe(wavelengths), 'k-', label=\"EQE\")\nplt.plot(wavelengths*1e9, 100*solar_cell[0].layer_absorption, label='Absorptance (A)')\nplt.plot(wavelengths*1e9, 100*solar_cell.reflected, label='Reflectance (R)')\nplt.legend()\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"QE/Absorptance (%)\")\nplt.title(\"(1) QE of Si cell - Beer-Lambert absorption\")\nplt.show()"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html#adding-front-surface-reflection-fresnel",
    "href": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html#adding-front-surface-reflection-fresnel",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "Adding front-surface reflection: Fresnel",
    "text": "Adding front-surface reflection: Fresnel\nNow, to make this calculation a bit more realistic, there are a few things we could do. We could load some measured front surface reflectance from a file, or we could calculate the reflectance. To calculate the reflectance, there are many approaches we could take; we are going to explore two of them here.\nIf we assume the silicon is infinitely thick (or at least much thicker than the wavelengths of light we care about) then the reflectance will approach the reflectivity of a simple air/Si interface. We can calculate what this is using the Fresnel equation for reflectivity.\n\ndef calculate_R_Fresnel(incidence_n, transmission_n, wl):\n    # return a function that gives the value of R (at normal incidence) at the input wavelengths\n\n    Rs = np.abs((incidence_n - transmission_n)/(incidence_n + transmission_n))**2\n\n    return interp1d(wl, Rs)\n\nThe transmission_n is the complex reflective index of Si at our wavelengths for the transmission medium (Si), which we can extract easily from the Si material object in Solcore. The incidence_n = 1 (air). Note that the function above is specifically for normal incidence.\n\ntrns_n = Si_n.n(wavelengths) + 1j*Si_n.k(wavelengths)\nreflectivity_fn = calculate_R_Fresnel(1, trns_n, wavelengths)\n\nWe define the solar cell again, with the same layers but now supplying the function for the externally-calculated reflectivity, and calculate the optics (reflection, absorption, transmission) again:\n\nsolar_cell_fresnel = SolarCell([Si_junction], reflectivity=reflectivity_fn)\n\nsolar_cell_solver(solar_cell_fresnel, 'optics', options)"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html#adding-front-surface-reflection-tmm",
    "href": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html#adding-front-surface-reflection-tmm",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "Adding front surface reflection: TMM",
    "text": "Adding front surface reflection: TMM\nFinally, we do the same again but now instead of supplying the external reflectivity we ask set the optics_method to “TMM” (Transfer Matrix Method), to correctly calculate reflection at the front surface. We will learn more about the transfer matrix method later.\n\nSi_junction = Junction([emitter_layer, base_layer], kind=\"DA\")\n\nsolar_cell_TMM = SolarCell([Si_junction])\n\nSet some more options for the cell calculation:\n\noptions[\"optics_method\"] = \"TMM\"\nvoltages = np.linspace(-1.1, 1.1, 100)\noptions[\"light_iv\"] = True\noptions[\"mpp\"] = True\noptions[\"voltages\"] = voltages\noptions[\"internal_voltages\"] = voltages\n\nwe calculate the QE and the IV (we set the light_iv option to True; if we don’t do this, Solcore just calculates the dark IV). We also ask Solcore to find the maximum power point (mpp) so we can get the efficiency. Note that the sign convention used by Solcore means that an n-on-p cell with have a negative open-circuit voltage.\n\nsolar_cell_solver(solar_cell_TMM, 'iv', options)\nsolar_cell_solver(solar_cell_TMM, 'qe', options)\n\nTreating layer(s) 1 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\nTreating layer(s) 1 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving QE of the solar cell...\n\n\nPLOT 2: here we plot the reflection, transmission, and absorption calculated with the Fresnel equation defined above, and with the TMM solver in Solcore, showing that for this simple situation (no anti-reflection coating, thick Si junction) they are exactly equivalent.\n\nplt.figure()\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.reflected, color='firebrick', label = \"R (TMM)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_fresnel.reflected, '--', color='orangered', label = \"R (Fresnel)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.absorbed, color='dimgrey', label = \"A (TMM)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_fresnel.absorbed, '--', color='lightgrey', label = \"A (Fresnel)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.transmitted, color='blue', label = \"T (TMM)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_fresnel.transmitted, '--', color='dodgerblue', label = \"T (Fresnel)\")\nplt.ylim(0, 100)\nplt.legend()\nplt.title(\"(2) Optics of Si cell - Fresnel/TMM\")\nplt.show()\n\n\n\n\nPLOT 3: As above for the TMM calculation, plotting the EQE as well, which will be slightly lower than the absorption because not all the carriers are collected. Comparing to plot (1), we can see we now have lower absorption due to the inclusion of front surface reflection, which is ~ 30% or more over the wavelength range of interest for a bare Si surface.\n\nplt.figure()\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM[0].eqe(wavelengths), 'k-', label=\"EQE\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM[0].layer_absorption, label='A')\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.reflected, label=\"R\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.transmitted, label=\"T\")\nplt.title(\"(3) QE of Si cell (no ARC) - TMM\")\nplt.legend()\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"QE/Absorptance (%)\")\nplt.ylim(0, 100)\nplt.show()"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html#adding-an-arc",
    "href": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html#adding-an-arc",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "Adding an ARC",
    "text": "Adding an ARC\nThe reflectance of bare Si is very high. Let’s try adding a simple anti-reflection coating (ARC), a single layer of silicon nitride (Si\\(_3\\)N\\(_4\\)):\n\nSiN = material(\"Si3N4\")()\n\nSi_junction = Junction([emitter_layer, base_layer], kind=\"DA\")\n\nsolar_cell_TMM_ARC = SolarCell([Layer(width=si(75, \"nm\"), material=SiN), Si_junction])\n\nsolar_cell_solver(solar_cell_TMM_ARC, 'qe', options)\nsolar_cell_solver(solar_cell_TMM_ARC, 'iv', options)\n\nTreating layer(s) 2 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving QE of the solar cell...\nTreating layer(s) 2 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\n\n\nPLOT 4: Absorption, EQE, reflection and transmission for the cell with a simple one-layer ARC. We see the reflection is significantly reduced from the previous plot leading to higher absorption/EQE.\n\nplt.figure()\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM_ARC[1].eqe(wavelengths), 'k-', label=\"EQE\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM_ARC[1].layer_absorption, label='A')\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM_ARC.reflected, label=\"R\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM_ARC.transmitted, label=\"T\")\nplt.legend()\nplt.title(\"(4) QE of Si cell (ARC) - TMM\")\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"QE/Absorptance (%)\")\nplt.ylim(0, 100)\nplt.show()\n\n\n\n\nPLOT 5: Compare the IV curves of the cells with and without an ARC. The efficiency is also shown on the plot. Note that because we didn’t specify a light source, Solcore will assume we want to use AM1.5G; in later examples we will set the light source used for light IV simulations explicitly.\n\nplt.figure()\nplt.plot(voltages, -solar_cell_TMM[0].iv(voltages)/10, label=\"No ARC\")\nplt.plot(voltages, -solar_cell_TMM_ARC[1].iv(voltages)/10, label=\"75 nm SiN\")\nplt.text(0.5, 1.02*abs(solar_cell_TMM.iv[\"Isc\"])/10, str(round(solar_cell_TMM.iv[\"Eta\"]*100,\n                                                      1)) + ' %')\nplt.text(0.5, 1.02*abs(solar_cell_TMM_ARC.iv[\"Isc\"])/10, str(round(solar_cell_TMM_ARC\n                                                          .iv[\"Eta\"]*100, 1)) + ' %')\nplt.ylim(0, 38)\nplt.xlim(-0.8, 0.8)\nplt.legend()\nplt.xlabel(\"V (V)\")\nplt.ylabel(r\"J (mA/cm$^2$)\")\nplt.title(\"(5) IV curve of Si cell with and without ARC\")\nplt.show()"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html#conclusions",
    "href": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html#conclusions",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "Conclusions",
    "text": "Conclusions\nWe see that the cell with an ARC has a significantly higher \\(J_{sc}\\), and a slightly higher \\(V_{oc}\\), than the bare Si cell. In reality, most Si cells have a textured surface rather than a planar surface with an ARC; this will be discussed later in the course.\nOverall, some things we can take away from the examples in this script:\n\nThe Beer-Lambert law is a very simple way to calculate absorption in a cell, but won’t take into account important effects such as front-surface reflection or the effects of anti-reflection coatings.\nUsing the transfer-matrix method (TMM), we can account for front surface reflection and interference effects which make e.g. ARCs effective. In the simple situation of a thick cell without any front surface layers, it is equivalent to simply calculating the reflection with the Fresnel equations and assuming Beer-Lambert absorption in the cell.\nAdding a simple, one-layer ARC can significantly reduce front-surface reflection for a single-junction cell, leading to improved short-circuit current. To correctly account for interference in this layer, which is what causes its anti-reflective properties, we most use the transfer-matrix method (TMM) optical solver."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html#questions",
    "href": "solcore-workshop-2/notebooks/5a-simple_Si_cell.html#questions",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "Questions",
    "text": "Questions\n\nWhich parameters could we change which would affect the EQE and/or IV of the cell?\nWhy can’t we just use the Fresnel equations to calculate the effect of an anti-reflection coating?"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/6b-arc_optimization.html",
    "href": "solcore-workshop-2/notebooks/6b-arc_optimization.html",
    "title": "Section 6b: Optimizing an ARC",
    "section": "",
    "text": "In the previous example, we introduced a simple one-layer anti-reflection coating (ARC); ARCs are a standard feature of all high-efficiency solar cells. But how do you find out the right thickness for the anti-reflection coating layer(s) (or the right dimensions for a light-trapping grating, or some other structure in your cell)? This is where optimization comes in. Here, we will look at a very simple ‘brute-force’ optimization for a single or double-layer ARC.\nimport numpy as np\nimport os\nimport matplotlib.pyplot as plt\n\nfrom solcore import material, si\nfrom solcore.solar_cell import Layer, SolarCell\nfrom solcore.solar_cell_solver import solar_cell_solver\nfrom solcore.light_source import LightSource\nfrom solcore.absorption_calculator import search_db, download_db\nfrom solcore.absorption_calculator import calculate_rat\nfrom solcore.state import State\n\nfrom rayflare.transfer_matrix_method import tmm_structure\nfrom rayflare.options import default_options\nimport seaborn as sns"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/6b-arc_optimization.html#setting-up",
    "href": "solcore-workshop-2/notebooks/6b-arc_optimization.html#setting-up",
    "title": "Section 6b: Optimizing an ARC",
    "section": "Setting up",
    "text": "Setting up\nWe set some options, as in previous examples, setting the wavelengths and defining the incident spectrum. We are going to do a partially coherent calculation, treating the ARC as a coherent layer and the thick Si layer as incoherent (no thin-film interference).\n\nopts = State()\n\nwavelengths = np.linspace(300, 1200, 800)*1e-9\n\nAM15g = LightSource(source_type=\"standard\", version=\"AM1.5g\", output_units=\"photon_flux_per_m\")\nspectrum = AM15g.spectrum(wavelengths)[1]\nnormalised_spectrum = spectrum/np.max(spectrum)\n\nopts.wavelength = wavelengths\nopts.coherency_list = ['c', 'i']\nopts.optics_method = 'TMM'\nopts.position = 100e-6\nopts.no_back_reflection = False\n\nSi = material(\"Si\")()\nSiN = material(\"Si3N4\")()\nAg = material(\"Ag\")()\nAir = material(\"Air\")()"
  },
  {
    "objectID": "solcore-workshop-2/notebooks/6b-arc_optimization.html#single-layer-arc",
    "href": "solcore-workshop-2/notebooks/6b-arc_optimization.html#single-layer-arc",
    "title": "Section 6b: Optimizing an ARC",
    "section": "Single-layer ARC",
    "text": "Single-layer ARC\nHere, we will calculate the behaviour of a single-layer SiN anti-reflection coating on Si while changing the ARC thickness between 0 and 200 nm. We will consider two values to optimize: the mean reflectance mean_R, and the reflectance weighted by the photon flux in an AM1.5G spectrum (weighted_R). The reason for considering the second value is that it is more useful to suppress reflection at wavelengths where there are more photons which could be absorbed by the cell (up to the cell’s bandgap).\nWe will loop through the different ARC thicknesses in d_range, build the structure for each case, and then calculate the reflectance. We then save the mean reflected and weighted mean reflectance in the corresponding arrays. We also plot the reflectance for each 15th loop (this is just so the plot does not get too crowded).\n\n%%capture\n\nd_range = np.linspace(0, 200, 200)\n\nmean_R = np.empty_like(d_range)\nweighted_R = np.empty_like(d_range)\n\ncols = sns.cubehelix_palette(np.ceil(len(d_range)/15))\n\nplt.figure()\njcol = 0\n\nfor i1, d in enumerate(d_range):\n\n    struct = SolarCell([Layer(si(d, 'nm'), SiN), Layer(si('120um'), Si)], substrate=Ag)\n    solar_cell_solver(struct, task='optics', user_options=opts)\n\n    if i1 % 15 == 0:\n        plt.plot(wavelengths*1e9, struct.reflected, label=str(np.round(d, 0)), color=cols[jcol])\n        jcol += 1\n\n    mean_R[i1] = np.mean(struct.reflected)\n    weighted_R[i1] = np.mean(struct.reflected*normalised_spectrum)\n\nplt.legend()\nplt.show()\n\nWe now find at which index mean_R and weighted_R are minimised using np.argmin, and use this to print the ARC thickness at which this occurs (rounded to 1 decimal place).\n\nprint('Minimum mean reflection occurs at d = ' + str(np.round(d_range[np.argmin(mean_R)], 1)) + ' nm')\nprint('Minimum weighted reflection occurs at d = ' + str(np.round(d_range[np.argmin(weighted_R)], 1)) + ' nm')\n\nMinimum mean reflection occurs at d = 67.3 nm\nMinimum weighted reflection occurs at d = 74.4 nm\n\n\nWe see that the values of \\(d\\) for the two different ways of optimizing are very similar, but not exactly the same, as we would expect. The minimum in both cases occurs around 70 nm. We can also plot the variation of the mean and weighted \\(R\\) with ARC thickness \\(d\\):\n\nplt.figure()\nplt.plot(d_range, mean_R, label='Mean reflection')\nplt.plot(d_range[np.argmin(mean_R)], np.min(mean_R), 'ok')\nplt.plot(d_range, weighted_R, label='Weighted mean reflection')\nplt.plot(d_range[np.argmin(weighted_R)], np.min(weighted_R), 'ok')\nplt.xlabel('d$_{SiN}$')\nplt.ylabel('(Weighted) mean reflection 300-1200 nm')\nplt.legend()\nplt.show()\n\n\n\n\nNow, to see what the reflectance looks like for the optimized structure, we make new tmm_structures with the optimal values and calculate and plot the reflectance:\n\nstruct_1 = SolarCell([Layer(si(d_range[np.argmin(mean_R)], 'nm'), SiN), Layer(si('120um'), Si)], substrate=Ag)\nsolar_cell_solver(struct_1, task='optics', user_options=opts)\nR_1 = struct_1.reflected\n\nstruct_2 = SolarCell([Layer(si(d_range[np.argmin(weighted_R)], 'nm'), SiN), Layer(si('120um'), Si)], substrate=Ag)\nsolar_cell_solver(struct_2, task='optics', user_options=opts)\nR_2 = struct_2.reflected\n\nplt.figure()\nplt.plot(wavelengths*1e9, R_1, label='Mean R minimum')\nplt.plot(wavelengths*1e9, R_2, label='Weighted R minimum')\nplt.legend()\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"R\")\nplt.show()\n\nTreating layer(s) 1 incoherently\nCalculating RAT...\nCalculating absorption profile...\nTreating layer(s) 1 incoherently\nCalculating RAT...\nCalculating absorption profile...\n\n\n\n\n\nWe see that the two reflectance curves are very similar, as expected because the layer thicknesses are very similar."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/6b-arc_optimization.html#double-layer-arc",
    "href": "solcore-workshop-2/notebooks/6b-arc_optimization.html#double-layer-arc",
    "title": "Section 6b: Optimizing an ARC",
    "section": "Double-layer ARC",
    "text": "Double-layer ARC\nWe will now consider a similar situation, but for a double-layer MgF\\(_2\\)/Ta\\(_2\\)O\\(_5\\) ARC on GaAs.\nSolcore can directly interface with the database from www.refractiveindex.info, which contains around 3000 sets of data for a large number of different materials. Before the first use, it is necessary to download the database. This only needs to be done once, so you can comment this line out after it’s done:\n\ndownload_db(confirm=True) # only needs to be done once\n\nDatabase file found at /Users/z3533914/.solcore/nk/nk.db\nMaking request to https://refractiveindex.info/download/database/rii-database-2021-07-18.zip\nDownloaded and extracting...\nWrote /var/folders/wh/w5k56r_927j4yp3mh91bggfc0000gq/T/tmp48b25bqt/database from https://refractiveindex.info/download/database/rii-database-2021-07-18.zip\nLOG: 2746,other,PtAl2,Chen : Bad Material YAML File.\n***Wrote SQLite DB on  /Users/z3533914/.solcore/nk/nk.db\n\n\nWe search for materials in the refractiveindex.info database, and use only the part of the solar spectrum relevant for absorption in GaAs (in this case, there is no benefit to reducing absorption above the GaAs bandgap around 900 nm). We will only consider the weighted mean \\(R\\) in this case. Since all the layers in the structure are relatively thin compared to the wavelengths of light, we do a coherent calculation.\n\n%%capture\n\npageid_MgF2 = search_db(os.path.join(\"MgF2\", \"Rodriguez-de Marcos\"))[0][0]\npageid_Ta2O5 = search_db(os.path.join(\"Ta2O5\", \"Rodriguez-de Marcos\"))[0][0]\n\nGaAs = material(\"GaAs\")()\nMgF2 = material(str(pageid_MgF2), nk_db=True)()\nTa2O5 = material(str(pageid_Ta2O5), nk_db=True)()\n\nMgF2_thickness = np.linspace(50, 100, 20)\nTa2O5_thickness = np.linspace(30, 80, 20)\n\nweighted_R_matrix = np.zeros((len(MgF2_thickness), len(Ta2O5_thickness)))\n\nwavelengths_GaAs = wavelengths[wavelengths &lt; 900e-9]\nnormalised_spectrum_GaAs = normalised_spectrum[wavelengths &lt; 900e-9]\n\nopts.coherency_list = None\nopts.wavelength = wavelengths_GaAs\nopts.position = 20e-6\n\nWe now have two thicknesses to loop through; otherwise, the procedure is similar to the single-layer ARC example.\n\n%%capture\n\nfor i1, d_MgF2 in enumerate(MgF2_thickness):\n    for j1, d_Ta2O5 in enumerate(Ta2O5_thickness):\n        struct = SolarCell([Layer(si(d_MgF2, 'nm'), MgF2), Layer(si(d_Ta2O5, 'nm'), Ta2O5),\n                                Layer(si('20um'), GaAs)],\n                               substrate=Ag)\n        solar_cell_solver(struct, 'optics', opts)\n        R = struct.reflected\n\n        weighted_R_matrix[i1, j1] = np.mean(R * normalised_spectrum_GaAs)\n\n# find the row and column indices of the minimum weighted R value\nri, ci = np.unravel_index(weighted_R_matrix.argmin(), weighted_R_matrix.shape)\n\nWe plot the total absorption (\\(1-R\\)) in the structure with the optimized ARC, and print the thicknesses of MgF\\(_2\\) and Ta\\(_2\\)O\\(_5\\) at which this occurs:\n\nplt.figure()\nplt.imshow(1-weighted_R_matrix, extent=[min(Ta2O5_thickness), max(Ta2O5_thickness),\n                                        min(MgF2_thickness), max(MgF2_thickness)],\n           origin='lower', aspect='equal')\nplt.plot(Ta2O5_thickness[ci], MgF2_thickness[ri], 'xk')\nplt.colorbar()\nplt.xlabel(\"Ta$_2$O$_5$ thickness (nm)\")\nplt.ylabel(\"MgF$_2$ thickness (nm)\")\nplt.show()\n\nprint(\"Minimum reflection occurs at MgF2 / Ta2O5 thicknesses of %.1f / %.1f nm \"\n     % (MgF2_thickness[ri], Ta2O5_thickness[ci]))\n\n\n\n\nMinimum reflection occurs at MgF2 / Ta2O5 thicknesses of 73.7 / 53.7 nm \n\n\nFor these two examples, where we are only trying to optimize one and two parameters respectively across a relatively small range, using a method (TMM) which executes quickly, brute force searching is possible. However, as we introduce more parameters, a wider parameter space, and slower simulation methods, it may no longer be computationally tractable; in that case, using for example differential evolution or other types of numerical optimization may be more appropriate (see this example)."
  },
  {
    "objectID": "solcore-workshop-2/notebooks/6b-arc_optimization.html#questions",
    "href": "solcore-workshop-2/notebooks/6b-arc_optimization.html#questions",
    "title": "Section 6b: Optimizing an ARC",
    "section": "Questions",
    "text": "Questions\n\nApart from varying the thickness of the layers, what else could we change?\nHow do we know where to start when designing an ARC (layer thickness/material)?"
  },
  {
    "objectID": "solcore-workshop-2/schedule.html",
    "href": "solcore-workshop-2/schedule.html",
    "title": "Schedule",
    "section": "",
    "text": "Day 1 (Wednesday 22/11)\n\nDay 2 (Thursday 23/11)\n\nDay 3 (Friday 24/11)\n\n\n\n\nThemes:\nIntroduction, efficiency limits & fitting data\n\nJunction models & planar optics\n\nAdvanced light-trapping structures\n\n\n1.00 - 1.30\nIntroduction to computer modelling & Solcore\n1.00 - 1.30\nIntroduction to different junction models\n1.00 - 1.20\nIntroduction to RayFlare & different optical methods\n\n\n1.30 - 2.15\nLimiting current & voltage models\n1.30 - 2.00\nPlanar Si cell using depletion approximation junction\n1.20 - 2.00\nEffect of diffraction grating (RCWA) and ray-tracing (RT) on a silicon wafer\n\n\n2.15 - 2.45\nBreak\n2.00 - 2.45\nIntroduction to the transfer-matrix method: interference and anti-reflection coatings\n2.00 - 2.30\nGaInP/GaAs/Si triple-junction cell with rear diffraction grating\n\n\n2.45 - 3.30\nShockley-Queisser efficiency limit\n2.45 - 3.15\nBreak\n2.30 - 3.00\nBreak\n\n\n3.30 - 4.00\nChanging irradiance spectra\n3.00 - 3.45\nPlanar Si cell using drift-diffusion junction\n3.00 - 3.45\nEpoxy-bonded GaInP/GaAs//Si triple-junction cell with pyramidally textured silicon\n\n\n4.00 - 4.15\nBreak\n3.45 - 4.15\nBreak\n3.45 - 4.30\nPerovskite on silicon tandem cell with pyramidcal texturing\n\n\n4.15 - 5.00\nTwo-diode model fits to experimental data\n4.15 - 5.00\nOptical model of a planar III-V on Si tandem cell\n4.30 - 5.00\nUsing the Katana HPC"
  },
  {
    "objectID": "solcore-workshop/notebooks/6a-TMM_introduction.html",
    "href": "solcore-workshop/notebooks/6a-TMM_introduction.html",
    "title": "Section 6a: Basic cell optics",
    "section": "",
    "text": "In this script, we will build on the TMM model from example 1(a) and look at the effects of interference.\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom solcore import material, si\nfrom solcore.solar_cell import Layer\nfrom solcore.absorption_calculator import calculate_rat, OptiStack\nimport seaborn as sns"
  },
  {
    "objectID": "solcore-workshop/notebooks/6a-TMM_introduction.html#setting-up",
    "href": "solcore-workshop/notebooks/6a-TMM_introduction.html#setting-up",
    "title": "Section 6a: Basic cell optics",
    "section": "Setting up",
    "text": "Setting up\nFirst, let’s define some materials:\n\nSi = material(\"Si\")\nSiN = material(\"Si3N4\")()\nAg = material(\"Ag\")()\n\nNote the second set of brackets (or lack thereof). The Solcore material system essentially operates in two stages; we first call the material function with the name of the material we want to use, for example Si = material(“Si”), which creates a general Python class corresponding to that material. We then call this class to specify further details, such as the temperature, doping level, or alloy composition (where relavant). This happens below when defining Si_n and Si_p; both are use the Si class defined above, and adding further details to the material. For the definitions of SiN and Ag above, we do both steps in a single line, hence the two sets of brackets.\n\nSi_n = Si(Nd=si(\"1e21cm-3\"), hole_diffusion_length=si(\"10um\"))\nSi_p = Si(Na=si(\"1e16cm-3\"), electron_diffusion_length=si(\"400um\"))\n\nTo look at the effect of interference in the Si layer at different thicknesses, we make a list of thicknesses to test (evenly spaced on a log scale from 400 nm to 300 um):\n\nSi_thicknesses = np.linspace(np.log(0.4e-6), np.log(300e-6), 8)\nSi_thicknesses = np.exp(Si_thicknesses)\n\nwavelengths = si(np.linspace(300, 1200, 400), \"nm\")\n\noptions = {\n    \"recalculate_absorption\": True,\n    \"optics_method\": \"TMM\",\n    \"wavelength\": wavelengths\n           }\n\nMake a color palette using the seaborn package to make the plots look nicer\n\ncolors = sns.color_palette('rocket', n_colors=len(Si_thicknesses))\ncolors.reverse()\n\ncreate an ARC layer:\n\nARC_layer = Layer(width=si('75nm'), material=SiN)"
  },
  {
    "objectID": "solcore-workshop/notebooks/6a-TMM_introduction.html#effect-of-si-thickness",
    "href": "solcore-workshop/notebooks/6a-TMM_introduction.html#effect-of-si-thickness",
    "title": "Section 6a: Basic cell optics",
    "section": "Effect of Si thickness",
    "text": "Effect of Si thickness\nNow we are going to loop through the different Si thicknesses generated above, and create a simple solar cell-like structure. Because we will only do an optical calculation, we don’t need to define a junction and can just make a simple stack of layers.\nWe then calculate reflection, absorption and transmission (RAT) for two different situations: 1. a fully coherent stack 2. assuming the silicon layer is incoherent. This means that light which enters the Si layer cannot interfere with itself, but light in the ARC layer can still show interference. In very thick layers (much thicker than the wavelength of light being considered) this is likely to be more physically accurate because real light does not have infinite coherence length; i.e. if you measured wavelength-dependent transmission or reflection of a Si wafer hundreds of microns thick you would not expect to see interference fringes.\nPLOT 1\n\nplt.figure()\n\nfor i1, Si_t in enumerate(Si_thicknesses):\n\n    base_layer = Layer(width=Si_t, material=Si_p) # silicon layer\n    solar_cell = OptiStack([ARC_layer, base_layer]) # OptiStack (optical stack) to feed into calculate_rat function\n\n    # Coherent calculation:\n    RAT_c = calculate_rat(solar_cell, wavelengths*1e9, no_back_reflection=False) # coherent calculation\n    # For historical reasons, Solcore's default setting is to ignore reflection at the back of the cell (i.e. at the\n    # interface between the final material in the stack and the substrate). Hence we need to tell the calculate_rat\n    # function NOT to ignore this reflection (no_back_reflection=False).\n\n    # Calculation assuming no interference in the silicon (\"incoherent\"):\n    RAT_i = calculate_rat(solar_cell, wavelengths*1e9, no_back_reflection=False,\n                          coherent=False, coherency_list=['c', 'i']) # partially coherent: ARC is coherent, Si is not\n\n    # Plot the results:\n    plt.plot(wavelengths*1e9, RAT_c[\"A\"], color=colors[i1], label=str(round(Si_t*1e6, 1)), alpha=0.7)\n    plt.plot(wavelengths*1e9, RAT_i[\"A\"], '--', color=colors[i1])\n\nplt.legend(title=r\"Thickness ($\\mu$m)\")\nplt.xlim(300, 1300)\nplt.ylim(0, 1.02)\nplt.ylabel(\"Absorption\")\nplt.title(\"(1) Absorption in Si with varying thickness\")\nplt.show()\n\n\n\n\nWe can see that the coherent calculations (solid lines) show clear interference fringes which depend on the Si thickness. The incoherent calculations do not have these fringes and seem to lie around the average of the interference fringes. For both sets of calculations, we see increasing absorption as the Si gets thicker, as expected."
  },
  {
    "objectID": "solcore-workshop/notebooks/6a-TMM_introduction.html#effect-of-reflective-substrate",
    "href": "solcore-workshop/notebooks/6a-TMM_introduction.html#effect-of-reflective-substrate",
    "title": "Section 6a: Basic cell optics",
    "section": "Effect of reflective substrate",
    "text": "Effect of reflective substrate\nNow we repeat the calculation, but with an Ag substrate under the Si. Previously, we did not specify the substrate and so it was assumed by Solcore to be air (\\(n\\) = 1, \\(\\kappa\\) = 0).\nPLOT 2\n\nplt.figure()\n\nfor i1, Si_t in enumerate(Si_thicknesses):\n\n    base_layer = Layer(width=Si_t, material=Si_p)\n\n    # As before, but now we specify the substrate to be silver:\n    solar_cell = OptiStack([ARC_layer, base_layer], substrate=Ag)\n\n    RAT_c = calculate_rat(solar_cell, wavelengths*1e9, no_back_reflection=False)\n    RAT_i = calculate_rat(solar_cell, wavelengths*1e9, no_back_reflection=False,\n                          coherent=False, coherency_list=['c', 'i'])\n    plt.plot(wavelengths*1e9, RAT_c[\"A\"], color=colors[i1],\n             label=str(round(Si_t*1e6, 1)), alpha=0.7)\n    plt.plot(wavelengths*1e9, RAT_i[\"A\"], '--', color=colors[i1])\n\nplt.legend(title=r\"Thickness ($\\mu$m)\")\nplt.xlim(300, 1300)\nplt.ylim(0, 1.02)\nplt.ylabel(\"Absorption\")\nplt.title(\"(2) Absorption in Si with varying thickness (Ag substrate)\")\nplt.show()\n\n\n\n\nWe see that the interference fringes get more prominent in the coherent calculation, due to higher reflection at the rear Si/Ag surface compared to Ag/Air. We also see a slightly boosted absorption at long wavelengths at all thicknesses, again due to improved reflection at the rear surface"
  },
  {
    "objectID": "solcore-workshop/notebooks/6a-TMM_introduction.html#effect-of-polarization-and-angle-of-incidence",
    "href": "solcore-workshop/notebooks/6a-TMM_introduction.html#effect-of-polarization-and-angle-of-incidence",
    "title": "Section 6a: Basic cell optics",
    "section": "Effect of polarization and angle of incidence",
    "text": "Effect of polarization and angle of incidence\nFinally, we look at the effect of incidence angle and polarization of the light hitting the cell.\nPLOT 3\n\nangles = [0, 30, 60, 70, 80, 89] # angles in degrees\n\nARC_layer = Layer(width=si('75nm'), material=SiN)\nbase_layer = Layer(width=si(\"100um\"), material=Si_p)\n\ncolors = sns.cubehelix_palette(n_colors=len(angles))\n\nplt.figure()\n\nfor i1, theta in enumerate(angles):\n\n    solar_cell = OptiStack([ARC_layer, base_layer])\n\n    RAT_s = calculate_rat(solar_cell, wavelengths*1e9, angle=theta,\n                          pol='s',\n                          no_back_reflection=False,\n                          coherent=False, coherency_list=['c', 'i'])\n    RAT_p = calculate_rat(solar_cell, wavelengths*1e9, angle=theta,\n                          pol='p',\n                          no_back_reflection=False,\n                          coherent=False, coherency_list=['c', 'i'])\n\n    plt.plot(wavelengths*1e9, RAT_s[\"A\"], color=colors[i1], label=str(round(theta)))\n    plt.plot(wavelengths*1e9, RAT_p[\"A\"], '--', color=colors[i1])\n\nplt.legend(title=r\"$\\theta (^\\circ)$\")\nplt.xlim(300, 1300)\nplt.ylim(0, 1.02)\nplt.ylabel(\"Absorption\")\nplt.title(\"(3) Absorption in Si with varying angle of incidence\")\nplt.show()\n\n\n\n\nFor normal incidence (\\(\\theta = 0^\\circ\\)), s (solid lines) and p (dashed lines) polarization are equivalent. As the incidence angle increases, in general absorption is higher for p-polarized light (due to lower reflection). Usually, sunlight is modelled as unpolarized light, which computationally is usually done by averaging the results for s and p-polarized light."
  },
  {
    "objectID": "solcore-workshop/notebooks/6a-TMM_introduction.html#conclusions",
    "href": "solcore-workshop/notebooks/6a-TMM_introduction.html#conclusions",
    "title": "Section 6a: Basic cell optics",
    "section": "Conclusions",
    "text": "Conclusions\nWe have now seen some effects of interference in layers of different thicknesses, and seen the effect of adding a highly reflective substrate. So we already have two strategies for light-trapping/improving the absorption in a solar cell: adding an anti-reflection coating (in example 1a), to reduce front-surface reflection and get more light into the cell, and adding a highly reflective layer at the back, to reduce loss through the back of the cell and keep light trapped in the cell."
  },
  {
    "objectID": "solcore-workshop/notebooks/6a-TMM_introduction.html#questions",
    "href": "solcore-workshop/notebooks/6a-TMM_introduction.html#questions",
    "title": "Section 6a: Basic cell optics",
    "section": "Questions",
    "text": "Questions\n\nWhy are the interference fringes stronger when adding a silver back mirror, compared to having air behind the Si?\nWe modelled s and p-polarized light - how do we normally model unpolarized light?"
  },
  {
    "objectID": "solcore-workshop/notebooks/2-Efficiency_limits.html",
    "href": "solcore-workshop/notebooks/2-Efficiency_limits.html",
    "title": "Section 2: Integration for limiting current, limiting voltage model, efficiency limit",
    "section": "",
    "text": "Tuesday 1 August 2023"
  },
  {
    "objectID": "solcore-workshop/notebooks/2-Efficiency_limits.html#trivich-flinn-efficiency-limit",
    "href": "solcore-workshop/notebooks/2-Efficiency_limits.html#trivich-flinn-efficiency-limit",
    "title": "Section 2: Integration for limiting current, limiting voltage model, efficiency limit",
    "section": "Trivich-Flinn Efficiency limit",
    "text": "Trivich-Flinn Efficiency limit\nIn 1955 Trivich & Flinn published a model for limiting efficiency. The limit it produces is too high, but it represents a good place to start with a computer model.\nTrivich D, Flinn PA. Maximum efﬁciency of solar energy conversion by quantum processes. In Solar Energy Research, Daniels F, Dufﬁe J (eds). Thames and Hudson: London, 1955.\nTrivich & Flinn assumed that the ideal solar cell would absorb all photons with energy above the band-gap energy \\(E_g\\) and that the maximum voltage that could ever be attained in a solar cell is the band-gap energy. The latter assumption is incorrect unless the solar cell is operating at absolute zero temperature.\nTo develop a model for the Trivich & Flinn efficiency limit the first step is to calculate what the limit to the photocurrent is in a solar cell."
  },
  {
    "objectID": "solcore-workshop/notebooks/2-Efficiency_limits.html#limits-to-the-short-circuit-current",
    "href": "solcore-workshop/notebooks/2-Efficiency_limits.html#limits-to-the-short-circuit-current",
    "title": "Section 2: Integration for limiting current, limiting voltage model, efficiency limit",
    "section": "Limits to the short-circuit current",
    "text": "Limits to the short-circuit current\n\nSolar Spectrum\nThe solar spectrum defines the ultimate current that a solar cell can produce. First we will plot the AM1.5G solar spectrum \\(b(\\lambda)\\) as a spectral irradiance, meaning that the y-axis has units of \\(W.m^{-2}.nm^{-1}\\)\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom solcore.light_source import LightSource\nimport seaborn as sns\n\n# Setup the AM1.5G solar spectrum\nwl = np.linspace(300, 4000, 4000) * 1e-9    # wl contains the x-coordinate in wavelength\nam15g = LightSource(source_type='standard', x=wl*1e9, version='AM1.5g',\n                    output_units=\"power_density_per_nm\")\n\nplt.figure()\nplt.title('Spectral Irradiance')\nplt.plot(*am15g.spectrum(wl*1e9), label='AM1.5G')\nplt.xlim(300, 3000)\nplt.xlabel('Wavelength (nm)')\nplt.ylabel('Power density (Wm$^{-2}$nm$^{-1}$)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x16dcaa990&gt;\n\n\n\n\n\nLet us now integrate the solar spectrum to provide the total irradiance in units of [\\(W.m^{-2}\\)]. The code below performs the following operation \\(b=\\int^{\\infty}_{0} b(\\lambda) d\\lambda\\)\n\n# Since .spectrum function returns a tuple (x,y) but np.trapz requires data in format (y,x) these are extracted into separate 1D np arrays.\nyval = am15g.spectrum()[1]\nxval = am15g.spectrum()[0]\nintegrated_value = np.trapz(yval,xval)  # Perform integration using trapezium rule\nb = integrated_value  # Save the integrated power density for the sun for later.\nprint('b = ', integrated_value)\n\nb =  1000.3974821197136\n\n\nLet’s take the opportunity to learn how to format numbers nicely in Python. Here we use the command “%.0f” % to display the value to zero decimal places.\n\nprint('b = ',\"%.0f\" % integrated_value,\"W.m-2\")\n\nb =  1000 W.m-2\n\n\nSolcore performs this integration for us internally. Let’s try the same exercise but for the extraterrestrial solar spectrum, AM0\n\nam0 = LightSource(source_type='standard', x=wl*1e9, version='AM0')\nprint(\"AM0 integrates to\", \"%.0f\" % am0.power_density, \"W.m-2\")\n\nAM0 integrates to 1348 W.m-2\n\n\n\n\nSpectral Photon Flux\nTo calculate a short-circuit current it is convenient to change the units. Two changes are necessary : 1. Since we specify band-gap energies in electron volts (eV) we need to transform the x-axis from nm to eV 2. Photocurrent is proportional to the incident photon flux (number of photons per second) not the irradiance (watts) so we need to convert the y-axis from energy to photon number.\nNote: The conversion is performed internally within the software but be aware that because the transformation from wavelength is non-linear, changing the x-axis from nm to eV also changes the y-values of the data. This is known as a Jacobian transformation and discussed in more detail in an article “Getting the basics right: Jacobian Conversion of Wavelength and Energy Scales for Quantatitive Analysis of Emission Spectra”, Journal of Physical Chemistry, 4(19) 3316 (2013)\n\nev = np.linspace(0.02,4,4000)\nflux = LightSource(source_type='standard', version='AM1.5g', x=ev, output_units='photon_flux_per_ev')\n\nplt.figure()\nplt.title('Spectral Photon Flux')\nplt.plot(*flux.spectrum(), label='AM1.5G')\nplt.xlim(0.2, 4)\nplt.xlabel('Photon Energy (eV)')\nplt.ylabel('Photon flux N ($ph.s^{-1}m^{-2}eV^{-1}$)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x16dc9f410&gt;\n\n\n\n\n\n\n\nCalculating the short-circuit current\nIntegrating the photon flux can provide an upper limit to the short-circuit current [A.m-2]. We can integrate the spectrum over the entire spectral range using \\(J_{sc}=q\\int_{0}^{\\infty}N(E)dE\\)\n\nq = 1.60217662E-19\nyval = flux.spectrum()[1]\nxval = flux.spectrum()[0]\nyint = q*np.trapz(yval,xval)  # Perform integration using trapezium rule\n\nprint(\"%.0f\" % yint)\n\n690\n\n\nA more useful calculation is to calculate the current that a solar cell would produce with a particular band-gap energy. To do this requires a bit more coding, since we now wish to integrate between limits: \\(J_{sc}=q\\int_{Eg}^{\\infty}N(E)dE\\)\nLet’s do this for a band-gap of 1.42 eV:\n\nq = 1.60217662E-19\neg = 1.42\nyval = flux.spectrum()[1]\nxval = flux.spectrum()[0]\n\nyval[xval &lt; eg] = 0 # set photon flux to zero for photon energies below the band-gap\n\nyint = q*np.trapz(yval,xval)  # Perform integration using trapezium rule\n\nprint(\"%.0f\" % yint)\n\n321\n\n\nLet’s reproduce the \\(J_{sc}\\) vs \\(E_g\\) graph that is shown on p. 87 of Martin Green’s Solar Cells book:\n\nq = 1.60217662E-19\n\ndef getJsc(eg):\n    yval = flux.spectrum()[1]  # Start with the solar spectrum in yval & xval\n    xval = flux.spectrum()[0]\n    yval[xval &lt; eg] = 0 # set photon flux to zero for photon energies below the band-gap\n    return q*np.trapz(yval,xval)  # return the integrated value\n\neg = np.linspace(0.5,2.5,100)\njsc = np.vectorize(getJsc)(eg)\n\nplt.figure()\nplt.title('Limit to the short-circuit current $J_{sc}$')\nplt.plot(eg, jsc/10, label='AM1.5G')  # Divide by 10 to convert from A.m^-2 to mA.cm^-2\nplt.xlim(0.5, 2.5)\nplt.xlabel('Band Gap energy (eV)')\nplt.ylabel('$J_{sc}$ ($mA.cm^{-2}$)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x17f3558d0&gt;\n\n\n\n\n\n\n\nCalculating the Trivich-Flinn Efficiency limit\nNow that the limit to \\(J_{sc}\\) is known, we can estimate the power of delivered by the solar cell by evaluating \\(\\frac{Eg J_{sc}}{b}\\)\n\nplt.figure()\nplt.title('Trivich-Flinn Single Junction Efficiency Limit')\nplt.plot(eg, 100*eg*jsc/b,label='AM1.5G')  # Divide by 10 to convert from A.m^-2 to mA.cm^-2\nplt.xlim(0.5, 2.5)\nplt.xlabel('Band Gap energy (eV)')\nplt.ylabel('Efficiency (%)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x17f3d72d0&gt;"
  },
  {
    "objectID": "solcore-workshop/notebooks/2-Efficiency_limits.html#the-shockley-queisser-efficiency-limit",
    "href": "solcore-workshop/notebooks/2-Efficiency_limits.html#the-shockley-queisser-efficiency-limit",
    "title": "Section 2: Integration for limiting current, limiting voltage model, efficiency limit",
    "section": "The Shockley-Queisser Efficiency limit",
    "text": "The Shockley-Queisser Efficiency limit\nShockley & Queisser refined the Trivich-Flinn limit by linking the voltage a solar cell can deliver to the Fermi level separation in the conduction and valance bands, not the band-gap energy.\nTo do this, a model is required for the recombination processes between the conduction and valance bands. The most fundamental (and inescapable) recombination mechanism is the radiative process. In section 3 we will derive a limit to Shockley’s diode equation \\(J=J_0 e^{\\frac{V}{kT}}\\) for the radiative limit, that being a diode where all current flows are linked to an optical process, either absorption or recombination.\nIn the radiative limit and an abrupt band-edge at band-gap energy \\(E_g\\) it can be shown that \\(J_0\\) is approximated by \\(J_0=q \\frac{2 \\pi}{c^2 h^3} kT \\left(E_g^2+2 E_g k T+2 k^2 T^2\\right) e^{\\frac{-E_g}{k T}}\\)\nWe can now plot a chart of \\(J_0\\) as a function of band-gap energy using this expression:\n\n# Define some physical constants:\nq = 1.60217662E-19  # electronic charge [C]\nk = 1.38064852E-23/q   # Boltzmann constant [eV/K]\nh = 6.62607004E-34/q  # Planck constant expressed in [eV.s]\nc = 299792458  # Speed of light [m.s^-1]\n\nt = 300  # Perform the calculation for a solar cell at 300K.\n\n# Define a function to return J0 implementing the expression above\ndef getJ0(eg):\n    return k*t*q*(2*np.pi/(c**2*h**3))*(eg**2+2*eg*k*t+2*k**2*t**2)*np.exp(-eg/(k*t))\n\neg = np.linspace(0.5,2.5,100)\nj0 = np.vectorize(getJ0)(eg)\n\nplt.figure()\nplt.title('The radiative limit to $J_0$ plotted as a function of band-gap energy Eg')\nplt.plot(eg,j0,label='J0')  # Divide by 10 to convert from A.m^-2 to mA.cm^-2\nplt.xlim(0.2, 2.5)\nplt.xlabel('Band Gap energy (eV)')\nplt.ylabel('$J_{0}$ ($A.m^{-2}$)')\nplt.yscale(\"log\")\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x17f47d490&gt;\n\n\n\n\n\nLet’s obtain J0 for GaAs and InGaP, two common III-V materials that are used in tandem solar cells: evaluate getJ0() for Eg=1.42 and Eg=1.88\n\ngetJ0(1.42)\n\n1.195457897843886e-17\n\n\n\ngetJ0(1.88)\n\n3.888154629395649e-25"
  },
  {
    "objectID": "solcore-workshop/notebooks/2-Efficiency_limits.html#calculating-the-iv-curve",
    "href": "solcore-workshop/notebooks/2-Efficiency_limits.html#calculating-the-iv-curve",
    "title": "Section 2: Integration for limiting current, limiting voltage model, efficiency limit",
    "section": "Calculating the IV curve",
    "text": "Calculating the IV curve\nWe are now able to calculate the limiting efficiency for a solar cell using the simple Shockley diode expression \\(J(V)=J_{s c}-J_0\\left(e^{\\frac{q V}{k T}}-1\\right)\\). Let’s plot the IV curve for a band-gap of 1.42eV\n\ndef getJ(v,eg):\n    return getJsc(eg) - getJ0(eg)*(np.exp(v/(k*t)) - 1)\n\neg = 1.42\nv = np.linspace(0,1.2,100)\nj = np.vectorize(getJ)(v,eg)\n\nplt.figure(3)\nplt.title('Limiting Efficiency IV curve for Eg=1.42eV (GaAs)')\nplt.plot(v,j/10)  #convert to mA.cm^-2\nplt.xlim(0.2, 1.2)\nplt.ylim(0,35)\nplt.xlabel('Voltage (V)')\nplt.ylabel('Current ($mA.cm^{-2}$)')\n\nText(0, 0.5, 'Current ($mA.cm^{-2}$)')"
  },
  {
    "objectID": "solcore-workshop/notebooks/2-Efficiency_limits.html#calculating-the-electrical-power-curve-and-finding-the-maximum-power",
    "href": "solcore-workshop/notebooks/2-Efficiency_limits.html#calculating-the-electrical-power-curve-and-finding-the-maximum-power",
    "title": "Section 2: Integration for limiting current, limiting voltage model, efficiency limit",
    "section": "Calculating the electrical power curve and finding the maximum power",
    "text": "Calculating the electrical power curve and finding the maximum power\n\nplt.figure()\nplt.title('Limiting Efficiency power curve for $E_g$ = 1.42 eV (GaAs)')\nplt.plot(v,v*j)\nplt.xlim(0.2, 1.2)\nplt.ylim(0,350)\nplt.xlabel('Voltage (V)')\nplt.ylabel('Power ($W.m^{-2}$)')\n\nText(0, 0.5, 'Power ($W.m^{-2}$)')\n\n\n\n\n\nDefine a function to find the maximum power point of the curve above:\n\ndef getPmax(eg):\n    v = np.linspace(0,eg-0.1,500)\n    p = v*np.vectorize(getJ)(v,eg)\n    return (np.amax(p))  # The amax command returns the maximum value in the array p\n\nTest it out on the curve above\n\ngetPmax(1.42)\n\n331.6412760959975\n\n\n\nPlotting the Shockley-Queisser efficiency limit graph:\nFinally we can calculate the Shockley-Queisser efficiency limit for AM1.5G\n\neg = np.linspace(0.5,2.5,100)\np = np.vectorize(getPmax)(eg)\n\nplt.figure(3)\nplt.title('Limiting Shockley-Queisser Efficiency Curve')\nplt.plot(eg, p/b, label='AM1.5G')  # Remember b is the integrated power of the\n# incident sunlight\nplt.xlim(0.2, 2.5)\nplt.xlabel('Band Gap energy (eV)')\nplt.ylabel('Efficiency (%)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x17f6258d0&gt;"
  },
  {
    "objectID": "solcore-workshop/notebooks/2-Efficiency_limits.html#an-easier-way-using-solcore",
    "href": "solcore-workshop/notebooks/2-Efficiency_limits.html#an-easier-way-using-solcore",
    "title": "Section 2: Integration for limiting current, limiting voltage model, efficiency limit",
    "section": "An easier way – using Solcore!",
    "text": "An easier way – using Solcore!\nThe Solcore library has all the functions we have written above built into it. We worked through this example step by step, but we can calculate the same result using the code below. First let’s calculate an IV curve for a Shockley-Queisser solar cell with a band-gap of 1.42eV:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom solcore.light_source import LightSource\nfrom solcore.solar_cell import SolarCell\nfrom solcore.solar_cell_solver import solar_cell_solver\nfrom solcore.structure import Junction\n\n# Load the AM1.5G solar spectrum\nwl = np.linspace(300, 4000, 4000) * 1e-9    # wl contains the x-coordinate in wavelength\nam15g = LightSource(source_type='standard', x=wl, version='AM1.5g')\n\neg = 1.42\nV = np.linspace(0, 1.3, 500)\ndb_junction = Junction(kind='DB', T=300, Eg=eg, A=1, R_shunt=np.inf, n=1) #\n# detailed-balance junction (Shockley-Queisser limit)\n\nmy_solar_cell = SolarCell([db_junction], T=300, R_series=0)\n\nsolar_cell_solver(my_solar_cell, 'iv',\n                      user_options={'T_ambient': 300, 'db_mode': 'top_hat', 'voltages': V, 'light_iv': True,\n                                    'internal_voltages': np.linspace(0, 1.3, 400), 'wavelength': wl,\n                                    'mpp': True, 'light_source': am15g})\n\nplt.figure()\nplt.title('Limiting Efficiency IV curve for $E_g$ = 1.42eV')\nplt.plot(V, my_solar_cell.iv.IV[1], 'k')\nplt.ylim(0, 350)\nplt.xlim(0, 1.2)\nplt.text(0.1,300,f'Jsc: {my_solar_cell.iv.Isc:.2f}')\nplt.text(0.1,280,f'Voc: {my_solar_cell.iv.Voc:.2f}')\nplt.text(0.1,260,f'Pmax: {my_solar_cell.iv.Pmpp:.2f}')\nplt.xlabel('Voltage (V)')\nplt.ylabel('Current (A/m$^2$)')\nplt.show()\n\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\n\n\n\n\n\nThe Shockley-Queisser efficiency calculation can now be performed over a range of band-gap energies. To do this, we make a function that calculates the maximum power Pmax as a function of band-gap energy.\n\n%%capture\n# A command that prevents the screen from filling up with unnecessary working\n\n# Function that returns the maximum power for a Shockley-Queisser solar cell with band-gap Eg\ndef getPmax(eg):\n    V = np.linspace(0, eg-0.1, 500)\n    db_junction = Junction(kind='DB', T=300, Eg=eg, A=1, R_shunt=np.inf, n=1)\n    my_solar_cell = SolarCell([db_junction], T=300, R_series=0)\n\n    solar_cell_solver(my_solar_cell, 'iv',\n                      user_options={'T_ambient': 300, 'db_mode': 'top_hat', 'voltages': V, 'light_iv': True, 'wavelength': wl,\n                                    'mpp': True, 'light_source': am15g})\n    return(my_solar_cell.iv.Pmpp)\n\n# Define the range of band-gaps to perform the calculation over\neg=np.linspace(0.5,2.5,100)\n# Perform the claculation for all values of eg\np=np.vectorize(getPmax)(eg)\n\nNow let’s plot the result:\n\nplt.figure()  # Plot the results calculated above:\nplt.title('Shockley-Queisser Limiting Efficiency for Unconentrated Sunlight')\nplt.plot(eg, p/am15g.power_density,label='AM1.5G')\nplt.xlim(0.5, 2.5)\nplt.xlabel('Band Gap energy (eV)')\nplt.ylabel('Efficiency (%)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x2c7060650&gt;\n\n\n\n\n\n\nEffect of solar concentration on a Shockley-Queisser Solar Cell\nIn a Trivich-Flinn model for a solar cell, concentrated sunlight is only expected to increase the current of a solar cell, not the voltage. In that model the current would increase in proportion with the concentration so the efficiency of the solar cell would be unchanged.\nIn the Shockley-Queisser model, concentrated sunlight increased both the current and the voltage of the solar cell which, in the absence of series resistance losses, leads to an increase in the efficiency of the solar cell. Here we calculate the Shockley-Queisser efficiency at different solar concentrations under the direct solar spectrum AM1.5D:\n\n%%capture\n\n# Set up a series of AM1.5D solar spectra at different concentrations\nwl = np.linspace(300, 4000, 4000) * 1e-9    #wl contains the x-ordinate in wavelength\nam15d1x = LightSource(source_type='standard', x=wl, version='AM1.5d', concentration=1)\nam15d30x = LightSource(source_type='standard', x=wl, version='AM1.5d', concentration=30)\nam15d1000x = LightSource(source_type='standard', x=wl, version='AM1.5d',\n                         concentration=1000)\n\n#Define a function to find Pmax for a particular band-gap energy and solar spectrum\ndef getPmax(eg,spectrum):\n    V = np.linspace(0, eg-0.1, 500)\n    db_junction = Junction(kind='DB', T=300, Eg=eg, A=1, R_shunt=np.inf, n=1)\n    my_solar_cell = SolarCell([db_junction], T=300, R_series=0)\n\n    solar_cell_solver(my_solar_cell, 'iv',\n                      user_options={'T_ambient': 300, 'db_mode': 'top_hat', 'voltages': V, 'light_iv': True, 'wavelength': wl,\n                                    'mpp': True, 'light_source': spectrum})\n    return my_solar_cell.iv.Pmpp\n\n# Evaluate the Pmax function for band-gaps spanning 0.8 to 1.6eV and concentrations 1x,30x,1000x\neg = np.linspace(0.8,1.6,100)\np1x = np.vectorize(getPmax)(eg, am15d1x)\np30x = np.vectorize(getPmax)(eg, am15d30x)\np1000x = np.vectorize(getPmax)(eg, am15d1000x)\n\n\n# Setup a figure for dual y-axes\nfig, ax = plt.subplots(1)\n\n# Plot the SQ curves\ncolors = sns.color_palette('husl', n_colors=3)\nax.plot(eg, 100*p1x/am15d1x.power_density,label='$\\eta$ @ AM1.5d 1x', color=colors[0])\nax.axvline(eg[np.argmax(p1x)], color=colors[0])\n\nax.plot(eg, 100*p30x/am15d30x.power_density,label='$\\eta$ @ AM1.5d 30x', color=colors[1])\nax.axvline(eg[np.argmax(p30x)], color=colors[1])\n\nax.plot(eg, 100*p1000x/am15d1000x.power_density,label='$\\eta$ @ AM1.5d 1000x', color=colors[2])\nax.axvline(eg[np.argmax(p1000x)], color=colors[2])\n\n# Define the second y-axis and plot the photon flux in units of eV\nax2 = ax.twinx()\nax2.plot(eg, am15d1x.spectrum(x=eg, output_units=\"photon_flux_per_ev\")[1],\n         '--', color='grey', label=\"AM1.5d\")\n\nax.set_xlim(0.8, 1.6)\nax.set_xlabel('Band Gap energy (eV)')\nax.set_ylabel('Efficiency (%)')\nax2.set_ylabel(r'Photon flux (s$^{-1}$ m$^{-2}$ eV$^{-1}$)')\nax.legend()\nax2.legend()\n\n&lt;matplotlib.legend.Legend at 0x2c4c9d1d0&gt;\n\n\n\n\n\nThe maximum band-gap energy moves to lower energies with increaseing solar concentration. This arises since although the current increases with increasing solar concentration, the cell voltage also increases which means the optimal effiicency is obtained at lower band-gaps. However, the drop in band-gap energy is modest owing to a strong atmospheric absorption feature at 1.1um which serves to pin the optimum bandgap around 1.12eV.\n\n\nExercise: Concentrated AM0\nTry repeating the example above but use the AM0 extraterrestial spectrum. Observe what happens to the band-gap shift with increasing concentration. How is it different to AM1.5d?"
  },
  {
    "objectID": "solcore-workshop/notebooks/4-Spectral2.html",
    "href": "solcore-workshop/notebooks/4-Spectral2.html",
    "title": "Section 4: Calculating Spectral Irradiance using SPCTRAL 2",
    "section": "",
    "text": "SPCTRAL 2 is a clear-sky spectral irradiance model that accounts for variations in the atmospheric conditions and air-mass. Developed at NREL in 1984, it generates terrestrial spectral irradiance from 300nm to 4um with a resolution of approximately 10nm.\n“Simple Solar Spectral Model for Direct and Diffuse Irradiance on Horizontal and Tilted Planes at the Earth’s Surface for Cloudless Atmospheres”, R. Bird, C. Riordan, December 1984\nThe Solcore implementation accomodates the following inputs (stated values are defaults):\nAll the inputs are numeric other than the aod_model whose options are: ‘rural’, ‘urban’, ‘maritime’ and ‘tropospheric’."
  },
  {
    "objectID": "solcore-workshop/notebooks/4-Spectral2.html#comparison-between-spctral2-with-default-parameters-and-am1.5g",
    "href": "solcore-workshop/notebooks/4-Spectral2.html#comparison-between-spctral2-with-default-parameters-and-am1.5g",
    "title": "Section 4: Calculating Spectral Irradiance using SPCTRAL 2",
    "section": "Comparison between SPCTRAL2 with default parameters and AM1.5G",
    "text": "Comparison between SPCTRAL2 with default parameters and AM1.5G\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom solcore.light_source import LightSource\n\n# Setup the AM1.5G solar spectrum\nwl = np.linspace(300, 4000, 4000) * 1e-9    #wl contains the x-ordinate in wavelength\nam15g = LightSource(source_type='standard', x=wl*1e9, version='AM1.5g')\n\nspc2default = LightSource(source_type='SPECTRAL2',  x=wl * 1e9)\n\nplt.figure()\nplt.title(\"Comparing SPCTRAL 2 vs AM1.5G\")\nplt.plot(*am15g.spectrum(wl*1e9), label='AM1.5G')\nplt.plot(*spc2default.spectrum(wl*1e9), label='SPC-default')\nplt.xlim(300, 3000)\nplt.xlabel('Wavelength (nm)')\nplt.ylabel('Power density (Wm$^{-2}$nm$^{-1}$)')\nplt.legend()\n\nWARNING: The RCWA solver will not be available because an S4 installation has not been found.\n\n\n&lt;matplotlib.legend.Legend at 0x17bf9e6e0&gt;"
  },
  {
    "objectID": "solcore-workshop/notebooks/4-Spectral2.html#adjusting-the-precipitable-water-value",
    "href": "solcore-workshop/notebooks/4-Spectral2.html#adjusting-the-precipitable-water-value",
    "title": "Section 4: Calculating Spectral Irradiance using SPCTRAL 2",
    "section": "Adjusting the precipitable water value",
    "text": "Adjusting the precipitable water value\nThe default SPCTRAL2 parameters results in almost no atmospheric absorption. This suggests the precipitable water column thickness is much too low, the default is 0.00142 cm. Let’s increase that value to 1cm to roughly match AM1.5G:\n\nspc2pc = LightSource(source_type='SPECTRAL2', precipwater=1.0, x=wl * 1e9)\n\nplt.figure()\nplt.title('Comparions between SPCTRAL2 defaults, 1cm precipitable water & AM1.5G')\nplt.plot(*am15g.spectrum(wl*1e9), label='AM1.5G')\nplt.plot(*spc2default.spectrum(wl*1e9), label='SPC-default')\nplt.plot(*spc2pc.spectrum(wl*1e9), label='PC water')\n\nplt.xlim(300, 3000)\nplt.xlabel('Wavelength (nm)')\nplt.ylabel('Power density (Wm$^{-2}$nm$^{-1}$)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x17e151690&gt;"
  },
  {
    "objectID": "solcore-workshop/notebooks/4-Spectral2.html#atmospheric-turbidity",
    "href": "solcore-workshop/notebooks/4-Spectral2.html#atmospheric-turbidity",
    "title": "Section 4: Calculating Spectral Irradiance using SPCTRAL 2",
    "section": "Atmospheric Turbidity",
    "text": "Atmospheric Turbidity\nThe short wavelength is attenuated which is likely due to a high level of aerosol loading in the default spectrum. To address this atmospheric turbidity can be reduced to around 0.05.\n\nspc2high = LightSource(source_type='SPECTRAL2', precipwater=1.0, turbidity=0.2, x=wl * 1e9)\nspc2med = LightSource(source_type='SPECTRAL2', precipwater=1.0, turbidity=0.1, x=wl * 1e9)\nspc2low = LightSource(source_type='SPECTRAL2', precipwater=1.0, turbidity=0.05, x=wl * 1e9)\n\nplt.figure()\nplt.title('Spectral Irradiance Plotted for Different Aersol Models')\nplt.plot(*am15g.spectrum(wl*1e9), label='AM1.5G')\nplt.plot(*spc2high.spectrum(wl*1e9), label='Turbidity = 0.2')\nplt.plot(*spc2med.spectrum(wl*1e9), label='Turbidity = 0.1')\nplt.plot(*spc2low.spectrum(wl*1e9), label='Turbidity = 0.05')\nplt.xlim(300, 3000)\nplt.xlabel('Wavelength (nm)')\nplt.ylabel('Power density (Wm$^{-2}$nm$^{-1}$)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x17e59a1d0&gt;"
  },
  {
    "objectID": "solcore-workshop/notebooks/4-Spectral2.html#variation-with-aerosol-models",
    "href": "solcore-workshop/notebooks/4-Spectral2.html#variation-with-aerosol-models",
    "title": "Section 4: Calculating Spectral Irradiance using SPCTRAL 2",
    "section": "Variation with Aerosol models",
    "text": "Variation with Aerosol models\nSeveral standard aerosol models are implemented in SPCTRAL 2 that were established by Shettle & Fenn.\nShettle, E. P., and R. W. Fenn, “Models of the Atmospheric Aerosol and Their Optical Properties, II Proceedings of the Advisory Group for Aerospace Reseach and Development Conference No . 183, Optical Propagation in the Atmosphere, 1975, pp. 2.1-2.16. Presented at the Electromagnetic Wave Propagation Panel Symposium, Lyngby, Denmark; 27-31 October 1975.\nHere we plot some of them with a turbidity of 0.2 to emphasise the different spectral behaviour:\n\nspc2rural = LightSource(source_type='SPECTRAL2', precipwater=1.0, turbidity=0.2,\n                        aod_model='rural', x=wl * 1e9)\nspc2marit = LightSource(source_type='SPECTRAL2', precipwater=1.0, turbidity=0.2,\n                        aod_model='maritime', x=wl * 1e9)\nspc2tropo = LightSource(source_type='SPECTRAL2', precipwater=1.0, turbidity=0.2,\n                        aod_model='tropospheric', x=wl * 1e9)\n\nplt.figure(1)\nplt.title('Spectral Irradiance Plotted for Different Aersol Models')\nplt.plot(*am15g.spectrum(wl*1e9), label='AM1.5G')\nplt.plot(*spc2rural.spectrum(wl*1e9), label='rural')\nplt.plot(*spc2marit.spectrum(wl*1e9), label='maritime')\nplt.plot(*spc2tropo.spectrum(wl*1e9), label='tropospheric')\nplt.xlim(300, 3000)\nplt.xlabel('Wavelength (nm)')\nplt.ylabel('Power density (Wm$^{-2}$nm$^{-1}$)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x17ea1a6e0&gt;"
  },
  {
    "objectID": "solcore-workshop/notebooks/4-Spectral2.html#changing-the-time-of-day",
    "href": "solcore-workshop/notebooks/4-Spectral2.html#changing-the-time-of-day",
    "title": "Section 4: Calculating Spectral Irradiance using SPCTRAL 2",
    "section": "Changing the time of day",
    "text": "Changing the time of day\nOne of the most common uses for a spectral irradiance model such as SPCTRAL2 is to calculate how a particular solar cell technology behaves under varying spectral conditions during the day. This is particularly important whan working with series connected tandem solar cells where the current matching condition will vary according to the incident spectrum. Here we plot the spectral irradiance at 12pm, 2pm, 3pm, 4pm, 5pm, 6pm and 7pm. Note the strong relative loss in short-wavelength light relative to the infrared as the air-mass increases throughout the afternoon.\n\nimport datetime\n\nplt.figure(1)\nplt.title('Spectral Irradiance plotted from 12pm-7pm')\nhours=[12, 14, 15, 16, 17, 18, 19]\n\nfor h in hours:\n    spc2 = LightSource(source_type='SPECTRAL2', dateAndTime=datetime.datetime(2011, 6, 30, h, 00),\n                       precipwater=1.0, turbidity=0.05, x=wl * 1e9)\n    plt.plot(*spc2.spectrum(wl*1e9), label='hour '+ str(h))\n\nplt.xlim(300, 3000)\nplt.xlabel('Wavelength (nm)')\nplt.ylabel('Power density (Wm$^{-2}$nm$^{-1}$)')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x17ec62380&gt;"
  },
  {
    "objectID": "solcore-workshop/notebooks/5a-simple_Si_cell.html",
    "href": "solcore-workshop/notebooks/5a-simple_Si_cell.html",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "",
    "text": "In this first set of examples, we will look at simple planar Si solar cell.\nIn this script, we will look at the difference between Beer-Lambert absorption calculations, using the Fresnel equations for front-surface reflection, and using the transfer-matrix model.\nFirst, lets import some very commonly-used Python packages:\nimport numpy as np\nimport matplotlib.pyplot as plt\nNumpy is a Python library which adds supports for multi-dimensional data arrays and matrices, so it is very useful for storing and handling data. You will probably use it in every Solcore script you write. Here, it is imported under the alias ‘np’, which you will see used below. matplotlib is used for making plots, and is imported under the alias ‘plt’. Both the ‘np’ and ‘plt’ aliases are extremely commonly used in Python programming.\nNow, let’s import some things from Solcore (which will be explained as we use them):\nfrom solcore import material, si\nfrom solcore.solar_cell import SolarCell, Layer, Junction\nfrom solcore.solar_cell_solver import solar_cell_solver\nfrom solcore.interpolate import interp1d"
  },
  {
    "objectID": "solcore-workshop/notebooks/5a-simple_Si_cell.html#defining-materials",
    "href": "solcore-workshop/notebooks/5a-simple_Si_cell.html#defining-materials",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "Defining materials",
    "text": "Defining materials\nTo define our solar cell, we first want to define some materials. Then we want to organise those materials into Layers, organise those layers into a Junction (or multiple Junctions, for a multi-junction cell, as we will see later), and then finally define a SolarCell with that Junction.\nFirst, let’s define a silicon material. Silicon, along with many other semiconductors, dielectrics, and metals common in solar cells, is included in Solcore’s database:\n\nSi = material(\"Si\")\n\nThis creates an instance of the Si material. However, to use this in a solar cell we need to do specify some more information, specifically the doping level and the minority carrier diffusion length. The ‘si’ function comes in handy here to convert all quantities to base units e.g. m, m\\(^{-3}\\)…\n\nSi_n = Si(Nd=si(\"1e21cm-3\"), hole_diffusion_length=si(\"10um\"))\nSi_p = Si(Na=si(\"1e16cm-3\"), electron_diffusion_length=si(\"400um\"))"
  },
  {
    "objectID": "solcore-workshop/notebooks/5a-simple_Si_cell.html#defining-layers",
    "href": "solcore-workshop/notebooks/5a-simple_Si_cell.html#defining-layers",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "Defining layers",
    "text": "Defining layers\nNow we define the emitter and base layers we will have in the solar cell; we specify their thickness, the material they are made of and the role they play within the cell (emitter or base). We create a junction which is a total of 200 \\(\\mu\\)m thick, with a 1 \\(\\mu\\)m junction depth.\n\nemitter_layer = Layer(width=si(\"1um\"), material=Si_n, role='emitter')\nbase_layer = Layer(width=si(\"199um\"), material=Si_p, role='base')\n\nNow we create the p-n junction using the layers defined above. We set kind=“DA” to tell Solcore to use the Depletion Approximation in the calculation:\n\nSi_junction = Junction([emitter_layer, base_layer], kind=\"DA\")"
  },
  {
    "objectID": "solcore-workshop/notebooks/5a-simple_Si_cell.html#setting-user-options",
    "href": "solcore-workshop/notebooks/5a-simple_Si_cell.html#setting-user-options",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "Setting user options",
    "text": "Setting user options\nWavelengths we want to use in the calculations; wavelengths between 300 and 1200 nm, at 200 evenly spaced intervals:\n\nwavelengths = si(np.linspace(300, 1200, 200), \"nm\")\n\nNote that here and above in defining the layers and materials we have used the “si()” function multiple times: you can use this to automatically convert quantities in other units to base SI units (e.g. nanometres to metres).\nNow we specify some options for running the calculation. Initially we will use the Beer-Lambert absorption law (\\(I(z) = I_0 e^{-\\alpha*z}\\)) to calculate the optics of the cell (“BL”). We set the wavelengths we want to use, and we set “recalculate_absorption” to True so that further down in the script when we try different optics methods, Solcore knows we want to re-calculate the optics of the cell rather than re-using previous results. We can specify the options in a Python format called a dictionary:\n\noptions = {\n    \"recalculate_absorption\": True,\n    \"optics_method\": \"BL\",\n    \"wavelength\": wavelengths\n           }"
  },
  {
    "objectID": "solcore-workshop/notebooks/5a-simple_Si_cell.html#running-cell-simulations",
    "href": "solcore-workshop/notebooks/5a-simple_Si_cell.html#running-cell-simulations",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "Running cell simulations",
    "text": "Running cell simulations\nDefine the solar cell; in this case it is very simple and we just have a single junction:\n\nsolar_cell = SolarCell([Si_junction])\n\nNow we use solar_cell_solver to calculate the QE of the cell; we can ask solar_cell_solver to calculate ‘qe’, ‘optics’ or ‘iv’.\n\nsolar_cell_solver(solar_cell, 'qe', options)\n\nSolving QE of the solar cell...\n\n\nPLOT 1: plotting the QE in the Si junction, as well as the fraction of light absorbed in the junction and reflected. Because we are using the Beer-Lambert absorption law and we did not specify external reflectance, the reflectance = 0 over the whole wavelength range.\n\nplt.figure()\nplt.plot(wavelengths*1e9, 100*solar_cell[0].eqe(wavelengths), 'k-', label=\"EQE\")\nplt.plot(wavelengths*1e9, 100*solar_cell[0].layer_absorption, label='Absorptance (A)')\nplt.plot(wavelengths*1e9, 100*solar_cell.reflected, label='Reflectance (R)')\nplt.legend()\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"QE/Absorptance (%)\")\nplt.title(\"(1) QE of Si cell - Beer-Lambert absorption\")\nplt.show()"
  },
  {
    "objectID": "solcore-workshop/notebooks/5a-simple_Si_cell.html#adding-front-surface-reflection-fresnel",
    "href": "solcore-workshop/notebooks/5a-simple_Si_cell.html#adding-front-surface-reflection-fresnel",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "Adding front-surface reflection: Fresnel",
    "text": "Adding front-surface reflection: Fresnel\nNow, to make this calculation a bit more realistic, there are a few things we could do. We could load some measured front surface reflectance from a file, or we could calculate the reflectance. To calculate the reflectance, there are many approaches we could take; we are going to explore two of them here.\nIf we assume the silicon is infinitely thick (or at least much thicker than the wavelengths of light we care about) then the reflectance will approach the reflectivity of a simple air/Si interface. We can calculate what this is using the Fresnel equation for reflectivity.\n\ndef calculate_R_Fresnel(incidence_n, transmission_n, wl):\n    # return a function that gives the value of R (at normal incidence) at the input wavelengths\n\n    Rs = np.abs((incidence_n - transmission_n)/(incidence_n + transmission_n))**2\n\n    return interp1d(wl, Rs)\n\nThe transmission_n is the complex reflective index of Si at our wavelengths for the transmission medium (Si), which we can extract easily from the Si material object in Solcore. The incidence_n = 1 (air). Note that the function above is specifically for normal incidence.\n\ntrns_n = Si_n.n(wavelengths) + 1j*Si_n.k(wavelengths)\nreflectivity_fn = calculate_R_Fresnel(1, trns_n, wavelengths)\n\nWe define the solar cell again, with the same layers but now supplying the function for the externally-calculated reflectivity, and calculate the optics (reflection, absorption, transmission) again:\n\nsolar_cell_fresnel = SolarCell([Si_junction], reflectivity=reflectivity_fn)\n\nsolar_cell_solver(solar_cell_fresnel, 'optics', options)"
  },
  {
    "objectID": "solcore-workshop/notebooks/5a-simple_Si_cell.html#adding-front-surface-reflection-tmm",
    "href": "solcore-workshop/notebooks/5a-simple_Si_cell.html#adding-front-surface-reflection-tmm",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "Adding front surface reflection: TMM",
    "text": "Adding front surface reflection: TMM\nFinally, we do the same again but now instead of supplying the external reflectivity we ask set the optics_method to “TMM” (Transfer Matrix Method), to correctly calculate reflection at the front surface. We will learn more about the transfer matrix method later.\n\nSi_junction = Junction([emitter_layer, base_layer], kind=\"DA\")\n\nsolar_cell_TMM = SolarCell([Si_junction])\n\nSet some more options for the cell calculation:\n\noptions[\"optics_method\"] = \"TMM\"\nvoltages = np.linspace(0, 1.1, 100)\noptions[\"light_iv\"] = True\noptions[\"mpp\"] = True\noptions[\"voltages\"] = voltages\n\nwe calculate the QE and the IV (we set the light_iv option to True; if we don’t do this, Solcore just calculates the dark IV). We also ask Solcore to find the maximum power point (mpp) so we can get the efficiency.\n\nsolar_cell_solver(solar_cell_TMM, 'iv', options)\nsolar_cell_solver(solar_cell_TMM, 'qe', options)\n\nTreating layer(s) 1 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\nTreating layer(s) 1 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving QE of the solar cell...\n\n\nPLOT 2: here we plot the reflection, transmission, and absorption calculated with the Fresnel equation defined above, and with the TMM solver in Solcore, showing that for this simple situation (no anti-reflection coating, thick Si junction) they are exactly equivalent.\n\nplt.figure()\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.reflected, color='firebrick', label = \"R (TMM)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_fresnel.reflected, '--', color='orangered', label = \"R (Fresnel)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.absorbed, color='dimgrey', label = \"A (TMM)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_fresnel.absorbed, '--', color='lightgrey', label = \"A (Fresnel)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.transmitted, color='blue', label = \"T (TMM)\")\nplt.plot(wavelengths*1e9, 100*solar_cell_fresnel.transmitted, '--', color='dodgerblue', label = \"T (Fresnel)\")\nplt.ylim(0, 100)\nplt.legend()\nplt.title(\"(2) Optics of Si cell - Fresnel/TMM\")\nplt.show()\n\n\n\n\nPLOT 3: As above for the TMM calculation, plotting the EQE as well, which will be slightly lower than the absorption because not all the carriers are collected. Comparing to plot (1), we can see we now have lower absorption due to the inclusion of front surface reflection, which is ~ 30% or more over the wavelength range of interest for a bare Si surface.\n\nplt.figure()\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM[0].eqe(wavelengths), 'k-', label=\"EQE\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM[0].layer_absorption, label='A')\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.reflected, label=\"R\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM.transmitted, label=\"T\")\nplt.title(\"(3) QE of Si cell (no ARC) - TMM\")\nplt.legend()\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"QE/Absorptance (%)\")\nplt.ylim(0, 100)\nplt.show()"
  },
  {
    "objectID": "solcore-workshop/notebooks/5a-simple_Si_cell.html#adding-an-arc",
    "href": "solcore-workshop/notebooks/5a-simple_Si_cell.html#adding-an-arc",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "Adding an ARC",
    "text": "Adding an ARC\nThe reflectance of bare Si is very high. Let’s try adding a simple anti-reflection coating (ARC), a single layer of silicon nitride (Si\\(_3\\)N\\(_4\\)):\n\nSiN = material(\"Si3N4\")()\n\nSi_junction = Junction([emitter_layer, base_layer], kind=\"DA\")\n\nsolar_cell_TMM_ARC = SolarCell([Layer(width=si(75, \"nm\"), material=SiN), Si_junction])\n\nsolar_cell_solver(solar_cell_TMM_ARC, 'qe', options)\nsolar_cell_solver(solar_cell_TMM_ARC, 'iv', options)\n\nTreating layer(s) 2 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving QE of the solar cell...\nTreating layer(s) 2 incoherently\nCalculating RAT...\nCalculating absorption profile...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell...\n\n\nPLOT 4: Absorption, EQE, reflection and transmission for the cell with a simple one-layer ARC. We see the reflection is significantly reduced from the previous plot leading to higher absorption/EQE.\n\nplt.figure()\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM_ARC[1].eqe(wavelengths), 'k-', label=\"EQE\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM_ARC[1].layer_absorption, label='A')\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM_ARC.reflected, label=\"R\")\nplt.plot(wavelengths*1e9, 100*solar_cell_TMM_ARC.transmitted, label=\"T\")\nplt.legend()\nplt.title(\"(4) QE of Si cell (ARC) - TMM\")\nplt.xlabel(\"Wavelength (nm)\")\nplt.ylabel(\"QE/Absorptance (%)\")\nplt.ylim(0, 100)\nplt.show()\n\n\n\n\nPLOT 5: Compare the IV curves of the cells with and without an ARC. The efficiency is also shown on the plot. Note that because we didn’t specify a light source, Solcore will assume we want to use AM1.5G; in later examples we will set the light source used for light IV simulations explicitly.\n\nplt.figure()\nplt.plot(voltages, -solar_cell_TMM[0].iv(voltages)/10, label=\"No ARC\")\nplt.plot(voltages, -solar_cell_TMM_ARC[1].iv(voltages)/10, label=\"75 nm SiN\")\nplt.text(0.5, 1.02*solar_cell_TMM.iv[\"Isc\"]/10, str(round(solar_cell_TMM.iv[\"Eta\"]*100,\n                                                      1)) + ' %')\nplt.text(0.5, 1.02*solar_cell_TMM_ARC.iv[\"Isc\"]/10, str(round(solar_cell_TMM_ARC\n                                                          .iv[\"Eta\"]*100, 1)) + ' %')\nplt.ylim(0, 38)\nplt.xlim(0, 0.8)\nplt.legend()\nplt.xlabel(\"V (V)\")\nplt.ylabel(r\"J (mA/cm$^2$)\")\nplt.title(\"(5) IV curve of Si cell with and without ARC\")\nplt.show()"
  },
  {
    "objectID": "solcore-workshop/notebooks/5a-simple_Si_cell.html#conclusions",
    "href": "solcore-workshop/notebooks/5a-simple_Si_cell.html#conclusions",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "Conclusions",
    "text": "Conclusions\nWe see that the cell with an ARC has a significantly higher \\(J_{sc}\\), and a slightly higher \\(V_{oc}\\), than the bare Si cell. In reality, most Si cells have a textured surface rather than a planar surface with an ARC; this will be discussed later in the course.\nOverall, some things we can take away from the examples in this script:\n\nThe Beer-Lambert law is a very simple way to calculate absorption in a cell, but won’t take into account important effects such as front-surface reflection or the effects of anti-reflection coatings.\nUsing the transfer-matrix method (TMM), we can account for front surface reflection and interference effects which make e.g. ARCs effective. In the simple situation of a thick cell without any front surface layers, it is equivalent to simply calculating the reflection with the Fresnel equations and assuming Beer-Lambert absorption in the cell.\nAdding a simple, one-layer ARC can significantly reduce front-surface reflection for a single-junction cell, leading to improved short-circuit current. To correctly account for interference in this layer, which is what causes its anti-reflective properties, we most use the transfer-matrix method (TMM) optical solver."
  },
  {
    "objectID": "solcore-workshop/notebooks/5a-simple_Si_cell.html#questions",
    "href": "solcore-workshop/notebooks/5a-simple_Si_cell.html#questions",
    "title": "Section 5a: Planar Si solar cell using DA",
    "section": "Questions",
    "text": "Questions\n\nWhich parameters could we change which would affect the EQE and/or IV of the cell?\nWhy can’t we just use the Fresnel equations to calculate the effect of an anti-reflection coating?"
  },
  {
    "objectID": "solcore-workshop/notebooks/5b-simple_GaAs_cell.html",
    "href": "solcore-workshop/notebooks/5b-simple_GaAs_cell.html",
    "title": "Section 5b: GaAs solar cell",
    "section": "",
    "text": "First we need to set up the calculation, so we import the libraries we need and some semiconductor material properties. Our solar cell has a single layer SiN anti-reflection coating, an Al\\(_{0.8}\\)GaAs window layer and GaAs p/n absorber regions.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom solcore import siUnits, material, si\nfrom solcore.solar_cell import SolarCell\nfrom solcore.structure import Junction, Layer\nfrom solcore.solar_cell_solver import solar_cell_solver\nfrom solcore.light_source import LightSource\nfrom pathlib import Path\n\ndef this_dir_file(f):\n    file_path = Path.cwd()\n    return file_path / \"data\" /  f\n\nqeData = np.loadtxt(this_dir_file(\"QT1405R.csv\"), unpack=True, delimiter=\",\")\n\n# Define the solar spectrum we wish to use for Light-IV calculations\nwl = np.linspace(300, 900, 400) * 1e-9  # Define the wavelength range of interest\nam15spectrum = LightSource(source_type='standard',version='AM1.5g',x=wl,output_units='photon_flux_per_m')\n\n# Define the materials we use for the calculation\nARC = material(\"Si3N4\")()\nAlGaAs = material(\"AlGaAs\")\nwindow_material = AlGaAs(Al=0.80)\nGaAs = material(\"GaAs\")\n\n# Configure the GaAs materials, n & p type.\ngaas_n_material = GaAs(Nd=siUnits(3e18, \"cm-3\"),\n                       hole_diffusion_length=si(\"500nm\"),\n                       hole_mobility=5e-2\n                       )\ngaas_p_material = GaAs(Na=siUnits(1e17, \"cm-3\"),\n                       electron_diffusion_length=si(\"5um\"),\n                       electron_mobility=5e-2\n                       )\n\nWe now want to build the solar cell from these layers. We start with the MgF2/ZnS AR coating, then the window layer, then GaAs p-doped emitter and finally the GaAs n-doped base. It is here, in the solar cell structure that we specify the layer thicknesses.\nThe default thicknesses below are not optimum and do not fit the EQE data at all! Try adjusting the thicknesses for the AR coating and the component layers to better fit the EQE data.\n\n# Configure the solar cell layer stack\nsolar_cell = SolarCell(\n    [Layer(si(\"200nm\"), ARC),\n     Junction([Layer(si(\"55nm\"), material=window_material, role='window'),\n                    Layer(si(\"800nm\"), material=gaas_p_material, role='emitter'),\n                  Layer(si(\"3000nm\"), material=gaas_n_material, role='base'),\n                  ], sn=1, sp=1, kind='DA')\n     ], shading=0.02, cell_area=1 / 1e4)\n\n\n# Calculate the solar cell QE\nsolar_cell_solver(solar_cell, 'qe', user_options={'wavelength': wl,'optics_method': 'TMM'})\n\n# Plot the QE - model and data\nplt.figure(1)\nplt.plot(wl * 1e9, solar_cell[1].eqe(wl) * 100, 'k', label='Model')\nplt.plot(qeData[0],qeData[1]*100,marker=\"o\",markeredgecolor=\"red\", label='Data')\nplt.plot(wl * 1e9, solar_cell.reflected*100, label='Reflection')\nplt.legend()\nplt.ylim(0, 100)\nplt.ylabel('EQE (%)')\nplt.xlabel('Wavelength (nm)')\n\nplt.show()\n\n# Plot the QE - contributions of the base, SCR (space charge region), and emitter\nplt.figure(1)\nplt.plot(wl * 1e9, solar_cell[1].eqe(wl) * 100, 'k', label='Model (total)')\nplt.plot(wl * 1e9, solar_cell[1].eqe_emitter(wl) * 100, '--g', label='Emitter')\nplt.plot(wl * 1e9, solar_cell[1].eqe_scr(wl) * 100, '--r', label='SCR')\nplt.plot(wl * 1e9, solar_cell[1].eqe_base(wl) * 100, '--b', label='Base')\nplt.legend()\nplt.ylim(0, 100)\nplt.ylabel('EQE (%)')\nplt.xlabel('Wavelength (nm)')\n\nplt.show()\n\nCalculating RAT...\nCalculating absorption profile...\nSolving QE of the solar cell..."
  },
  {
    "objectID": "solcore-workshop/notebooks/5b-simple_GaAs_cell.html#fitting-the-eqe-of-a-gaas-solar-cell",
    "href": "solcore-workshop/notebooks/5b-simple_GaAs_cell.html#fitting-the-eqe-of-a-gaas-solar-cell",
    "title": "Section 5b: GaAs solar cell",
    "section": "",
    "text": "First we need to set up the calculation, so we import the libraries we need and some semiconductor material properties. Our solar cell has a single layer SiN anti-reflection coating, an Al\\(_{0.8}\\)GaAs window layer and GaAs p/n absorber regions.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom solcore import siUnits, material, si\nfrom solcore.solar_cell import SolarCell\nfrom solcore.structure import Junction, Layer\nfrom solcore.solar_cell_solver import solar_cell_solver\nfrom solcore.light_source import LightSource\nfrom pathlib import Path\n\ndef this_dir_file(f):\n    file_path = Path.cwd()\n    return file_path / \"data\" /  f\n\nqeData = np.loadtxt(this_dir_file(\"QT1405R.csv\"), unpack=True, delimiter=\",\")\n\n# Define the solar spectrum we wish to use for Light-IV calculations\nwl = np.linspace(300, 900, 400) * 1e-9  # Define the wavelength range of interest\nam15spectrum = LightSource(source_type='standard',version='AM1.5g',x=wl,output_units='photon_flux_per_m')\n\n# Define the materials we use for the calculation\nARC = material(\"Si3N4\")()\nAlGaAs = material(\"AlGaAs\")\nwindow_material = AlGaAs(Al=0.80)\nGaAs = material(\"GaAs\")\n\n# Configure the GaAs materials, n & p type.\ngaas_n_material = GaAs(Nd=siUnits(3e18, \"cm-3\"),\n                       hole_diffusion_length=si(\"500nm\"),\n                       hole_mobility=5e-2\n                       )\ngaas_p_material = GaAs(Na=siUnits(1e17, \"cm-3\"),\n                       electron_diffusion_length=si(\"5um\"),\n                       electron_mobility=5e-2\n                       )\n\nWe now want to build the solar cell from these layers. We start with the MgF2/ZnS AR coating, then the window layer, then GaAs p-doped emitter and finally the GaAs n-doped base. It is here, in the solar cell structure that we specify the layer thicknesses.\nThe default thicknesses below are not optimum and do not fit the EQE data at all! Try adjusting the thicknesses for the AR coating and the component layers to better fit the EQE data.\n\n# Configure the solar cell layer stack\nsolar_cell = SolarCell(\n    [Layer(si(\"200nm\"), ARC),\n     Junction([Layer(si(\"55nm\"), material=window_material, role='window'),\n                    Layer(si(\"800nm\"), material=gaas_p_material, role='emitter'),\n                  Layer(si(\"3000nm\"), material=gaas_n_material, role='base'),\n                  ], sn=1, sp=1, kind='DA')\n     ], shading=0.02, cell_area=1 / 1e4)\n\n\n# Calculate the solar cell QE\nsolar_cell_solver(solar_cell, 'qe', user_options={'wavelength': wl,'optics_method': 'TMM'})\n\n# Plot the QE - model and data\nplt.figure(1)\nplt.plot(wl * 1e9, solar_cell[1].eqe(wl) * 100, 'k', label='Model')\nplt.plot(qeData[0],qeData[1]*100,marker=\"o\",markeredgecolor=\"red\", label='Data')\nplt.plot(wl * 1e9, solar_cell.reflected*100, label='Reflection')\nplt.legend()\nplt.ylim(0, 100)\nplt.ylabel('EQE (%)')\nplt.xlabel('Wavelength (nm)')\n\nplt.show()\n\n# Plot the QE - contributions of the base, SCR (space charge region), and emitter\nplt.figure(1)\nplt.plot(wl * 1e9, solar_cell[1].eqe(wl) * 100, 'k', label='Model (total)')\nplt.plot(wl * 1e9, solar_cell[1].eqe_emitter(wl) * 100, '--g', label='Emitter')\nplt.plot(wl * 1e9, solar_cell[1].eqe_scr(wl) * 100, '--r', label='SCR')\nplt.plot(wl * 1e9, solar_cell[1].eqe_base(wl) * 100, '--b', label='Base')\nplt.legend()\nplt.ylim(0, 100)\nplt.ylabel('EQE (%)')\nplt.xlabel('Wavelength (nm)')\n\nplt.show()\n\nCalculating RAT...\nCalculating absorption profile...\nSolving QE of the solar cell..."
  },
  {
    "objectID": "solcore-workshop/notebooks/5b-simple_GaAs_cell.html#is-there-a-better-design-for-this-solar-gaas-cell",
    "href": "solcore-workshop/notebooks/5b-simple_GaAs_cell.html#is-there-a-better-design-for-this-solar-gaas-cell",
    "title": "Section 5b: GaAs solar cell",
    "section": "Is there a better design for this solar GaAs cell?",
    "text": "Is there a better design for this solar GaAs cell?\nNow that you have fitted the EQE, let’s calculate the efficiency under AM1.5G. Start with the same values you used above for the layer thicknesses. Can you design a better GaAs solar cell ?!\n\n# Configure the solar cell layer stack\nsolar_cell = SolarCell(\n    [Layer(si(\"200nm\"), ARC),\n     Junction([Layer(si(\"55nm\"), material=window_material, role='window'),\n                    Layer(si(\"800nm\"), material=gaas_p_material, role='emitter'),\n                  Layer(si(\"3000nm\"), material=gaas_n_material, role='base'),\n                  ], sn=1, sp=1, kind='DA')\n     ], shading=0.02, cell_area=1 / 1e4)\n\n\n# Calculate the solar cell QE\nsolar_cell_solver(solar_cell, 'qe', user_options={'wavelength': wl,'optics_method': 'TMM'})\n\n# Plot the QE\nplt.figure(1)\nplt.plot(wl * 1e9, solar_cell[1].eqe(wl) * 100, 'b', label='GaAs')\nplt.plot(qeData[0],qeData[1]*100,marker=\"o\",markeredgecolor=\"red\")\nplt.plot(wl * 1e9, solar_cell.reflected*100, label='Reflection')\nplt.legend()\nplt.ylim(0, 100)\nplt.ylabel('EQE (%)')\nplt.xlabel('Wavelength (nm)')\n\n# Plot the Light-IV\nV = np.linspace(0, 1.2, 200)\nsolar_cell_solver(solar_cell, 'iv', user_options={'voltages': V, 'light_iv': True, 'wavelength': wl,\n                                                  'optics_method': 'TMM','light_source':am15spectrum,\n                                                  'mpp':True})\n\nplt.figure(2)\nplt.plot(V, solar_cell.iv['IV'][1]/10, 'k', linewidth=3, label='GaAs')\n\nplt.legend()\nplt.ylim(0, 35)\nplt.xlim(0, 1.2)\nplt.ylabel('Current (mA/cm$^2$)')\nplt.xlabel('Voltage (V)')\nplt.text(0.1,20,f'Jsc {solar_cell.iv.Isc:.2f}')\nplt.text(0.1,18,f'Voc {solar_cell.iv.Voc:.2f}')\nplt.text(0.1,16,f'Eta {solar_cell.iv.Eta:.2f}')\n\nplt.show()\n\nCalculating RAT...\nCalculating absorption profile...\nSolving QE of the solar cell...\nSolving IV of the junctions...\nSolving IV of the tunnel junctions...\nSolving IV of the total solar cell..."
  },
  {
    "objectID": "solcore-workshop/notebooks/9b-GaInP_GaAs_Si_pyramids.html",
    "href": "solcore-workshop/notebooks/9b-GaInP_GaAs_Si_pyramids.html",
    "title": "Section 9b: Planar III-V epoxy-bonded to textured Si",
    "section": "",
    "text": "The structure in this example is based on that of the previous example (9a), but with the planar bottom Si cell replaced by a Si cell with a pyramidal texture, bonded to the III-V top cells with a low-index epoxy/glass layer.\nWe could use the angular redistribution matrix method as in the previous example - however, because in this example we only need to use TMM and ray-tracing (RT), we can use the ray-tracing method with integrated RT directly (this is generally faster, because we do not need to calculate the behaviour of the surfaces for every angle of incidence)."
  },
  {
    "objectID": "solcore-workshop/notebooks/9b-GaInP_GaAs_Si_pyramids.html#setting-up",
    "href": "solcore-workshop/notebooks/9b-GaInP_GaAs_Si_pyramids.html#setting-up",
    "title": "Section 9b: Planar III-V epoxy-bonded to textured Si",
    "section": "Setting up",
    "text": "Setting up\nWe load relevant packages and define materials, the same as in the previous example.\n\nfrom solcore import material, si\nfrom solcore.absorption_calculator import search_db, download_db\nimport os\nfrom solcore.structure import Layer\nfrom solcore.light_source import LightSource\nfrom rayflare.ray_tracing import rt_structure\nfrom rayflare.transfer_matrix_method import tmm_structure\nfrom rayflare.textures import planar_surface, regular_pyramids\nfrom rayflare.options import default_options\nfrom solcore.constants import q\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# download_db()\n\n\nMgF2_pageid = search_db(os.path.join(\"MgF2\", \"Rodriguez-de Marcos\"))[0][0];\nTa2O5_pageid = search_db(os.path.join(\"Ta2O5\", \"Rodriguez-de Marcos\"))[0][0];\nSU8_pageid = search_db(\"SU8\")[0][0];\nAg_pageid = search_db(os.path.join(\"Ag\", \"Jiang\"))[0][0];\n\nepoxy = material(\"BK7\")()\n\nMgF2 = material(str(MgF2_pageid), nk_db=True)();\nTa2O5 = material(str(Ta2O5_pageid), nk_db=True)();\nSU8 = material(str(SU8_pageid), nk_db=True)();\nAg = material(str(Ag_pageid), nk_db=True)();\n\nwindow = material(\"AlInP\")(Al=0.52)\nGaInP = material(\"GaInP\")\nAlGaAs = material(\"AlGaAs\")\n\nAir = material(\"Air\")()\n\nGaAs = material(\"GaAs\")\n\nSi = material(\"Si\")\n\nAl2O3 = material(\"Al2O3P\")()\nAl = material(\"Al\")()\n\nWe define the layers we will need, as before. We specify the thickness of the silicon (280 \\(\\mu\\)m) and epoxy (1 mm) at the top:\n\nd_Si = 280e-6 # thickness of Si wafer\nd_epoxy = 1e-3 # thickness of epoxy\n\nARC = [\n    Layer(110e-9, MgF2),\n    Layer(65e-9, Ta2O5),\n]\n\nGaInP_junction = [\n    Layer(17e-9, window),\n    Layer(400e-9, GaInP(In=0.50)),\n    Layer(100e-9, AlGaAs(Al=0.8))]\n\n# 100 nm TJ\ntunnel_1 = [\n    Layer(80e-9, AlGaAs(Al=0.8)),\n    Layer(20e-9, GaInP(In=0.5)),\n]\n\nGaAs_junction = [\n    Layer(17e-9, GaInP(In=0.5), role=\"window\"),\n    Layer(1050e-9, GaAs()),\n    Layer(70e-9, AlGaAs(Al=0.8), role=\"bsf\")]\n\nspacer_ARC = [\n    Layer(80e-9, Ta2O5),\n]"
  },
  {
    "objectID": "solcore-workshop/notebooks/9b-GaInP_GaAs_Si_pyramids.html#defining-the-cell-layers",
    "href": "solcore-workshop/notebooks/9b-GaInP_GaAs_Si_pyramids.html#defining-the-cell-layers",
    "title": "Section 9b: Planar III-V epoxy-bonded to textured Si",
    "section": "Defining the cell layers",
    "text": "Defining the cell layers\nThere are three interfaces in the cell which will define the structure to simulate:\n\nthe III-V/epoxy interface, where the epoxy itself will be treated as a bulk layer in the simulation\nthe epoxy/Si interface, where the Si has a pyramidal texture (the Si itself is another bulk layer in the simulation).\nthe rear surface of the cell, where the Si again has a pyramidal texture (and we assume there is a silver back mirror behind the cell)\n\nThese 3 interfaces are defined here, using the pre-defined textures for a planar surface or regular pyramids:\n\nfront_layers = ARC + GaInP_junction + tunnel_1 + GaAs_junction + spacer_ARC\n\nfront_surf = planar_surface(\n    interface_layers = front_layers\n)\n\nSi_front = regular_pyramids(\n    elevation_angle=50,\n    upright=True,\n)\n\nSi_back = regular_pyramids(\n    elevation_angle=50,\n    upright=False,\n)\n\nNow we set relevant options for the solver. We set the number of rays to trace at each wavelength (more rays will make the result less noisy, but increase computation time) and whether to calculate the absorption profile in the bulk layers (no, in this case). The randomize_surface options determines whether the ray keeps track of its positions in the unit cell while travelling between surfaces; we set this to False to mimic random pyramids.\n\noptions = default_options()\n\nwl = np.arange(300, 1201, 10) * 1e-9\nAM15G = LightSource(source_type=\"standard\", version=\"AM1.5g\", x=wl,\n                    output_units=\"photon_flux_per_m\")\n\noptions.wavelengths = wl\noptions.project_name = \"III_V_Si_cell\"\n\n# options for ray-tracing\noptions.randomize_surface = True\noptions.n_rays = 1000\noptions.bulk_profile = False"
  },
  {
    "objectID": "solcore-workshop/notebooks/9b-GaInP_GaAs_Si_pyramids.html#defining-the-structures",
    "href": "solcore-workshop/notebooks/9b-GaInP_GaAs_Si_pyramids.html#defining-the-structures",
    "title": "Section 9b: Planar III-V epoxy-bonded to textured Si",
    "section": "Defining the structures",
    "text": "Defining the structures\nFinally, we define the ray-tracing structure we will use, using the interfaces, bulk materials, and options set above. Because we want to calculate the reflection/absorption/transmission probabilities at the front surface using TMM, we set the use_TMM argument to True. We also define a completely planar cell with the same layer thicknesses etc. to compare and evaluate the effect of the textures Si surfaces.\n\nsolar_cell = rt_structure(\n    textures=[front_surf, Si_front, Si_back],\n    materials=[epoxy, Si()],\n    widths=[d_epoxy, d_Si],\n    incidence=Air,\n    transmission=Ag,\n    options=options,\n    use_TMM=True,\n    save_location=\"current\", # lookup table save location\n    overwrite=True, # whether to overwrite any previously existing results, if found\n)\n\n# options for TMM\noptions.coherent = False\noptions.coherency_list = len(front_layers)*['c'] + ['i']*2\n\nsolar_cell_planar = tmm_structure(\n    layer_stack = front_layers + [Layer(d_epoxy, epoxy), Layer(d_Si, Si())],\n    incidence=Air,\n    transmission=Ag,\n)\n\nPre-computing TMM lookup table(s)\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/MgF2/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/MgF2/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/Ta2O5/Rodriguez-de Marcos.yml loaded.\nDatabase file found at /Users/phoebe/.solcore/nk/nk.db\nMaterial main/Ta2O5/Rodriguez-de Marcos.yml loaded."
  },
  {
    "objectID": "solcore-workshop/notebooks/9b-GaInP_GaAs_Si_pyramids.html#calculations",
    "href": "solcore-workshop/notebooks/9b-GaInP_GaAs_Si_pyramids.html#calculations",
    "title": "Section 9b: Planar III-V epoxy-bonded to textured Si",
    "section": "Calculations",
    "text": "Calculations\nCalculate the R/A/T for the planar reference cell:\n\ntmm_result = solar_cell_planar.calculate(options=options)\n\nGaInP_A_tmm = tmm_result['A_per_layer'][:,3]\nGaAs_A_tmm = tmm_result['A_per_layer'][:,8]\nSi_A_tmm = tmm_result['A_per_layer'][:,len(front_layers)+1]\n\nJmax_GaInP_tmm = q*np.trapz(GaInP_A_tmm*AM15G.spectrum()[1], x=wl)/10\nJmax_GaAs_tmm = q*np.trapz(GaAs_A_tmm*AM15G.spectrum()[1], x=wl)/10\nJmax_Si_tmm = q*np.trapz(Si_A_tmm*AM15G.spectrum()[1], x=wl)/10\n\nCalculate the R/A/T for the textured cell:\n\nrt_result = solar_cell.calculate(options=options)\n\nGaInP_absorption_ARC = rt_result['A_per_interface'][0][:,3]\nGaAs_absorption_ARC = rt_result['A_per_interface'][0][:,8]\nSi_absorption_ARC = rt_result['A_per_layer'][:,1]\n\nJmax_GaInP = q*np.trapz(GaInP_absorption_ARC*AM15G.spectrum()[1], x=wl)/10\nJmax_GaAs = q*np.trapz(GaAs_absorption_ARC*AM15G.spectrum()[1], x=wl)/10\nJmax_Si = q*np.trapz(Si_absorption_ARC*AM15G.spectrum()[1], x=wl)/10"
  },
  {
    "objectID": "solcore-workshop/notebooks/9b-GaInP_GaAs_Si_pyramids.html#plotting-the-results",
    "href": "solcore-workshop/notebooks/9b-GaInP_GaAs_Si_pyramids.html#plotting-the-results",
    "title": "Section 9b: Planar III-V epoxy-bonded to textured Si",
    "section": "Plotting the results",
    "text": "Plotting the results\nFinally, we plot the results; the solid lines show the results for the textured Si cell (calculated using ray-tracing), the dashed lines for the planar cell (calculated using TMM). The maximum possible currents are shown in the plot, with the value in brackets for Si being for the planar cell.\n\nplt.figure(figsize=(6,3))\nplt.plot(wl * 1e9, GaInP_absorption_ARC, \"-k\", label=\"GaInP\")\nplt.plot(wl * 1e9, GaAs_absorption_ARC, \"-b\", label=\"GaAs\")\nplt.plot(wl * 1e9, Si_absorption_ARC, \"-r\", label=\"Si\")\nplt.plot(wl * 1e9, GaInP_A_tmm, \"--k\")\nplt.plot(wl * 1e9, GaAs_A_tmm, \"--b\")\nplt.plot(wl * 1e9, Si_A_tmm, \"--r\")\nplt.plot(wl * 1e9, rt_result['R'], '-', color='grey', label=\"Reflected\")\nplt.plot(wl * 1e9, tmm_result['R'], '--', color='grey')\n\nplt.text(420, 0.55, r\"{:.1f} mA/cm$^2$\".format(Jmax_GaInP))\nplt.text(670, 0.55, r\"{:.1f} mA/cm$^2$\".format(Jmax_GaAs))\nplt.text(870, 0.55, r\"{:.1f} mA/cm$^2$\".format(Jmax_Si))\nplt.text(870, 0.45, r\"({:.1f} mA/cm$^2)$\".format(Jmax_Si_tmm))\n\nplt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "solcore-workshop/notebooks/9b-GaInP_GaAs_Si_pyramids.html#questionschallenges",
    "href": "solcore-workshop/notebooks/9b-GaInP_GaAs_Si_pyramids.html#questionschallenges",
    "title": "Section 9b: Planar III-V epoxy-bonded to textured Si",
    "section": "Questions/challenges",
    "text": "Questions/challenges\n\nDoes it make sense to do a ray-tracing calculation for short wavelengths? For this structure, can you speed up the calculation and avoid the random noise at short wavelengths?\nHow much current is lost to parasitic absorption in e.g. tunnel junctions, window layers etc.?\nHow can we reduce reflection at the epoxy interfaces?\nIf the epoxy/glass layer is much thicker than the relevant incident wavelengths, and not absorbing, does the exact thickness matter in the simulation?\nWhat happens if only the rear surface is textured? Would a structure without the front texture have other advantages?\nWhy does the Si have lower absorption/limiting current in this structure compared to the previous example?"
  }
]